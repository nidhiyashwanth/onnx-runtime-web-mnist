/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d91e":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "static/media/ort.bundle.min.8af89744.mjs";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.2e583633.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fpreload-css.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fsrc%2Fcomponents%2FDigitRecognizer.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fpreload-css.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fsrc%2Fcomponents%2FDigitRecognizer.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/DigitRecognizer.tsx */ \"(app-pages-browser)/./src/components/DigitRecognizer.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZldm9iaWRldiUyRkRlc2t0b3AlMkZSZWFjdCUyRm9ubngtbWwlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRnNoYXJlZCUyRmxpYiUyRmxhenktZHluYW1pYyUyRmR5bmFtaWMtYmFpbG91dC10by1jc3IuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZldm9iaWRldiUyRkRlc2t0b3AlMkZSZWFjdCUyRm9ubngtbWwlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRnNoYXJlZCUyRmxpYiUyRmxhenktZHluYW1pYyUyRnByZWxvYWQtY3NzLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGZXZvYmlkZXYlMkZEZXNrdG9wJTJGUmVhY3QlMkZvbm54LW1sJTJGc3JjJTJGY29tcG9uZW50cyUyRkRpZ2l0UmVjb2duaXplci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4UUFBbUo7QUFDbko7QUFDQSx3UEFBd0k7QUFDeEk7QUFDQSxrTUFBNkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9jNDA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2V2b2JpZGV2L0Rlc2t0b3AvUmVhY3Qvb25ueC1tbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2R5bmFtaWMtYmFpbG91dC10by1jc3IuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9ldm9iaWRldi9EZXNrdG9wL1JlYWN0L29ubngtbWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2xhenktZHluYW1pYy9wcmVsb2FkLWNzcy5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2V2b2JpZGV2L0Rlc2t0b3AvUmVhY3Qvb25ueC1tbC9zcmMvY29tcG9uZW50cy9EaWdpdFJlY29nbml6ZXIudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fpreload-css.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fsrc%2Fcomponents%2FDigitRecognizer.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"BailoutToCSR\", ({\n    enumerable: true,\n    get: function() {\n        return BailoutToCSR;\n    }\n}));\nconst _bailouttocsr = __webpack_require__(/*! ./bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nfunction BailoutToCSR(param) {\n    let { reason, children } = param;\n    if (typeof window === \"undefined\") {\n        throw new _bailouttocsr.BailoutToCSRError(reason);\n    }\n    return children;\n} //# sourceMappingURL=dynamic-bailout-to-csr.js.map\n_c = BailoutToCSR;\nvar _c;\n$RefreshReg$(_c, \"BailoutToCSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBY08sTUFBQUEsZ0JBQXNCQyxtQkFBQUEsQ0FBdUM7U0FBdkNDLGFBQVVDLEtBQVE7SUFDN0MsSUFBSSxFQUFBQyxNQUFPQyxFQUFBQSxRQUFXLEtBQUFDO1FBQ3BCLE9BQU1ELFdBQUlFLGFBQUFBO1FBQ1osVUFBQVAsY0FBQU8saUJBQUEsQ0FBQUg7SUFFQTtJQUNGLE9BQUFEOztLQU42QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2xhenktZHluYW1pYy9keW5hbWljLWJhaWxvdXQtdG8tY3NyLnRzeD80ZmY0Il0sIm5hbWVzIjpbIl9iYWlsb3V0dG9jc3IiLCJyZXF1aXJlIiwiQmFpbG91dFRvQ1NSIiwiY2hpbGRyZW4iLCJyZWFzb24iLCJ3aW5kb3ciLCJwYXJhbSIsIkJhaWxvdXRUb0NTUkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"PreloadCss\", ({\n    enumerable: true,\n    get: function() {\n        return PreloadCss;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _requestasyncstorageexternal = __webpack_require__(/*! ../../../client/components/request-async-storage.external */ \"(shared)/./node_modules/next/dist/client/components/request-async-storage.external.js\");\nfunction PreloadCss(param) {\n    let { moduleIds } = param;\n    // Early return in client compilation and only load requestStore on server side\n    if (typeof window !== \"undefined\") {\n        return null;\n    }\n    const requestStore = (0, _requestasyncstorageexternal.getExpectedRequestStore)(\"next/dynamic css\");\n    const allFiles = [];\n    // Search the current dynamic call unique key id in react loadable manifest,\n    // and find the corresponding CSS files to preload\n    if (requestStore.reactLoadableManifest && moduleIds) {\n        const manifest = requestStore.reactLoadableManifest;\n        for (const key of moduleIds){\n            if (!manifest[key]) continue;\n            const cssFiles = manifest[key].files.filter((file)=>file.endsWith(\".css\"));\n            allFiles.push(...cssFiles);\n        }\n    }\n    if (allFiles.length === 0) {\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: allFiles.map((file)=>{\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n                // @ts-ignore\n                precedence: \"dynamic\",\n                rel: \"stylesheet\",\n                href: requestStore.assetPrefix + \"/_next/\" + encodeURI(file),\n                as: \"style\"\n            }, file);\n        })\n    });\n} //# sourceMappingURL=preload-css.js.map\n_c = PreloadCss;\nvar _c;\n$RefreshReg$(_c, \"PreloadCss\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvcHJlbG9hZC1jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFJTyxNQUFBQSwrQkFBc0VDLG1CQUFBQSxDQUFBO1NBQWxEQyxXQUFXQyxLQUFYO0lBQ3pCLE1BQUFDLFNBQUEsS0FBQUQ7SUFDQSwrRUFBbUM7UUFDakMsT0FBT0UsV0FBQTtRQUNUO0lBRUE7SUFDQSxNQUFNQyxlQUFhLElBQUFOLDZCQUFBTyx1QkFBQTtJQUVuQixNQUFBRCxXQUFBO0lBQ0EsNEVBQWtEO0lBQ2xELGtEQUEwQ0Y7UUFDeENJLGFBQU1DLHFCQUF3QkMsSUFBQUEsV0FBQUE7UUFDOUIsTUFBS0QsV0FBTUUsYUFBa0JELHFCQUFBO2FBQzNCLE1BQUtELE9BQVNFLFVBQU07WUFDcEIsS0FBQUYsUUFBTUcsQ0FBQUEsSUFBV0gsRUFBQUE7WUFHakJILE1BQUFBLFdBQWlCTSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxLQUFBQSxDQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxLQUFBQSxRQUFBQSxDQUFBQTtZQUNuQk4sU0FBQU8sSUFBQSxJQUFBRDtRQUNGO0lBRUE7UUFDRU4sU0FBT1EsTUFBQTtRQUNUO0lBRUE7V0FFS1IsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBU1MsWUFBS0MsR0FBQUEsRUFBQUEsWUFBQUEsUUFBQUEsRUFBQUE7a0JBQ2JWLFNBQUFTLEdBQUEsRUFBQUM7bUJBR2lCLGtCQUFBQyxZQUFBQyxHQUFBO2dCQUNiQyxhQUFZO2dCQUNaQyxZQUFJO2dCQUNKQyxLQUFBQTtnQkFDQUMsTUFBR2QsYUFBQWUsV0FBQSxlQUFBQyxVQUFBUjtnQkFMRUEsSUFBQUE7WUFRWCxHQUFBQTs7SUFHTjs7S0ExQzJCZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL3ByZWxvYWQtY3NzLnRzeD9kZTVjIl0sIm5hbWVzIjpbIl9yZXF1ZXN0YXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJyZXF1aXJlIiwiUHJlbG9hZENzcyIsInBhcmFtIiwibW9kdWxlSWRzIiwid2luZG93IiwiYWxsRmlsZXMiLCJnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSIsInJlcXVlc3RTdG9yZSIsIm1hbmlmZXN0IiwicmVhY3RMb2FkYWJsZU1hbmlmZXN0Iiwia2V5IiwiY3NzRmlsZXMiLCJwdXNoIiwibGVuZ3RoIiwibWFwIiwiZmlsZSIsIl9qc3hydW50aW1lIiwianN4IiwicHJlY2VkZW5jZSIsInJlbCIsImhyZWYiLCJhcyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/DigitRecognizer.tsx":
/*!********************************************!*\
  !*** ./src/components/DigitRecognizer.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DigitRecognizer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_onnxHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/onnxHelper */ \"(app-pages-browser)/./src/utils/onnxHelper.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction DigitRecognizer() {\n    _s();\n    const [prediction, setPrediction] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [imageLoaded, setImageLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentImagePath, setCurrentImagePath] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/5.png\");\n    const [modelPath, setModelPath] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"/models/simple/model.onnx\");\n    const [fallbackIndex, setFallbackIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [retryCount, setRetryCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [allModelsFailed, setAllModelsFailed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isDrawing, setIsDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [useDrawnImage, setUseDrawnImage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // List of possible image paths to try\n    const imagePaths = [\n        \"/5.png\",\n        \"/digit5.png\"\n    ];\n    // List of possible model paths to try\n    const modelPaths = [\n        \"/models/simple/model.onnx\",\n        \"/models/mnist.onnx\",\n        \"/models/mnist-8.onnx\"\n    ];\n    // Initialize drawing canvas\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const ctx = canvas.getContext(\"2d\");\n            if (ctx) {\n                // Set initial canvas state - white background\n                ctx.fillStyle = \"white\";\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Set drawing style\n                ctx.strokeStyle = \"black\";\n                ctx.lineWidth = 3;\n                ctx.lineCap = \"round\";\n                ctx.lineJoin = \"round\";\n            }\n        }\n    }, []);\n    // Drawing functions\n    const startDrawing = (e)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        setIsDrawing(true);\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n            const rect = canvas.getBoundingClientRect();\n            let x, y;\n            if (\"touches\" in e) {\n                // Touch event\n                x = e.touches[0].clientX - rect.left;\n                y = e.touches[0].clientY - rect.top;\n            } else {\n                // Mouse event\n                x = e.clientX - rect.left;\n                y = e.clientY - rect.top;\n            }\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n        }\n    };\n    const draw = (e)=>{\n        if (!isDrawing) return;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n            const rect = canvas.getBoundingClientRect();\n            let x, y;\n            if (\"touches\" in e) {\n                // Touch event\n                x = e.touches[0].clientX - rect.left;\n                y = e.touches[0].clientY - rect.top;\n            } else {\n                // Mouse event\n                x = e.clientX - rect.left;\n                y = e.clientY - rect.top;\n            }\n            ctx.lineTo(x, y);\n            ctx.stroke();\n        }\n    };\n    const endDrawing = ()=>{\n        setIsDrawing(false);\n        setUseDrawnImage(true);\n    };\n    const clearCanvas = ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n            ctx.fillStyle = \"white\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            setPrediction(null);\n        }\n    };\n    // Preload and verify that at least one image is available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Try to load images in sequence until one works\n        const tryLoadImage = (index)=>{\n            if (index >= imagePaths.length) {\n                console.error(\"All image loading attempts failed\");\n                setError(\"Failed to load any test images. Check console for details.\");\n                return;\n            }\n            const path = imagePaths[index];\n            console.log(\"Attempting to load image: \".concat(path));\n            const img = document.createElement(\"img\");\n            img.onload = ()=>{\n                console.log(\"Successfully loaded image: \".concat(path));\n                setImageLoaded(true);\n                setCurrentImagePath(path);\n                setError(null);\n            };\n            img.onerror = ()=>{\n                console.error(\"Failed to load image: \".concat(path));\n                // Try next image\n                tryLoadImage(index + 1);\n            };\n            img.src = path;\n        };\n        // Start trying to load images\n        tryLoadImage(0);\n    // No cleanup needed as we want the image loading to complete\n    }, []);\n    // Reset all state and start over\n    const resetAndRetry = ()=>{\n        setFallbackIndex(0);\n        setModelPath(modelPaths[0]);\n        setRetryCount(0);\n        setAllModelsFailed(false);\n        setError(null);\n        setPrediction(null);\n        // Short delay to ensure state updates before retry\n        setTimeout(()=>{\n            recognizeDigit();\n        }, 500);\n    };\n    // Manually set a different model\n    const tryNextModel = ()=>{\n        if (fallbackIndex < modelPaths.length - 1) {\n            const nextIndex = fallbackIndex + 1;\n            setFallbackIndex(nextIndex);\n            setModelPath(modelPaths[nextIndex]);\n            setError(\"Switching to model: \".concat(modelPaths[nextIndex]));\n            setRetryCount(0);\n        } else {\n            setAllModelsFailed(true);\n            setError(\"All models have failed. Try a different approach or check troubleshooting tips below.\");\n        }\n    };\n    const recognizeDigit = async ()=>{\n        // Don't attempt if we've already tried all models\n        if (allModelsFailed) {\n            setError(\"All models have failed. Please try the troubleshooting options below.\");\n            return;\n        }\n        // Prevent excessive retry loops\n        if (retryCount > 3) {\n            setError(\"Too many retries on model \".concat(fallbackIndex + 1, \". Try the next model instead.\"));\n            return;\n        }\n        try {\n            setIsLoading(true);\n            setError(null);\n            let tensor;\n            if (useDrawnImage && canvasRef.current) {\n                console.log(\"Using drawn image for recognition\");\n                // Convert canvas to a data URL\n                const canvasDataUrl = canvasRef.current.toDataURL(\"image/png\");\n                // Create an image from the canvas data\n                const img = document.createElement(\"img\");\n                // Wait for the image to load\n                await new Promise((resolve, reject)=>{\n                    img.onload = resolve;\n                    img.onerror = reject;\n                    img.src = canvasDataUrl;\n                });\n                // Draw the image to a new 28x28 canvas for proper size\n                const tempCanvas = document.createElement(\"canvas\");\n                tempCanvas.width = 28;\n                tempCanvas.height = 28;\n                const ctx = tempCanvas.getContext(\"2d\");\n                if (ctx) {\n                    // Fill with white background first\n                    ctx.fillStyle = \"white\";\n                    ctx.fillRect(0, 0, 28, 28);\n                    // Draw the image\n                    ctx.drawImage(img, 0, 0, 28, 28);\n                    // Get the data URL from the new canvas\n                    const dataUrl = tempCanvas.toDataURL(\"image/png\");\n                    // Convert to tensor\n                    tensor = await (0,_utils_onnxHelper__WEBPACK_IMPORTED_MODULE_2__.imageToTensor)(dataUrl);\n                } else {\n                    throw new Error(\"Could not get canvas context\");\n                }\n            } else {\n                console.log(\"Using sample image for recognition:\", currentImagePath);\n                // Convert image to tensor\n                tensor = await (0,_utils_onnxHelper__WEBPACK_IMPORTED_MODULE_2__.imageToTensor)(currentImagePath);\n            }\n            console.log(\"Image converted to tensor successfully\");\n            // Run inference with the MNIST model\n            console.log(\"Running inference with model:\", modelPath);\n            const result = await (0,_utils_onnxHelper__WEBPACK_IMPORTED_MODULE_2__.runInference)(modelPath, tensor);\n            console.log(\"Inference completed successfully with result:\", result);\n            // Clear any previous errors and update state\n            setError(null);\n            setPrediction(result);\n            setRetryCount(0);\n            setAllModelsFailed(false);\n        } catch (err) {\n            console.error(\"Error during recognition:\", err);\n            setRetryCount((prev)=>prev + 1);\n            // If model loading failed, try the next model in sequence\n            if (fallbackIndex < modelPaths.length - 1 && err instanceof Error && (err.message.includes(\"Failed to load model\") || err.message.includes(\"protobuf parsing failed\"))) {\n                console.log(\"Trying next model file...\");\n                const nextIndex = fallbackIndex + 1;\n                const nextModel = modelPaths[nextIndex];\n                setModelPath(nextModel);\n                setFallbackIndex(nextIndex);\n                setError(\"Model \".concat(fallbackIndex + 1, \" failed, trying model \").concat(nextIndex + 1, \": \").concat(nextModel));\n                setRetryCount(0);\n                // Retry with the next model after a brief delay\n                setTimeout(()=>{\n                    recognizeDigit();\n                }, 1000);\n                return;\n            }\n            // If we've tried all models and still have errors\n            if (fallbackIndex >= modelPaths.length - 1) {\n                setAllModelsFailed(true);\n                setError(\"All models have failed. Try the troubleshooting options below.\");\n            } else {\n                setError(\"Failed to recognize digit. See console for details.\");\n            }\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-md mx-auto bg-gray-900 p-6 rounded-xl shadow-lg\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-xl font-bold mb-4 text-white text-center\",\n                children: \"MNIST Digit Recognition\"\n            }, void 0, false, {\n                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                lineNumber: 293,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-3 text-xs text-gray-400 text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            \"Using model: \",\n                            modelPath.split(\"/\").pop()\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 297,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xs text-gray-500\",\n                        children: [\n                            \"Model \",\n                            fallbackIndex + 1,\n                            \" of \",\n                            modelPaths.length\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 298,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                lineNumber: 296,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col items-center gap-4 mb-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"border border-gray-600 rounded-lg bg-white mb-2 shadow-md overflow-hidden\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                            ref: canvasRef,\n                            width: 196,\n                            height: 196,\n                            className: \"cursor-crosshair touch-none\",\n                            onMouseDown: startDrawing,\n                            onMouseMove: draw,\n                            onMouseUp: endDrawing,\n                            onMouseLeave: endDrawing,\n                            onTouchStart: startDrawing,\n                            onTouchMove: draw,\n                            onTouchEnd: endDrawing\n                        }, void 0, false, {\n                            fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                            lineNumber: 304,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 303,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex space-x-2 w-full justify-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: clearCanvas,\n                                className: \"px-4 py-2 bg-gray-700 text-white text-sm rounded-lg hover:bg-gray-600 transition-colors\",\n                                children: \"Clear\"\n                            }, void 0, false, {\n                                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                                lineNumber: 321,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: recognizeDigit,\n                                disabled: isLoading || allModelsFailed,\n                                className: \"px-4 py-2 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors flex-grow\",\n                                children: isLoading ? \"Recognizing...\" : \"Recognize Digit\"\n                            }, void 0, false, {\n                                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                                lineNumber: 328,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: tryNextModel,\n                                disabled: fallbackIndex >= modelPaths.length - 1 || isLoading,\n                                className: \"px-4 py-2 bg-indigo-600 text-white text-sm rounded-lg hover:bg-indigo-700 disabled:opacity-50 transition-colors\",\n                                children: \"Try Next Model\"\n                            }, void 0, false, {\n                                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                                lineNumber: 336,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 320,\n                        columnNumber: 9\n                    }, this),\n                    prediction !== null && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 py-6 px-8 bg-gray-800 rounded-xl border border-gray-700 shadow-inner\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"text-gray-400 text-sm mb-1 text-center\",\n                                children: \"Prediction\"\n                            }, void 0, false, {\n                                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                                lineNumber: 348,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-5xl font-bold text-white text-center\",\n                                children: prediction\n                            }, void 0, false, {\n                                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                                lineNumber: 349,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 347,\n                        columnNumber: 11\n                    }, this),\n                    error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-2 text-red-400 text-sm bg-red-900/20 p-3 rounded-lg border border-red-800\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                        lineNumber: 355,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                lineNumber: 301,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-xs text-gray-500 mt-6 text-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: 'This demo runs MNIST digit recognition directly in your browser using ONNX Runtime Web. Draw a digit from 0-9 in the canvas above and click \"Recognize Digit\".'\n                }, void 0, false, {\n                    fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                    lineNumber: 362,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n                lineNumber: 361,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/evobidev/Desktop/React/onnx-ml/src/components/DigitRecognizer.tsx\",\n        lineNumber: 292,\n        columnNumber: 5\n    }, this);\n}\n_s(DigitRecognizer, \"XON2kotpQd0aaI/FGpsZFz+gXNU=\");\n_c = DigitRecognizer;\nvar _c;\n$RefreshReg$(_c, \"DigitRecognizer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RpZ2l0UmVjb2duaXplci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVvRDtBQUNhO0FBRWxELFNBQVNLOztJQUN0QixNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR1AsK0NBQVFBLENBQWdCO0lBQzVELE1BQU0sQ0FBQ1EsV0FBV0MsYUFBYSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNVLE9BQU9DLFNBQVMsR0FBR1gsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQ1ksYUFBYUMsZUFBZSxHQUFHYiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNjLGtCQUFrQkMsb0JBQW9CLEdBQUdmLCtDQUFRQSxDQUFDO0lBQ3pELE1BQU0sQ0FBQ2dCLFdBQVdDLGFBQWEsR0FBR2pCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2tCLGVBQWVDLGlCQUFpQixHQUFHbkIsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDb0IsWUFBWUMsY0FBYyxHQUFHckIsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDc0IsaUJBQWlCQyxtQkFBbUIsR0FBR3ZCLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ3dCLFdBQVdDLGFBQWEsR0FBR3pCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQzBCLGVBQWVDLGlCQUFpQixHQUFHM0IsK0NBQVFBLENBQUM7SUFDbkQsTUFBTTRCLFlBQVkxQiw2Q0FBTUEsQ0FBb0I7SUFFNUMsc0NBQXNDO0lBQ3RDLE1BQU0yQixhQUFhO1FBQ2pCO1FBQ0E7S0FDRDtJQUVELHNDQUFzQztJQUN0QyxNQUFNQyxhQUFhO1FBQ2pCO1FBQ0E7UUFDQTtLQUNEO0lBRUQsNEJBQTRCO0lBQzVCN0IsZ0RBQVNBLENBQUM7UUFDUixNQUFNOEIsU0FBU0gsVUFBVUksT0FBTztRQUNoQyxJQUFJRCxRQUFRO1lBQ1YsTUFBTUUsTUFBTUYsT0FBT0csVUFBVSxDQUFDO1lB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Ozs7Ozs7Ozs7Ozs7OztBQU9YO0dBM1d3QjFHO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0RpZ2l0UmVjb2duaXplci50c3g/M2EwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGltYWdlVG9UZW5zb3IsIHJ1bkluZmVyZW5jZSB9IGZyb20gJ0AvdXRpbHMvb25ueEhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERpZ2l0UmVjb2duaXplcigpIHtcbiAgY29uc3QgW3ByZWRpY3Rpb24sIHNldFByZWRpY3Rpb25dID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpbWFnZUxvYWRlZCwgc2V0SW1hZ2VMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY3VycmVudEltYWdlUGF0aCwgc2V0Q3VycmVudEltYWdlUGF0aF0gPSB1c2VTdGF0ZSgnLzUucG5nJyk7XG4gIGNvbnN0IFttb2RlbFBhdGgsIHNldE1vZGVsUGF0aF0gPSB1c2VTdGF0ZSgnL21vZGVscy9zaW1wbGUvbW9kZWwub25ueCcpO1xuICBjb25zdCBbZmFsbGJhY2tJbmRleCwgc2V0RmFsbGJhY2tJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3JldHJ5Q291bnQsIHNldFJldHJ5Q291bnRdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFthbGxNb2RlbHNGYWlsZWQsIHNldEFsbE1vZGVsc0ZhaWxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0RyYXdpbmcsIHNldElzRHJhd2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt1c2VEcmF3bkltYWdlLCBzZXRVc2VEcmF3bkltYWdlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcbiAgXG4gIC8vIExpc3Qgb2YgcG9zc2libGUgaW1hZ2UgcGF0aHMgdG8gdHJ5XG4gIGNvbnN0IGltYWdlUGF0aHMgPSBbXG4gICAgJy81LnBuZycsXG4gICAgJy9kaWdpdDUucG5nJ1xuICBdO1xuXG4gIC8vIExpc3Qgb2YgcG9zc2libGUgbW9kZWwgcGF0aHMgdG8gdHJ5XG4gIGNvbnN0IG1vZGVsUGF0aHMgPSBbXG4gICAgJy9tb2RlbHMvc2ltcGxlL21vZGVsLm9ubngnLCAvLyBUcnkgdGhlIHNpbXBsZXIgbW9kZWwgZmlyc3RcbiAgICAnL21vZGVscy9tbmlzdC5vbm54JyxcbiAgICAnL21vZGVscy9tbmlzdC04Lm9ubngnXG4gIF07XG5cbiAgLy8gSW5pdGlhbGl6ZSBkcmF3aW5nIGNhbnZhc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICAvLyBTZXQgaW5pdGlhbCBjYW52YXMgc3RhdGUgLSB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gU2V0IGRyYXdpbmcgc3R5bGVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBEcmF3aW5nIGZ1bmN0aW9uc1xuICBjb25zdCBzdGFydERyYXdpbmcgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4gfCBSZWFjdC5Ub3VjaEV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgXG4gICAgc2V0SXNEcmF3aW5nKHRydWUpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZXQgeCwgeTtcbiAgICAgIFxuICAgICAgaWYgKCd0b3VjaGVzJyBpbiBlKSB7XG4gICAgICAgIC8vIFRvdWNoIGV2ZW50XG4gICAgICAgIHggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3VzZSBldmVudFxuICAgICAgICB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRyYXcgPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4gfCBSZWFjdC5Ub3VjaEV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGlmICghaXNEcmF3aW5nKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IHgsIHk7XG4gICAgICBcbiAgICAgIGlmICgndG91Y2hlcycgaW4gZSkge1xuICAgICAgICAvLyBUb3VjaCBldmVudFxuICAgICAgICB4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW91c2UgZXZlbnRcbiAgICAgICAgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmREcmF3aW5nID0gKCkgPT4ge1xuICAgIHNldElzRHJhd2luZyhmYWxzZSk7XG4gICAgc2V0VXNlRHJhd25JbWFnZSh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBjbGVhckNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBzZXRQcmVkaWN0aW9uKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQcmVsb2FkIGFuZCB2ZXJpZnkgdGhhdCBhdCBsZWFzdCBvbmUgaW1hZ2UgaXMgYXZhaWxhYmxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVHJ5IHRvIGxvYWQgaW1hZ2VzIGluIHNlcXVlbmNlIHVudGlsIG9uZSB3b3Jrc1xuICAgIGNvbnN0IHRyeUxvYWRJbWFnZSA9IChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoaW5kZXggPj0gaW1hZ2VQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQWxsIGltYWdlIGxvYWRpbmcgYXR0ZW1wdHMgZmFpbGVkJyk7XG4gICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBhbnkgdGVzdCBpbWFnZXMuIENoZWNrIGNvbnNvbGUgZm9yIGRldGFpbHMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcGF0aCA9IGltYWdlUGF0aHNbaW5kZXhdO1xuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gbG9hZCBpbWFnZTogJHtwYXRofWApO1xuICAgICAgXG4gICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIFxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBsb2FkZWQgaW1hZ2U6ICR7cGF0aH1gKTtcbiAgICAgICAgc2V0SW1hZ2VMb2FkZWQodHJ1ZSk7XG4gICAgICAgIHNldEN1cnJlbnRJbWFnZVBhdGgocGF0aCk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke3BhdGh9YCk7XG4gICAgICAgIC8vIFRyeSBuZXh0IGltYWdlXG4gICAgICAgIHRyeUxvYWRJbWFnZShpbmRleCArIDEpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgaW1nLnNyYyA9IHBhdGg7XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdGFydCB0cnlpbmcgdG8gbG9hZCBpbWFnZXNcbiAgICB0cnlMb2FkSW1hZ2UoMCk7XG4gICAgXG4gICAgLy8gTm8gY2xlYW51cCBuZWVkZWQgYXMgd2Ugd2FudCB0aGUgaW1hZ2UgbG9hZGluZyB0byBjb21wbGV0ZVxuICB9LCBbXSk7XG4gIFxuICAvLyBSZXNldCBhbGwgc3RhdGUgYW5kIHN0YXJ0IG92ZXJcbiAgY29uc3QgcmVzZXRBbmRSZXRyeSA9ICgpID0+IHtcbiAgICBzZXRGYWxsYmFja0luZGV4KDApO1xuICAgIHNldE1vZGVsUGF0aChtb2RlbFBhdGhzWzBdKTtcbiAgICBzZXRSZXRyeUNvdW50KDApO1xuICAgIHNldEFsbE1vZGVsc0ZhaWxlZChmYWxzZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgc2V0UHJlZGljdGlvbihudWxsKTtcbiAgICAvLyBTaG9ydCBkZWxheSB0byBlbnN1cmUgc3RhdGUgdXBkYXRlcyBiZWZvcmUgcmV0cnlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlY29nbml6ZURpZ2l0KCk7XG4gICAgfSwgNTAwKTtcbiAgfTtcblxuICAvLyBNYW51YWxseSBzZXQgYSBkaWZmZXJlbnQgbW9kZWxcbiAgY29uc3QgdHJ5TmV4dE1vZGVsID0gKCkgPT4ge1xuICAgIGlmIChmYWxsYmFja0luZGV4IDwgbW9kZWxQYXRocy5sZW5ndGggLSAxKSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBmYWxsYmFja0luZGV4ICsgMTtcbiAgICAgIHNldEZhbGxiYWNrSW5kZXgobmV4dEluZGV4KTtcbiAgICAgIHNldE1vZGVsUGF0aChtb2RlbFBhdGhzW25leHRJbmRleF0pO1xuICAgICAgc2V0RXJyb3IoYFN3aXRjaGluZyB0byBtb2RlbDogJHttb2RlbFBhdGhzW25leHRJbmRleF19YCk7XG4gICAgICBzZXRSZXRyeUNvdW50KDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRBbGxNb2RlbHNGYWlsZWQodHJ1ZSk7XG4gICAgICBzZXRFcnJvcignQWxsIG1vZGVscyBoYXZlIGZhaWxlZC4gVHJ5IGEgZGlmZmVyZW50IGFwcHJvYWNoIG9yIGNoZWNrIHRyb3VibGVzaG9vdGluZyB0aXBzIGJlbG93LicpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWNvZ25pemVEaWdpdCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBEb24ndCBhdHRlbXB0IGlmIHdlJ3ZlIGFscmVhZHkgdHJpZWQgYWxsIG1vZGVsc1xuICAgIGlmIChhbGxNb2RlbHNGYWlsZWQpIHtcbiAgICAgIHNldEVycm9yKCdBbGwgbW9kZWxzIGhhdmUgZmFpbGVkLiBQbGVhc2UgdHJ5IHRoZSB0cm91Ymxlc2hvb3Rpbmcgb3B0aW9ucyBiZWxvdy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gUHJldmVudCBleGNlc3NpdmUgcmV0cnkgbG9vcHNcbiAgICBpZiAocmV0cnlDb3VudCA+IDMpIHtcbiAgICAgIHNldEVycm9yKGBUb28gbWFueSByZXRyaWVzIG9uIG1vZGVsICR7ZmFsbGJhY2tJbmRleCArIDF9LiBUcnkgdGhlIG5leHQgbW9kZWwgaW5zdGVhZC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgXG4gICAgICBsZXQgdGVuc29yO1xuICAgICAgXG4gICAgICBpZiAodXNlRHJhd25JbWFnZSAmJiBjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZHJhd24gaW1hZ2UgZm9yIHJlY29nbml0aW9uJyk7XG4gICAgICAgIC8vIENvbnZlcnQgY2FudmFzIHRvIGEgZGF0YSBVUkxcbiAgICAgICAgY29uc3QgY2FudmFzRGF0YVVybCA9IGNhbnZhc1JlZi5jdXJyZW50LnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbWFnZSBmcm9tIHRoZSBjYW52YXMgZGF0YVxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICBpbWcuc3JjID0gY2FudmFzRGF0YVVybDtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSB0byBhIG5ldyAyOHgyOCBjYW52YXMgZm9yIHByb3BlciBzaXplXG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IDI4O1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IDI4O1xuICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgLy8gRmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmQgZmlyc3RcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMjgsIDI4KTtcbiAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZVxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCAyOCwgMjgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBVUkwgZnJvbSB0aGUgbmV3IGNhbnZhc1xuICAgICAgICAgIGNvbnN0IGRhdGFVcmwgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ29udmVydCB0byB0ZW5zb3JcbiAgICAgICAgICB0ZW5zb3IgPSBhd2FpdCBpbWFnZVRvVGVuc29yKGRhdGFVcmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgc2FtcGxlIGltYWdlIGZvciByZWNvZ25pdGlvbjonLCBjdXJyZW50SW1hZ2VQYXRoKTtcbiAgICAgICAgLy8gQ29udmVydCBpbWFnZSB0byB0ZW5zb3JcbiAgICAgICAgdGVuc29yID0gYXdhaXQgaW1hZ2VUb1RlbnNvcihjdXJyZW50SW1hZ2VQYXRoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0ltYWdlIGNvbnZlcnRlZCB0byB0ZW5zb3Igc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICBcbiAgICAgIC8vIFJ1biBpbmZlcmVuY2Ugd2l0aCB0aGUgTU5JU1QgbW9kZWxcbiAgICAgIGNvbnNvbGUubG9nKCdSdW5uaW5nIGluZmVyZW5jZSB3aXRoIG1vZGVsOicsIG1vZGVsUGF0aCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5JbmZlcmVuY2UobW9kZWxQYXRoLCB0ZW5zb3IpO1xuICAgICAgY29uc29sZS5sb2coJ0luZmVyZW5jZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvcnMgYW5kIHVwZGF0ZSBzdGF0ZVxuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBzZXRQcmVkaWN0aW9uKHJlc3VsdCk7XG4gICAgICBzZXRSZXRyeUNvdW50KDApO1xuICAgICAgc2V0QWxsTW9kZWxzRmFpbGVkKGZhbHNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyByZWNvZ25pdGlvbjonLCBlcnIpO1xuICAgICAgc2V0UmV0cnlDb3VudChwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgIFxuICAgICAgLy8gSWYgbW9kZWwgbG9hZGluZyBmYWlsZWQsIHRyeSB0aGUgbmV4dCBtb2RlbCBpbiBzZXF1ZW5jZVxuICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPCBtb2RlbFBhdGhzLmxlbmd0aCAtIDEgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgXG4gICAgICAgICAgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gbG9hZCBtb2RlbCcpIHx8IGVyci5tZXNzYWdlLmluY2x1ZGVzKCdwcm90b2J1ZiBwYXJzaW5nIGZhaWxlZCcpKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIG5leHQgbW9kZWwgZmlsZS4uLicpO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBmYWxsYmFja0luZGV4ICsgMTtcbiAgICAgICAgY29uc3QgbmV4dE1vZGVsID0gbW9kZWxQYXRoc1tuZXh0SW5kZXhdO1xuICAgICAgICBzZXRNb2RlbFBhdGgobmV4dE1vZGVsKTtcbiAgICAgICAgc2V0RmFsbGJhY2tJbmRleChuZXh0SW5kZXgpO1xuICAgICAgICBzZXRFcnJvcihgTW9kZWwgJHtmYWxsYmFja0luZGV4ICsgMX0gZmFpbGVkLCB0cnlpbmcgbW9kZWwgJHtuZXh0SW5kZXggKyAxfTogJHtuZXh0TW9kZWx9YCk7XG4gICAgICAgIHNldFJldHJ5Q291bnQoMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IG1vZGVsIGFmdGVyIGEgYnJpZWYgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVjb2duaXplRGlnaXQoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UndmUgdHJpZWQgYWxsIG1vZGVscyBhbmQgc3RpbGwgaGF2ZSBlcnJvcnNcbiAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IG1vZGVsUGF0aHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBzZXRBbGxNb2RlbHNGYWlsZWQodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKCdBbGwgbW9kZWxzIGhhdmUgZmFpbGVkLiBUcnkgdGhlIHRyb3VibGVzaG9vdGluZyBvcHRpb25zIGJlbG93LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byByZWNvZ25pemUgZGlnaXQuIFNlZSBjb25zb2xlIGZvciBkZXRhaWxzLicpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctbWQgbXgtYXV0byBiZy1ncmF5LTkwMCBwLTYgcm91bmRlZC14bCBzaGFkb3ctbGdcIj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCBtYi00IHRleHQtd2hpdGUgdGV4dC1jZW50ZXJcIj5NTklTVCBEaWdpdCBSZWNvZ25pdGlvbjwvaDI+XG4gICAgICBcbiAgICAgIHsvKiBNb2RlbCBpbmZvICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0zIHRleHQteHMgdGV4dC1ncmF5LTQwMCB0ZXh0LWNlbnRlclwiPlxuICAgICAgICA8ZGl2PlVzaW5nIG1vZGVsOiB7bW9kZWxQYXRoLnNwbGl0KCcvJykucG9wKCl9PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwXCI+TW9kZWwge2ZhbGxiYWNrSW5kZXggKyAxfSBvZiB7bW9kZWxQYXRocy5sZW5ndGh9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtNCBtYi02XCI+XG4gICAgICAgIHsvKiBEcmF3aW5nIENhbnZhcyAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgYm9yZGVyLWdyYXktNjAwIHJvdW5kZWQtbGcgYmctd2hpdGUgbWItMiBzaGFkb3ctbWQgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgICAgPGNhbnZhcyBcbiAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgd2lkdGg9ezE5Nn1cbiAgICAgICAgICAgIGhlaWdodD17MTk2fVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY3Vyc29yLWNyb3NzaGFpciB0b3VjaC1ub25lXCJcbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtzdGFydERyYXdpbmd9XG4gICAgICAgICAgICBvbk1vdXNlTW92ZT17ZHJhd31cbiAgICAgICAgICAgIG9uTW91c2VVcD17ZW5kRHJhd2luZ31cbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17ZW5kRHJhd2luZ31cbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD17c3RhcnREcmF3aW5nfVxuICAgICAgICAgICAgb25Ub3VjaE1vdmU9e2RyYXd9XG4gICAgICAgICAgICBvblRvdWNoRW5kPXtlbmREcmF3aW5nfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgey8qIENhbnZhcyBDb250cm9scyAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHNwYWNlLXgtMiB3LWZ1bGwganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtjbGVhckNhbnZhc31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTcwMCB0ZXh0LXdoaXRlIHRleHQtc20gcm91bmRlZC1sZyBob3ZlcjpiZy1ncmF5LTYwMCB0cmFuc2l0aW9uLWNvbG9yc1wiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtyZWNvZ25pemVEaWdpdH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtpc0xvYWRpbmcgfHwgYWxsTW9kZWxzRmFpbGVkfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWJsdWUtNjAwIHRleHQtd2hpdGUgdGV4dC1zbSByb3VuZGVkLWxnIGhvdmVyOmJnLWJsdWUtNzAwIGRpc2FibGVkOm9wYWNpdHktNTAgdHJhbnNpdGlvbi1jb2xvcnMgZmxleC1ncm93XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7aXNMb2FkaW5nID8gJ1JlY29nbml6aW5nLi4uJyA6ICdSZWNvZ25pemUgRGlnaXQnfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RyeU5leHRNb2RlbH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxsYmFja0luZGV4ID49IG1vZGVsUGF0aHMubGVuZ3RoIC0gMSB8fCBpc0xvYWRpbmd9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctaW5kaWdvLTYwMCB0ZXh0LXdoaXRlIHRleHQtc20gcm91bmRlZC1sZyBob3ZlcjpiZy1pbmRpZ28tNzAwIGRpc2FibGVkOm9wYWNpdHktNTAgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIFRyeSBOZXh0IE1vZGVsXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgey8qIFByZWRpY3Rpb24gUmVzdWx0ICovfVxuICAgICAgICB7cHJlZGljdGlvbiAhPT0gbnVsbCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IHB5LTYgcHgtOCBiZy1ncmF5LTgwMCByb3VuZGVkLXhsIGJvcmRlciBib3JkZXItZ3JheS03MDAgc2hhZG93LWlubmVyXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCB0ZXh0LXNtIG1iLTEgdGV4dC1jZW50ZXJcIj5QcmVkaWN0aW9uPC9oMz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC01eGwgZm9udC1ib2xkIHRleHQtd2hpdGUgdGV4dC1jZW50ZXJcIj57cHJlZGljdGlvbn08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBFcnJvciBNZXNzYWdlICovfVxuICAgICAgICB7ZXJyb3IgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMiB0ZXh0LXJlZC00MDAgdGV4dC1zbSBiZy1yZWQtOTAwLzIwIHAtMyByb3VuZGVkLWxnIGJvcmRlciBib3JkZXItcmVkLTgwMFwiPlxuICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNTAwIG10LTYgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPHA+XG4gICAgICAgICAgVGhpcyBkZW1vIHJ1bnMgTU5JU1QgZGlnaXQgcmVjb2duaXRpb24gZGlyZWN0bHkgaW4geW91ciBicm93c2VyIHVzaW5nIE9OTlggUnVudGltZSBXZWIuXG4gICAgICAgICAgRHJhdyBhIGRpZ2l0IGZyb20gMC05IGluIHRoZSBjYW52YXMgYWJvdmUgYW5kIGNsaWNrIFwiUmVjb2duaXplIERpZ2l0XCIuXG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbWFnZVRvVGVuc29yIiwicnVuSW5mZXJlbmNlIiwiRGlnaXRSZWNvZ25pemVyIiwicHJlZGljdGlvbiIsInNldFByZWRpY3Rpb24iLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiaW1hZ2VMb2FkZWQiLCJzZXRJbWFnZUxvYWRlZCIsImN1cnJlbnRJbWFnZVBhdGgiLCJzZXRDdXJyZW50SW1hZ2VQYXRoIiwibW9kZWxQYXRoIiwic2V0TW9kZWxQYXRoIiwiZmFsbGJhY2tJbmRleCIsInNldEZhbGxiYWNrSW5kZXgiLCJyZXRyeUNvdW50Iiwic2V0UmV0cnlDb3VudCIsImFsbE1vZGVsc0ZhaWxlZCIsInNldEFsbE1vZGVsc0ZhaWxlZCIsImlzRHJhd2luZyIsInNldElzRHJhd2luZyIsInVzZURyYXduSW1hZ2UiLCJzZXRVc2VEcmF3bkltYWdlIiwiY2FudmFzUmVmIiwiaW1hZ2VQYXRocyIsIm1vZGVsUGF0aHMiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImxpbmVDYXAiLCJsaW5lSm9pbiIsInN0YXJ0RHJhd2luZyIsImUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJ0b3VjaGVzIiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwiZHJhdyIsImxpbmVUbyIsInN0cm9rZSIsImVuZERyYXdpbmciLCJjbGVhckNhbnZhcyIsInRyeUxvYWRJbWFnZSIsImluZGV4IiwibGVuZ3RoIiwiY29uc29sZSIsInBhdGgiLCJsb2ciLCJpbWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwicmVzZXRBbmRSZXRyeSIsInNldFRpbWVvdXQiLCJyZWNvZ25pemVEaWdpdCIsInRyeU5leHRNb2RlbCIsIm5leHRJbmRleCIsInRlbnNvciIsImNhbnZhc0RhdGFVcmwiLCJ0b0RhdGFVUkwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRlbXBDYW52YXMiLCJkcmF3SW1hZ2UiLCJkYXRhVXJsIiwiRXJyb3IiLCJyZXN1bHQiLCJlcnIiLCJwcmV2IiwibWVzc2FnZSIsImluY2x1ZGVzIiwibmV4dE1vZGVsIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJzcGxpdCIsInBvcCIsInJlZiIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJoMyIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DigitRecognizer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/onnxHelper.ts":
/*!*********************************!*\
  !*** ./src/utils/onnxHelper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   imageToTensor: function() { return /* binding */ imageToTensor; },\n/* harmony export */   runInference: function() { return /* binding */ runInference; }\n/* harmony export */ });\n/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! onnxruntime-web */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d16c\");\n/* __next_internal_client_entry_do_not_use__ imageToTensor,runInference auto */ \n// Initialize ONNX runtime with the files we found\nonnxruntime_web__WEBPACK_IMPORTED_MODULE_0__.env.wasm.wasmPaths = {\n    \"ort-wasm-simd-threaded.wasm\": \"/wasm/ort-wasm-simd-threaded.wasm\",\n    \"ort-wasm-simd-threaded.jsep.wasm\": \"/wasm/ort-wasm-simd-threaded.jsep.wasm\"\n};\n// Enable debug logging but don't be too verbose\nonnxruntime_web__WEBPACK_IMPORTED_MODULE_0__.env.debug = true;\nconsole.log(\"ONNX Runtime version:\", onnxruntime_web__WEBPACK_IMPORTED_MODULE_0__.env.versions);\n// Function to load an image and convert it to a tensor for the MNIST model\nconst imageToTensor = async (imageUrl)=>{\n    return new Promise((resolve, reject)=>{\n        // Use document.createElement instead of new Image()\n        const img = document.createElement(\"img\");\n        img.onload = ()=>{\n            console.log(\"Image loaded successfully: \".concat(imageUrl));\n            // Create a canvas to draw the image\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = 28;\n            canvas.height = 28;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                reject(new Error(\"Could not get canvas context\"));\n                return;\n            }\n            // Fill with white background first\n            ctx.fillStyle = \"white\";\n            ctx.fillRect(0, 0, 28, 28);\n            // Draw the image in the canvas\n            ctx.drawImage(img, 0, 0, 28, 28);\n            const imageData = ctx.getImageData(0, 0, 28, 28);\n            // ===== DEBUG =====\n            // Log the first few pixels to verify we have data\n            console.log(\"First 10 pixels:\");\n            for(let i = 0; i < 10; i++){\n                console.log(\"Pixel \".concat(i, \": R=\").concat(imageData.data[i * 4], \", G=\").concat(imageData.data[i * 4 + 1], \", B=\").concat(imageData.data[i * 4 + 2], \", A=\").concat(imageData.data[i * 4 + 3]));\n            }\n            // ================\n            // Convert the image data to a Float32Array\n            // MNIST expects a 1D array of 784 (28*28) values between 0-1\n            const data = new Float32Array(28 * 28);\n            for(let i = 0; i < imageData.data.length / 4; i++){\n                // Convert RGBA to grayscale and normalize to 0-1\n                // For MNIST: white (255,255,255) should be 0, black (0,0,0) should be 1\n                const r = 1.0 - imageData.data[i * 4] / 255;\n                const g = 1.0 - imageData.data[i * 4 + 1] / 255;\n                const b = 1.0 - imageData.data[i * 4 + 2] / 255;\n                // Simple grayscale conversion - higher value for darker pixels\n                data[i] = (r + g + b) / 3;\n            }\n            // Log first few values of processed data\n            console.log(\"First 10 tensor values:\");\n            for(let i = 0; i < 10; i++){\n                console.log(\"Value \".concat(i, \": \").concat(data[i]));\n            }\n            // Create the tensor (shape should match model input)\n            // MNIST model expects shape [1, 1, 28, 28]\n            const tensor = new onnxruntime_web__WEBPACK_IMPORTED_MODULE_0__.Tensor(\"float32\", data, [\n                1,\n                1,\n                28,\n                28\n            ]);\n            resolve(tensor);\n        };\n        img.onerror = ()=>{\n            console.error(\"Failed to load image:\", imageUrl);\n            reject(new Error(\"Failed to load image: \".concat(imageUrl)));\n        };\n        img.src = imageUrl;\n    });\n};\n// Function to run inference on an ONNX model\nconst runInference = async (modelPath, inputTensor)=>{\n    try {\n        console.log(\"Creating session for model: \".concat(modelPath));\n        // Simplest approach possible: fetch the model directly\n        const response = await fetch(modelPath);\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch model: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const modelArrayBuffer = await response.arrayBuffer();\n        console.log(\"Model file fetched successfully: \".concat(modelPath, \" (\").concat(modelArrayBuffer.byteLength, \" bytes)\"));\n        // Log first few bytes of model to verify it's an ONNX file\n        const firstBytes = new Uint8Array(modelArrayBuffer.slice(0, 20));\n        console.log(\"First 20 bytes of model file:\", Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, \"0\")).join(\" \"));\n        // Create session with minimal options for maximum compatibility\n        const sessionOptions = {\n            executionProviders: [\n                \"wasm\"\n            ],\n            enableMemPattern: false,\n            enableCpuMemArena: false\n        };\n        console.log(\"Creating session with minimal options\");\n        const session = await onnxruntime_web__WEBPACK_IMPORTED_MODULE_0__.InferenceSession.create(modelArrayBuffer, sessionOptions);\n        console.log(\"Session created successfully\");\n        console.log(\"Model input names:\", session.inputNames);\n        console.log(\"Model output names:\", session.outputNames);\n        // Create feeds with the input name from model\n        const feeds = {};\n        feeds[session.inputNames[0]] = inputTensor;\n        // Run the session\n        console.log(\"Running inference...\");\n        const outputData = await session.run(feeds);\n        console.log(\"Inference completed, processing results...\");\n        // Get the output tensor\n        const output = outputData[session.outputNames[0]];\n        console.log(\"Output tensor shape:\", output.dims);\n        // Process the output - find the index of max value (predicted digit)\n        const predictions = Array.prototype.slice.call(output.data);\n        console.log(\"Raw predictions:\", predictions);\n        const maxPredictionIndex = predictions.indexOf(Math.max(...predictions));\n        console.log(\"Prediction index:\", maxPredictionIndex);\n        return maxPredictionIndex;\n    } catch (error) {\n        console.error(\"Error running inference:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9vbm54SGVscGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztnRkFFdUM7QUFFdkMsa0RBQWtEO0FBQ2xEQSxnREFBTyxDQUFDRSxJQUFJLENBQUNDLFNBQVMsR0FBRztJQUN2QiwrQkFBK0I7SUFDL0Isb0NBQW9DO0FBQ3RDO0FBRUEsZ0RBQWdEO0FBQ2hESCxnREFBTyxDQUFDSSxLQUFLLEdBQUc7QUFDaEJDLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJOLGdEQUFPLENBQUNPLFFBQVE7QUFFckQsMkVBQTJFO0FBQ3BFLE1BQU1DLGdCQUFnQixPQUFPQztJQUNsQyxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0Isb0RBQW9EO1FBQ3BELE1BQU1DLE1BQU1DLFNBQVNDLGFBQWEsQ0FBQztRQUVuQ0YsSUFBSUcsTUFBTSxHQUFHO1lBQ1hYLFFBQVFDLEdBQUcsQ0FBQyw4QkFBdUMsT0FBVEc7WUFDMUMsb0NBQW9DO1lBQ3BDLE1BQU1RLFNBQVNILFNBQVNDLGFBQWEsQ0FBQztZQUN0Q0UsT0FBT0MsS0FBSyxHQUFHO1lBQ2ZELE9BQU9FLE1BQU0sR0FBRztZQUNoQixNQUFNQyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFFOUIsSUFBSSxDQUFDRCxLQUFLO2dCQUNSUixPQUFPLElBQUlVLE1BQU07Z0JBQ2pCO1lBQ0Y7WUFFQSxtQ0FBbUM7WUFDbkNGLElBQUlHLFNBQVMsR0FBRztZQUNoQkgsSUFBSUksUUFBUSxDQUFDLEdBQUcsR0FBRyxJQUFJO1lBRXZCLCtCQUErQjtZQUMvQkosSUFBSUssU0FBUyxDQUFDWixLQUFLLEdBQUcsR0FBRyxJQUFJO1lBQzdCLE1BQU1hLFlBQVlOLElBQUlPLFlBQVksQ0FBQyxHQUFHLEdBQUcsSUFBSTtZQUU3QyxvQkFBb0I7WUFDcEIsa0RBQWtEO1lBQ2xEdEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSyxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7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QU0sQ0FBQ2xCLGtCQUFrQlk7UUFFcEV2RCxRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQjBELFFBQVFHLFVBQVU7UUFDcEQ5RCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCMEQsUUFBUUksV0FBVztRQUV0RCw4Q0FBOEM7UUFDOUMsTUFBTUMsUUFBb0MsQ0FBQztRQUMzQ0EsS0FBSyxDQUFDTCxRQUFRRyxVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUd6QjtRQUUvQixrQkFBa0I7UUFDbEJyQyxRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNZ0UsYUFBYSxNQUFNTixRQUFRTyxHQUFHLENBQUNGO1FBQ3JDaEUsUUFBUUMsR0FBRyxDQUFDO1FBRVosd0JBQXdCO1FBQ3hCLE1BQU1rRSxTQUFTRixVQUFVLENBQUNOLFFBQVFJLFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDakQvRCxRQUFRQyxHQUFHLENBQUMsd0JBQXdCa0UsT0FBT0MsSUFBSTtRQUUvQyxxRUFBcUU7UUFDckUsTUFBTUMsY0FBY3BCLE1BQU1xQixTQUFTLENBQUN0QixLQUFLLENBQUN1QixJQUFJLENBQUNKLE9BQU8zQyxJQUFJO1FBQzFEeEIsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQm9FO1FBQ2hDLE1BQU1HLHFCQUFxQkgsWUFBWUksT0FBTyxDQUFDQyxLQUFLQyxHQUFHLElBQUlOO1FBQzNEckUsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQnVFO1FBRWpDLE9BQU9BO0lBQ1QsRUFBRSxPQUFPdkMsT0FBTztRQUNkakMsUUFBUWlDLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE1BQU1BO0lBQ1I7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9vbm54SGVscGVyLnRzPzZmZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgKiBhcyBvcnQgZnJvbSAnb25ueHJ1bnRpbWUtd2ViJztcblxuLy8gSW5pdGlhbGl6ZSBPTk5YIHJ1bnRpbWUgd2l0aCB0aGUgZmlsZXMgd2UgZm91bmRcbm9ydC5lbnYud2FzbS53YXNtUGF0aHMgPSB7XG4gICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nOiAnL3dhc20vb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtJyxcbiAgJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtJzogJy93YXNtL29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtJyxcbn07XG5cbi8vIEVuYWJsZSBkZWJ1ZyBsb2dnaW5nIGJ1dCBkb24ndCBiZSB0b28gdmVyYm9zZVxub3J0LmVudi5kZWJ1ZyA9IHRydWU7XG5jb25zb2xlLmxvZygnT05OWCBSdW50aW1lIHZlcnNpb246Jywgb3J0LmVudi52ZXJzaW9ucyk7XG5cbi8vIEZ1bmN0aW9uIHRvIGxvYWQgYW4gaW1hZ2UgYW5kIGNvbnZlcnQgaXQgdG8gYSB0ZW5zb3IgZm9yIHRoZSBNTklTVCBtb2RlbFxuZXhwb3J0IGNvbnN0IGltYWdlVG9UZW5zb3IgPSBhc3luYyAoaW1hZ2VVcmw6IHN0cmluZyk6IFByb21pc2U8b3J0LlRlbnNvcj4gPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIFVzZSBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGluc3RlYWQgb2YgbmV3IEltYWdlKClcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYEltYWdlIGxvYWRlZCBzdWNjZXNzZnVsbHk6ICR7aW1hZ2VVcmx9YCk7XG4gICAgICAvLyBDcmVhdGUgYSBjYW52YXMgdG8gZHJhdyB0aGUgaW1hZ2VcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMjg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMjg7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIFxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaWxsIHdpdGggd2hpdGUgYmFja2dyb3VuZCBmaXJzdFxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMjgsIDI4KTtcbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgaW1hZ2UgaW4gdGhlIGNhbnZhc1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIDI4LCAyOCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDI4LCAyOCk7XG4gICAgICBcbiAgICAgIC8vID09PT09IERFQlVHID09PT09XG4gICAgICAvLyBMb2cgdGhlIGZpcnN0IGZldyBwaXhlbHMgdG8gdmVyaWZ5IHdlIGhhdmUgZGF0YVxuICAgICAgY29uc29sZS5sb2coJ0ZpcnN0IDEwIHBpeGVsczonKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zb2xlLmxvZyhgUGl4ZWwgJHtpfTogUj0ke2ltYWdlRGF0YS5kYXRhW2kqNF19LCBHPSR7aW1hZ2VEYXRhLmRhdGFbaSo0KzFdfSwgQj0ke2ltYWdlRGF0YS5kYXRhW2kqNCsyXX0sIEE9JHtpbWFnZURhdGEuZGF0YVtpKjQrM119YCk7XG4gICAgICB9XG4gICAgICAvLyA9PT09PT09PT09PT09PT09XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgdGhlIGltYWdlIGRhdGEgdG8gYSBGbG9hdDMyQXJyYXlcbiAgICAgIC8vIE1OSVNUIGV4cGVjdHMgYSAxRCBhcnJheSBvZiA3ODQgKDI4KjI4KSB2YWx1ZXMgYmV0d2VlbiAwLTFcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDI4ICogMjgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZURhdGEuZGF0YS5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgICAgLy8gQ29udmVydCBSR0JBIHRvIGdyYXlzY2FsZSBhbmQgbm9ybWFsaXplIHRvIDAtMVxuICAgICAgICAvLyBGb3IgTU5JU1Q6IHdoaXRlICgyNTUsMjU1LDI1NSkgc2hvdWxkIGJlIDAsIGJsYWNrICgwLDAsMCkgc2hvdWxkIGJlIDFcbiAgICAgICAgY29uc3QgciA9IDEuMCAtIChpbWFnZURhdGEuZGF0YVtpICogNF0gLyAyNTUpO1xuICAgICAgICBjb25zdCBnID0gMS4wIC0gKGltYWdlRGF0YS5kYXRhW2kgKiA0ICsgMV0gLyAyNTUpO1xuICAgICAgICBjb25zdCBiID0gMS4wIC0gKGltYWdlRGF0YS5kYXRhW2kgKiA0ICsgMl0gLyAyNTUpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltcGxlIGdyYXlzY2FsZSBjb252ZXJzaW9uIC0gaGlnaGVyIHZhbHVlIGZvciBkYXJrZXIgcGl4ZWxzXG4gICAgICAgIGRhdGFbaV0gPSAociArIGcgKyBiKSAvIDM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExvZyBmaXJzdCBmZXcgdmFsdWVzIG9mIHByb2Nlc3NlZCBkYXRhXG4gICAgICBjb25zb2xlLmxvZygnRmlyc3QgMTAgdGVuc29yIHZhbHVlczonKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zb2xlLmxvZyhgVmFsdWUgJHtpfTogJHtkYXRhW2ldfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIHRlbnNvciAoc2hhcGUgc2hvdWxkIG1hdGNoIG1vZGVsIGlucHV0KVxuICAgICAgLy8gTU5JU1QgbW9kZWwgZXhwZWN0cyBzaGFwZSBbMSwgMSwgMjgsIDI4XVxuICAgICAgY29uc3QgdGVuc29yID0gbmV3IG9ydC5UZW5zb3IoJ2Zsb2F0MzInLCBkYXRhLCBbMSwgMSwgMjgsIDI4XSk7XG4gICAgICByZXNvbHZlKHRlbnNvcik7XG4gICAgfTtcbiAgICBcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlOicsIGltYWdlVXJsKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke2ltYWdlVXJsfWApKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSBpbWFnZVVybDtcbiAgfSk7XG59O1xuXG4vLyBGdW5jdGlvbiB0byBydW4gaW5mZXJlbmNlIG9uIGFuIE9OTlggbW9kZWxcbmV4cG9ydCBjb25zdCBydW5JbmZlcmVuY2UgPSBhc3luYyAobW9kZWxQYXRoOiBzdHJpbmcsIGlucHV0VGVuc29yOiBvcnQuVGVuc29yKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgc2Vzc2lvbiBmb3IgbW9kZWw6ICR7bW9kZWxQYXRofWApO1xuICAgIFxuICAgIC8vIFNpbXBsZXN0IGFwcHJvYWNoIHBvc3NpYmxlOiBmZXRjaCB0aGUgbW9kZWwgZGlyZWN0bHlcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKG1vZGVsUGF0aCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbW9kZWw6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG1vZGVsQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnNvbGUubG9nKGBNb2RlbCBmaWxlIGZldGNoZWQgc3VjY2Vzc2Z1bGx5OiAke21vZGVsUGF0aH0gKCR7bW9kZWxBcnJheUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlcylgKTtcbiAgICBcbiAgICAvLyBMb2cgZmlyc3QgZmV3IGJ5dGVzIG9mIG1vZGVsIHRvIHZlcmlmeSBpdCdzIGFuIE9OTlggZmlsZVxuICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheShtb2RlbEFycmF5QnVmZmVyLnNsaWNlKDAsIDIwKSk7XG4gICAgY29uc29sZS5sb2coJ0ZpcnN0IDIwIGJ5dGVzIG9mIG1vZGVsIGZpbGU6JywgQXJyYXkuZnJvbShmaXJzdEJ5dGVzKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcgJykpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBzZXNzaW9uIHdpdGggbWluaW1hbCBvcHRpb25zIGZvciBtYXhpbXVtIGNvbXBhdGliaWxpdHlcbiAgICBjb25zdCBzZXNzaW9uT3B0aW9ucyA9IHtcbiAgICAgIGV4ZWN1dGlvblByb3ZpZGVyczogWyd3YXNtJ10sXG4gICAgICBlbmFibGVNZW1QYXR0ZXJuOiBmYWxzZSxcbiAgICAgIGVuYWJsZUNwdU1lbUFyZW5hOiBmYWxzZVxuICAgIH07XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHNlc3Npb24gd2l0aCBtaW5pbWFsIG9wdGlvbnMnKTtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKG1vZGVsQXJyYXlCdWZmZXIsIHNlc3Npb25PcHRpb25zKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBpbnB1dCBuYW1lczonLCBzZXNzaW9uLmlucHV0TmFtZXMpO1xuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBvdXRwdXQgbmFtZXM6Jywgc2Vzc2lvbi5vdXRwdXROYW1lcyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGZlZWRzIHdpdGggdGhlIGlucHV0IG5hbWUgZnJvbSBtb2RlbFxuICAgIGNvbnN0IGZlZWRzOiBSZWNvcmQ8c3RyaW5nLCBvcnQuVGVuc29yPiA9IHt9O1xuICAgIGZlZWRzW3Nlc3Npb24uaW5wdXROYW1lc1swXV0gPSBpbnB1dFRlbnNvcjtcbiAgICBcbiAgICAvLyBSdW4gdGhlIHNlc3Npb25cbiAgICBjb25zb2xlLmxvZygnUnVubmluZyBpbmZlcmVuY2UuLi4nKTtcbiAgICBjb25zdCBvdXRwdXREYXRhID0gYXdhaXQgc2Vzc2lvbi5ydW4oZmVlZHMpO1xuICAgIGNvbnNvbGUubG9nKCdJbmZlcmVuY2UgY29tcGxldGVkLCBwcm9jZXNzaW5nIHJlc3VsdHMuLi4nKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIG91dHB1dCB0ZW5zb3JcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXREYXRhW3Nlc3Npb24ub3V0cHV0TmFtZXNbMF1dO1xuICAgIGNvbnNvbGUubG9nKCdPdXRwdXQgdGVuc29yIHNoYXBlOicsIG91dHB1dC5kaW1zKTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIHRoZSBvdXRwdXQgLSBmaW5kIHRoZSBpbmRleCBvZiBtYXggdmFsdWUgKHByZWRpY3RlZCBkaWdpdClcbiAgICBjb25zdCBwcmVkaWN0aW9ucyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG91dHB1dC5kYXRhIGFzIEZsb2F0MzJBcnJheSk7XG4gICAgY29uc29sZS5sb2coJ1JhdyBwcmVkaWN0aW9uczonLCBwcmVkaWN0aW9ucyk7XG4gICAgY29uc3QgbWF4UHJlZGljdGlvbkluZGV4ID0gcHJlZGljdGlvbnMuaW5kZXhPZihNYXRoLm1heCguLi5wcmVkaWN0aW9ucykpO1xuICAgIGNvbnNvbGUubG9nKCdQcmVkaWN0aW9uIGluZGV4OicsIG1heFByZWRpY3Rpb25JbmRleCk7XG4gICAgXG4gICAgcmV0dXJuIG1heFByZWRpY3Rpb25JbmRleDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBydW5uaW5nIGluZmVyZW5jZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJvcnQiLCJlbnYiLCJ3YXNtIiwid2FzbVBhdGhzIiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwidmVyc2lvbnMiLCJpbWFnZVRvVGVuc29yIiwiaW1hZ2VVcmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubG9hZCIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsIkVycm9yIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJpIiwiZGF0YSIsIkZsb2F0MzJBcnJheSIsImxlbmd0aCIsInIiLCJnIiwiYiIsInRlbnNvciIsIlRlbnNvciIsIm9uZXJyb3IiLCJlcnJvciIsInNyYyIsInJ1bkluZmVyZW5jZSIsIm1vZGVsUGF0aCIsImlucHV0VGVuc29yIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm1vZGVsQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmaXJzdEJ5dGVzIiwiVWludDhBcnJheSIsInNsaWNlIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJzZXNzaW9uT3B0aW9ucyIsImV4ZWN1dGlvblByb3ZpZGVycyIsImVuYWJsZU1lbVBhdHRlcm4iLCJlbmFibGVDcHVNZW1BcmVuYSIsInNlc3Npb24iLCJJbmZlcmVuY2VTZXNzaW9uIiwiY3JlYXRlIiwiaW5wdXROYW1lcyIsIm91dHB1dE5hbWVzIiwiZmVlZHMiLCJvdXRwdXREYXRhIiwicnVuIiwib3V0cHV0IiwiZGltcyIsInByZWRpY3Rpb25zIiwicHJvdG90eXBlIiwiY2FsbCIsIm1heFByZWRpY3Rpb25JbmRleCIsImluZGV4T2YiLCJNYXRoIiwibWF4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/onnxHelper.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTBlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d16c":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ Of; },\n/* harmony export */   TRACE: function() { return /* binding */ vr; },\n/* harmony export */   TRACE_FUNC_BEGIN: function() { return /* binding */ Ne; },\n/* harmony export */   TRACE_FUNC_END: function() { return /* binding */ Be; },\n/* harmony export */   Tensor: function() { return /* binding */ qe; },\n/* harmony export */   \"default\": function() { return /* binding */ lT; },\n/* harmony export */   env: function() { return /* binding */ we; },\n/* harmony export */   registerBackend: function() { return /* binding */ Ct; }\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Un=Object.defineProperty;var Af=Object.getOwnPropertyDescriptor;var kf=Object.getOwnPropertyNames;var Ef=Object.prototype.hasOwnProperty;var Nn=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,n)=>(typeof require<\"u\"?require:t)[n]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var G=(e,t)=>()=>(e&&(t=e(e=0)),t);var Zt=(e,t)=>{for(var n in t)Un(e,n,{get:t[n],enumerable:!0})},Pf=(e,t,n,r)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of kf(t))!Ef.call(e,o)&&o!==n&&Un(e,o,{get:()=>t[o],enumerable:!(r=Af(t,o))||r.enumerable});return e};var br=e=>Pf(Un({},\"__esModule\",{value:!0}),e);var _r,Tt,Ct,zf,Wa,Vn=G(()=>{\"use strict\";_r=new Map,Tt=[],Ct=(e,t,n)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let r=_r.get(e);if(r===void 0)_r.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${n}`)}if(n>=0){let o=Tt.indexOf(e);o!==-1&&Tt.splice(o,1);for(let a=0;a<Tt.length;a++)if(_r.get(Tt[a]).priority<=n){Tt.splice(a,0,e);return}Tt.push(e)}return}throw new TypeError(\"not a valid backend\")},zf=async e=>{let t=_r.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Wa=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l==\"string\"?l:l.name),r=n.length===0?Tt:n,o,a=[],s=new Set;for(let l of r){let p=await zf(l);typeof p==\"string\"?a.push({name:l,err:p}):(o||(o=p),o===p&&s.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${a.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of a)n.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>s.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var La=G(()=>{\"use strict\";Vn()});var Ga,Ha=G(()=>{\"use strict\";Ga=\"1.21.0\"});var Fa,Ue,Wn=G(()=>{\"use strict\";Ha();Fa=\"warning\",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:Ga},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fa=e}},get logLevel(){return Fa}};Object.defineProperty(Ue,\"logLevel\",{enumerable:!0})});var we,qa=G(()=>{\"use strict\";Wn();we=Ue});var Ka,ja,Za=G(()=>{\"use strict\";Ka=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext(\"2d\");if(r!=null){let o,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[3]):(o=e.dims[3],a=e.dims[2]);let s=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let f=a*o,h=0,y=f,_=f*2,b=-1;s===\"RGBA\"?(h=0,y=f,_=f*2,b=f*3):s===\"RGB\"?(h=0,y=f,_=f*2):s===\"RBG\"&&(h=0,_=f,y=f*2);for(let w=0;w<a;w++)for(let S=0;S<o;S++){let $=(e.data[h++]-p[0])*l[0],v=(e.data[y++]-p[1])*l[1],T=(e.data[_++]-p[2])*l[2],C=b===-1?255:(e.data[b++]-p[3])*l[3];r.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+T+\",\"+C+\")\",r.fillRect(S,w,1,1)}if(\"toDataURL\"in n)return n.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},ja=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),r;if(n!=null){let o,a,s;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[1],s=e.dims[3]):(o=e.dims[3],a=e.dims[2],s=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,f;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?f=[0,0,0,0]:typeof l.bias==\"number\"?f=[l.bias,l.bias,l.bias,l.bias]:(f=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(f[3]=l.bias[3]));let h=a*o;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!==\"RGBA\"||s===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let y=4,_=0,b=1,w=2,S=3,$=0,v=h,T=h*2,C=-1;d===\"RGBA\"?($=0,v=h,T=h*2,C=h*3):d===\"RGB\"?($=0,v=h,T=h*2):d===\"RBG\"&&($=0,T=h,v=h*2),r=n.createImageData(o,a);for(let A=0;A<a*o;_+=y,b+=y,w+=y,S+=y,A++)r.data[_]=(e.data[$++]-f[0])*p[0],r.data[b]=(e.data[v++]-f[1])*p[1],r.data[w]=(e.data[T++]-f[2])*p[2],r.data[S]=C===-1?255:(e.data[C++]-f[3])*p[3]}else throw new Error(\"Can not access image data\");return r}});var Ln,Qa,Ya,Xa,Ja,es,ts=G(()=>{\"use strict\";wr();Ln=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:n,width:r}=t,o=t.norm??{mean:255,bias:0},a,s;typeof o.mean==\"number\"?a=[o.mean,o.mean,o.mean,o.mean]:a=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=n*r,f=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),h=4,y=0,_=1,b=2,w=3,S=0,$=p,v=p*2,T=-1;d===\"RGB\"&&(h=3,y=0,_=1,b=2,w=-1),l===\"RGBA\"?T=p*3:l===\"RBG\"?(S=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,S=p*2);for(let A=0;A<p;A++,y+=h,b+=h,_+=h,w+=h)f[S++]=(e[y]+s[0])/a[0],f[$++]=(e[_]+s[1])/a[1],f[v++]=(e[b]+s[2])/a[2],T!==-1&&w!==-1&&(f[T++]=(e[w]+s[3])/a[3]);return l===\"RGBA\"?new De(\"float32\",f,[1,4,n,r]):new De(\"float32\",f,[1,3,n,r])},Qa=async(e,t)=>{let n=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,r=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,a=typeof e==\"string\",s,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=f=>typeof HTMLCanvasElement<\"u\"&&f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext(\"2d\"):null;if(n){let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(y=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=y,d.width=_}else d.tensorFormat=\"RGBA\",d.height=y,d.width=_;h.drawImage(e,0,0),s=h.getImageData(0,0,_,y).data}else throw new Error(\"Can not access image data\")}else if(r){let f,h;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(f=t.resizedHeight,h=t.resizedWidth):(f=e.height,h=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=f,d.width=h,t!==void 0){let y=l();y.width=h,y.height=f;let _=p(y);if(_!=null)_.putImageData(e,0,0),s=_.getImageData(0,0,h,f).data;else throw new Error(\"Can not access image data\")}else s=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;return h.drawImage(e,0,0,_,y),s=h.getImageData(0,0,_,y).data,d.height=y,d.width=_,Ln(s,d)}else throw new Error(\"Can not access image data\")}else{if(a)return new Promise((f,h)=>{let y=l(),_=p(y);if(!e||!_)return h();let b=new Image;b.crossOrigin=\"Anonymous\",b.src=e,b.onload=()=>{y.width=b.width,y.height=b.height,_.drawImage(b,0,0,y.width,y.height);let w=_.getImageData(0,0,y.width,y.height);d.height=y.height,d.width=y.width,f(Ln(w.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(s!==void 0)return Ln(s,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},Ya=(e,t)=>{let{width:n,height:r,download:o,dispose:a}=t,s=[1,r,n,4];return new De({location:\"texture\",type:\"float32\",texture:e,dims:s,download:o,dispose:a})},Xa=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"gpu-buffer\",type:n??\"float32\",gpuBuffer:e,dims:r,download:o,dispose:a})},Ja=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"ml-tensor\",type:n??\"float32\",mlTensor:e,dims:r,download:o,dispose:a})},es=(e,t,n)=>new De({location:\"cpu-pinned\",type:e,data:t,dims:n??[t.length]})});var It,Qt,rs,ns,os=G(()=>{\"use strict\";It=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),Qt=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),rs=!1,ns=()=>{if(!rs){rs=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<\"u\"&&n.from;e&&(It.set(\"int64\",BigInt64Array),Qt.set(BigInt64Array,\"int64\")),t&&(It.set(\"uint64\",BigUint64Array),Qt.set(BigUint64Array,\"uint64\")),r?(It.set(\"float16\",n),Qt.set(n,\"float16\")):It.set(\"float16\",Uint16Array)}}});var is,as,ss=G(()=>{\"use strict\";wr();is=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!=\"number\"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},as=(e,t)=>{switch(e.location){case\"cpu\":return new De(e.type,e.data,t);case\"cpu-pinned\":return new De({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new De({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new De({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new De({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var De,wr=G(()=>{\"use strict\";Za();ts();os();ss();De=class{constructor(t,n,r){ns();let o,a;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,a=t.dims,t.location){case\"cpu-pinned\":{let d=It.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=r,t===\"string\"){if(!Array.isArray(n))throw new TypeError(\"A string tensor's data must be a string array.\");d=n}else{let p=It.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(n,BigInt):d=p.from(n)}else if(n instanceof p)d=n;else if(n instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(n);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else if(t===\"float16\"&&n instanceof Uint16Array&&p!==Uint16Array)d=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=n,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=Qt.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");a=l,this.cpuData=d,this.dataLocation=\"cpu\"}let s=is(a);if(this.cpuData&&s!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=a,this.size=s}static async fromImage(t,n){return Qa(t,n)}static fromTexture(t,n){return Ya(t,n)}static fromGpuBuffer(t,n){return Xa(t,n)}static fromMLTensor(t,n){return Ja(t,n)}static fromPinnedBuffer(t,n,r){return es(t,n,r)}toDataURL(t){return Ka(this,t)}toImageData(t){return ja(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return as(this,t)}}});var qe,Gn=G(()=>{\"use strict\";wr();qe=De});var vr,us,Ne,Be,Hn=G(()=>{\"use strict\";Wn();vr=(e,t)=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},us=(e,t)=>{let n=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let o=0;o<n.length;o++){if(r&&!n[o].includes(\"TRACE_FUNC\")){let a=`FUNC_${e}::${n[o].trim().split(\" \")[1]}`;t&&(a+=`::${t}`),vr(\"CPU\",a);return}n[o].includes(\"TRACE_FUNC\")&&(r=!0)}},Ne=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"BEGIN\",e)},Be=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"END\",e)}});var $r,ds=G(()=>{\"use strict\";Vn();Gn();Hn();$r=class e{constructor(t){this.handler=t}async run(t,n,r){Ne();let o={},a={};if(typeof t!=\"object\"||t===null||t instanceof qe||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let s=!0;if(typeof n==\"object\"){if(n===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(n instanceof qe)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(n)){if(n.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");s=!1;for(let p of n){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,f=Object.getOwnPropertyNames(n);for(let h of this.outputNames)if(f.indexOf(h)!==-1){let y=n[h];(y===null||y instanceof qe)&&(p=!0,s=!1,o[h]=y)}if(p){if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else a=n}}else if(typeof n<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(s)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,a),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let f=d[p];f instanceof qe?l[p]=f:l[p]=new qe(f.type,f.data,f.dims)}return Be(),l}async release(){return this.handler.dispose()}static async create(t,n,r,o){Ne();let a,s={};if(typeof t==\"string\"){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let f=t,h=0,y=t.byteLength;if(typeof n==\"object\"&&n!==null)s=n;else if(typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteOffset' must be an integer.\");if(h<0||h>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(y=t.byteLength-h,typeof r==\"number\"){if(y=r,!Number.isSafeInteger(y))throw new RangeError(\"'byteLength' must be an integer.\");if(y<=0||h+y>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-h}].`);if(typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof r<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\");a=new Uint8Array(f,h,y)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Wa(s),p=await d.createInferenceSessionHandler(a,l);return Be(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Of,ls=G(()=>{\"use strict\";ds();Of=$r});var cs=G(()=>{\"use strict\"});var ps=G(()=>{\"use strict\"});var ms=G(()=>{\"use strict\"});var fs=G(()=>{\"use strict\"});var Fn={};Zt(Fn,{InferenceSession:()=>Of,TRACE:()=>vr,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>Be,Tensor:()=>qe,env:()=>we,registerBackend:()=>Ct});var Ge=G(()=>{\"use strict\";La();qa();ls();Gn();cs();ps();Hn();ms();fs()});var xr=G(()=>{\"use strict\"});var bs={};Zt(bs,{default:()=>Df});var gs,ys,Df,_s=G(()=>{\"use strict\";qn();bt();Sr();gs=\"ort-wasm-proxy-worker\",ys=globalThis.self?.name===gs;ys&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case\"init-wasm\":Tr(n.wasm).then(()=>{Cr(n).then(()=>{postMessage({type:t})},r=>{postMessage({type:t,err:r})})},r=>{postMessage({type:t,err:r})});break;case\"init-ep\":{let{epName:r,env:o}=n;Ir(o,r).then(()=>{postMessage({type:t})},a=>{postMessage({type:t,err:a})});break}case\"copy-from\":{let{buffer:r}=n,o=Yt(r);postMessage({type:t,out:o});break}case\"create\":{let{model:r,options:o}=n;Ar(r,o).then(a=>{postMessage({type:t,out:a})},a=>{postMessage({type:t,err:a})});break}case\"release\":kr(n),postMessage({type:t});break;case\"run\":{let{sessionId:r,inputIndices:o,inputs:a,outputIndices:s,options:d}=n;Er(r,o,a,s,new Array(s.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},zr([...a,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":Pr(n),postMessage({type:t});break;default:}}catch(r){postMessage({type:t,err:r})}});Df=ys?null:e=>new Worker(e??Ve,{type:\"module\",name:gs})});var vs={};Zt(vs,{default:()=>Bf});var Kn,ws,Bf,Mf,$s=G(()=>{\"use strict\";ws=(Kn=\"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\",async function(e={}){var t,n,r=e,o=new Promise((i,u)=>{t=i,n=u}),a=typeof window==\"object\",s=typeof WorkerGlobalScope<\"u\",d=s&&self.name?.startsWith(\"em-pthread\");r.mountExternalData=(i,u)=>{i.startsWith(\"./\")&&(i=i.substring(2)),(r.Bd||(r.Bd=new Map)).set(i,u)},r.unmountExternalData=()=>{delete r.Bd};var l=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let p=()=>{let i=(c,m,g)=>(...x)=>{let I=Je,z=m?.();x=c(...x);let B=m?.();return z!==B&&(c=B,g(z),m=g=null),Je!=I?new Promise((L,q)=>{En={resolve:L,reject:q}}):x},u=c=>async(...m)=>{try{if(r.Cd)throw Error(\"Session already started\");let g=r.Cd={be:m[0],errors:[]},x=await c(...m);if(r.Cd!==g)throw Error(\"Session mismatch\");r.Dd?.flush();let I=g.errors;if(0<I.length){let z=await Promise.all(I);if(z=z.filter(B=>B),0<z.length)throw Error(z.join(`\n`))}return x}finally{r.Cd=null}};r._OrtCreateSession=i(r._OrtCreateSession,()=>r._OrtCreateSession,c=>r._OrtCreateSession=c),r._OrtRun=u(i(r._OrtRun,()=>r._OrtRun,c=>r._OrtRun=c)),r._OrtRunWithBinding=u(i(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,c=>r._OrtRunWithBinding=c)),r._OrtBindInput=i(r._OrtBindInput,()=>r._OrtBindInput,c=>r._OrtBindInput=c),p=void 0};r.jsepInit=(i,u)=>{if(p?.(),i===\"webgpu\"){[r.Dd,r.Rd,r.Vd,r.Hd,r.Ud,r.hc,r.Wd,r.Zd,r.Sd,r.Td,r.Xd]=u;let c=r.Dd;r.jsepRegisterBuffer=(m,g,x,I)=>c.registerBuffer(m,g,x,I),r.jsepGetBuffer=m=>c.getBuffer(m),r.jsepCreateDownloader=(m,g,x)=>c.createDownloader(m,g,x),r.jsepOnCreateSession=m=>{c.onCreateSession(m)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepOnRunStart=m=>c.onRunStart(m),r.$d=(m,g)=>{c.upload(m,g)}}else if(i===\"webnn\"){[r.Dd,r.Yd,r.Id,r.jsepEnsureTensor,r.Jd,r.jsepDownloadTensor]=u,r.jsepReleaseTensorId=r.Id,r.jsepUploadTensor=r.Jd;let c=r.Dd;r.jsepOnRunStart=m=>c.onRunStart(m),r.jsepOnRunEnd=c.onRunEnd.bind(c),r.jsepRegisterMLContext=(m,g)=>{c.registerMLContext(m,g)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepCreateMLTensorDownloader=(m,g)=>c.createMLTensorDownloader(m,g),r.jsepRegisterMLTensor=(m,g,x,I)=>c.registerMLTensor(m,g,x,I),r.jsepCreateMLContext=m=>c.createMLContext(m),r.jsepRegisterMLConstant=(m,g,x,I,z)=>c.registerMLConstant(m,g,x,I,z,r.Bd),r.jsepRegisterGraphInput=c.registerGraphInput.bind(c),r.jsepIsGraphInput=c.isGraphInput.bind(c),r.jsepCreateTemporaryTensor=c.createTemporaryTensor.bind(c)}};var f,h,y=Object.assign({},r),_=(i,u)=>{throw u},b=\"\";(a||s)&&(s?b=self.location.href:typeof document<\"u\"&&document.currentScript&&(b=document.currentScript.src),Kn&&(b=Kn),b=b.startsWith(\"blob:\")?\"\":b.slice(0,b.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),s&&(h=i=>{var u=new XMLHttpRequest;return u.open(\"GET\",i,!1),u.responseType=\"arraybuffer\",u.send(null),new Uint8Array(u.response)}),f=async i=>{if(le(i))return new Promise((c,m)=>{var g=new XMLHttpRequest;g.open(\"GET\",i,!0),g.responseType=\"arraybuffer\",g.onload=()=>{g.status==200||g.status==0&&g.response?c(g.response):m(g.status)},g.onerror=m,g.send(null)});var u=await fetch(i,{credentials:\"same-origin\"});if(u.ok)return u.arrayBuffer();throw Error(u.status+\" : \"+u.url)});var w=console.log.bind(console),S=console.error.bind(console),$=w,v=S;Object.assign(r,y),y=null;var T,C,A,k,O,M,V,F,j,ne,W,J,ve,Q=r.wasmBinary,ee=!1,le=i=>i.startsWith(\"file://\");function Z(){return T.buffer!=k.buffer&&be(),k}function pe(){return T.buffer!=k.buffer&&be(),O}function ke(){return T.buffer!=k.buffer&&be(),M}function Se(){return T.buffer!=k.buffer&&be(),V}function D(){return T.buffer!=k.buffer&&be(),F}function R(){return T.buffer!=k.buffer&&be(),j}function Y(){return T.buffer!=k.buffer&&be(),ne}function fe(){return T.buffer!=k.buffer&&be(),ve}if(d){let i=function(u){try{var c=u.data,m=c.yd;if(m===\"load\"){let g=[];self.onmessage=x=>g.push(x),self.startWorker=()=>{postMessage({yd:\"loaded\"});for(let x of g)i(x);self.onmessage=i};for(let x of c.Od)r[x]&&!r[x].proxy||(r[x]=(...I)=>{postMessage({yd:\"callHandler\",Nd:x,args:I})},x==\"print\"&&($=r[x]),x==\"printErr\"&&(v=r[x]));T=c.he,be(),Fe(c.ie)}else if(m===\"run\"){cp(c.xd),Dn(c.xd,0,0,1,0,0),Lo(),An(c.xd),xe||(Mi(),xe=!0);try{pp(c.de,c.Fd)}catch(g){if(g!=\"unwind\")throw g}}else c.target!==\"setimmediate\"&&(m===\"checkMailbox\"?xe&&ur():m&&(v(`worker: received unknown command ${m}`),v(c)))}catch(g){throw Ri(),g}};var ub=i,Fe,xe=!1;v=function(...u){u=u.join(\" \"),console.error(u)},self.alert=function(...u){postMessage({yd:\"alert\",text:u.join(\" \"),fe:gr()})},self.onunhandledrejection=u=>{throw u.reason||u},self.onmessage=i}function be(){var i=T.buffer;r.HEAP8=k=new Int8Array(i),r.HEAP16=M=new Int16Array(i),r.HEAPU8=O=new Uint8Array(i),r.HEAPU16=V=new Uint16Array(i),r.HEAP32=F=new Int32Array(i),r.HEAPU32=j=new Uint32Array(i),r.HEAPF32=ne=new Float32Array(i),r.HEAPF64=ve=new Float64Array(i),r.HEAP64=W=new BigInt64Array(i),r.HEAPU64=J=new BigUint64Array(i)}function Ye(){d?startWorker(r):U.Bb()}d||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),be());var Gt,xt=0,Ht=null;function Bo(){if(--xt==0&&Ht){var i=Ht;Ht=null,i()}}function ut(i){throw v(i=\"Aborted(\"+i+\")\"),ee=!0,i=new WebAssembly.RuntimeError(i+\". Build with -sASSERTIONS for more info.\"),n(i),i}function Mo(){return{a:{Ta:lp,Va:dp,W:mp,la:fp,b:gp,u:yp,R:bp,Za:_p,d:wp,pb:qo,g:hp,T:Zo,Ga:Qo,lb:Xo,nb:Jo,Ha:ei,Ea:ti,wb:ri,Da:ni,pa:oi,mb:ii,jb:ai,Fa:si,kb:ui,Ma:vp,za:xp,eb:Sp,cb:Cp,ya:Ap,V:kp,N:Ep,db:Pp,ma:Up,fb:Np,zb:Vp,hb:Wp,qb:Lp,ab:Gp,Aa:Hp,yb:An,Ja:Fp,S:qp,Wa:Kp,$:Qp,G:Yp,E:Jp,m:Tn,H:em,B:nm,X:om,J:im,v:am,O:sm,D:um,t:dm,A:lm,z:cm,w:pm,r:mm,tb:fm,ub:hm,vb:gm,rb:$i,sb:xi,bb:Si,Oa:bm,La:vm,y:$m,ja:xm,Ba:Sm,Ka:_m,qa:Tm,Ia:Cm,ib:Im,U:ym,fa:Am,Sa:km,gb:Em,Qa:Pm,Pa:zm,Ab:Ai,Ca:ki,ob:_n,aa:Ei,oa:Pi,xb:zi,na:Oi,$a:af,ia:_f,sa:Sf,ga:nf,da:pf,ua:$f,p:tf,e:Nm,c:Rm,ea:lf,f:Vm,n:Lm,k:Ym,Y:Hm,ka:Xm,j:rf,wa:df,Ra:If,ca:yf,Ua:Cf,P:cf,K:qm,_:gf,Q:of,Z:wf,x:Fm,l:Um,va:hf,i:Mm,h:Gm,ra:Tf,ta:xf,o:Wm,q:Km,s:Zm,I:Qm,C:ef,L:Jm,xa:uf,_a:sf,F:bf,Ya:mf,ba:vf,M:jm,Xa:ff,ha:Dm,a:T,Na:bn}}}var hn={1319426:()=>typeof wasmOffsetConverter<\"u\",1319483:(i,u,c,m,g)=>{if(r===void 0||!r.Bd)return 1;if((i=Ae(Number(i>>>0))).startsWith(\"./\")&&(i=i.substring(2)),!(i=r.Bd.get(i)))return 2;if(u=Number(u>>>0),c=Number(c>>>0),m=Number(m>>>0),u+c>i.byteLength)return 3;try{let x=i.subarray(u,u+c);switch(g){case 0:pe().set(x,m>>>0);break;case 1:r.$d(m,x);break;default:return 4}return 0}catch{return 4}},1320198:(i,u,c)=>{r.Jd(i,pe().subarray(u>>>0,u+c>>>0))},1320261:()=>r.Yd(),1320302:i=>{r.Id(i)},1320338:()=>{r.Sd()},1320369:()=>{r.Td()},1320398:()=>{r.Xd()},1320423:i=>r.Rd(i),1320456:i=>r.Vd(i),1320488:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c),!0)},1320551:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c))},1320608:i=>{r.hc(\"Abs\",i,void 0)},1320659:i=>{r.hc(\"Neg\",i,void 0)},1320710:i=>{r.hc(\"Floor\",i,void 0)},1320763:i=>{r.hc(\"Ceil\",i,void 0)},1320815:i=>{r.hc(\"Reciprocal\",i,void 0)},1320873:i=>{r.hc(\"Sqrt\",i,void 0)},1320925:i=>{r.hc(\"Exp\",i,void 0)},1320976:i=>{r.hc(\"Erf\",i,void 0)},1321027:i=>{r.hc(\"Sigmoid\",i,void 0)},1321082:(i,u,c)=>{r.hc(\"HardSigmoid\",i,{alpha:u,beta:c})},1321161:i=>{r.hc(\"Log\",i,void 0)},1321212:i=>{r.hc(\"Sin\",i,void 0)},1321263:i=>{r.hc(\"Cos\",i,void 0)},1321314:i=>{r.hc(\"Tan\",i,void 0)},1321365:i=>{r.hc(\"Asin\",i,void 0)},1321417:i=>{r.hc(\"Acos\",i,void 0)},1321469:i=>{r.hc(\"Atan\",i,void 0)},1321521:i=>{r.hc(\"Sinh\",i,void 0)},1321573:i=>{r.hc(\"Cosh\",i,void 0)},1321625:i=>{r.hc(\"Asinh\",i,void 0)},1321678:i=>{r.hc(\"Acosh\",i,void 0)},1321731:i=>{r.hc(\"Atanh\",i,void 0)},1321784:i=>{r.hc(\"Tanh\",i,void 0)},1321836:i=>{r.hc(\"Not\",i,void 0)},1321887:(i,u,c)=>{r.hc(\"Clip\",i,{min:u,max:c})},1321956:i=>{r.hc(\"Clip\",i,void 0)},1322008:(i,u)=>{r.hc(\"Elu\",i,{alpha:u})},1322066:i=>{r.hc(\"Gelu\",i,void 0)},1322118:i=>{r.hc(\"Relu\",i,void 0)},1322170:(i,u)=>{r.hc(\"LeakyRelu\",i,{alpha:u})},1322234:(i,u)=>{r.hc(\"ThresholdedRelu\",i,{alpha:u})},1322304:(i,u)=>{r.hc(\"Cast\",i,{to:u})},1322362:i=>{r.hc(\"Add\",i,void 0)},1322413:i=>{r.hc(\"Sub\",i,void 0)},1322464:i=>{r.hc(\"Mul\",i,void 0)},1322515:i=>{r.hc(\"Div\",i,void 0)},1322566:i=>{r.hc(\"Pow\",i,void 0)},1322617:i=>{r.hc(\"Equal\",i,void 0)},1322670:i=>{r.hc(\"Greater\",i,void 0)},1322725:i=>{r.hc(\"GreaterOrEqual\",i,void 0)},1322787:i=>{r.hc(\"Less\",i,void 0)},1322839:i=>{r.hc(\"LessOrEqual\",i,void 0)},1322898:(i,u,c,m,g)=>{r.hc(\"ReduceMean\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323073:(i,u,c,m,g)=>{r.hc(\"ReduceMax\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323247:(i,u,c,m,g)=>{r.hc(\"ReduceMin\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323421:(i,u,c,m,g)=>{r.hc(\"ReduceProd\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323596:(i,u,c,m,g)=>{r.hc(\"ReduceSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323770:(i,u,c,m,g)=>{r.hc(\"ReduceL1\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323943:(i,u,c,m,g)=>{r.hc(\"ReduceL2\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324116:(i,u,c,m,g)=>{r.hc(\"ReduceLogSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324293:(i,u,c,m,g)=>{r.hc(\"ReduceSumSquare\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324473:(i,u,c,m,g)=>{r.hc(\"ReduceLogSumExp\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324653:i=>{r.hc(\"Where\",i,void 0)},1324706:(i,u,c)=>{r.hc(\"Transpose\",i,{perm:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[]})},1324830:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1324963:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1325096:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1325529:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1326190:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1326623:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1327284:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327375:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1327854:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327945:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328424:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1328511:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328986:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1329073:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1329548:(i,u,c,m,g)=>{r.hc(\"Gemm\",i,{alpha:u,beta:c,transA:m,transB:g})},1329652:i=>{r.hc(\"MatMul\",i,void 0)},1329706:(i,u,c,m)=>{r.hc(\"ArgMax\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329814:(i,u,c,m)=>{r.hc(\"ArgMin\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329922:(i,u)=>{r.hc(\"Softmax\",i,{axis:u})},1329985:(i,u)=>{r.hc(\"Concat\",i,{axis:u})},1330045:(i,u,c,m,g)=>{r.hc(\"Split\",i,{axis:u,numOutputs:c,splitSizes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1330201:i=>{r.hc(\"Expand\",i,void 0)},1330255:(i,u)=>{r.hc(\"Gather\",i,{axis:Number(u)})},1330326:(i,u)=>{r.hc(\"GatherElements\",i,{axis:Number(u)})},1330405:(i,u)=>{r.hc(\"GatherND\",i,{batch_dims:Number(u)})},1330484:(i,u,c,m,g,x,I,z,B,L,q)=>{r.hc(\"Resize\",i,{antialias:u,axes:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],coordinateTransformMode:Ae(g),cubicCoeffA:x,excludeOutside:I,extrapolationValue:z,keepAspectRatioPolicy:Ae(B),mode:Ae(L),nearestMode:Ae(q)})},1330846:(i,u,c,m,g,x,I)=>{r.hc(\"Slice\",i,{starts:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[],ends:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[],axes:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[]})},1331110:i=>{r.hc(\"Tile\",i,void 0)},1331162:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331276:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331390:i=>{r.hc(\"Range\",i,void 0)},1331443:(i,u)=>{r.hc(\"Einsum\",i,{equation:Ae(u)})},1331524:(i,u,c,m,g)=>{r.hc(\"Pad\",i,{mode:u,value:c,pads:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1331667:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1331836:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1332005:(i,u,c)=>{r.hc(\"CumSum\",i,{exclusive:Number(u),reverse:Number(c)})},1332102:(i,u,c)=>{r.hc(\"DequantizeLinear\",i,{axis:u,blockSize:c})},1332192:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332362:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332532:(i,u)=>{r.hc(\"ScatterND\",i,{reduction:Ae(u)})},1332617:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"Attention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x,qkvHiddenSizes:I?Array.from(D().subarray(Number(z)>>>0,Number(z)+I>>>0)):[],pastPresentShareBuffer:!!B})},1332889:i=>{r.hc(\"BiasAdd\",i,void 0)},1332944:i=>{r.hc(\"BiasSplitGelu\",i,void 0)},1333005:i=>{r.hc(\"FastGelu\",i,void 0)},1333061:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le,jt)=>{r.hc(\"Conv\",i,{format:X?\"NHWC\":\"NCHW\",auto_pad:u,dilations:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],group:g,kernel_shape:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],pads:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],strides:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],w_is_const:()=>!!Z()[Number(ue)>>>0],activation:Ae($e),activation_params:Le?Array.from(Y().subarray(Number(Le)>>>0,Number(jt)>>>0)):[]})},1333645:i=>{r.hc(\"Gelu\",i,void 0)},1333697:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"GroupQueryAttention\",i,{numHeads:u,kvNumHeads:c,scale:m,softcap:g,doRotary:x,rotaryInterleaved:I,smoothSoftmax:z,localWindowSize:B})},1333914:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334025:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334136:(i,u,c,m,g,x)=>{r.hc(\"MatMulNBits\",i,{k:u,n:c,accuracyLevel:m,bits:g,blockSize:x})},1334263:(i,u,c,m,g,x)=>{r.hc(\"MultiHeadAttention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x})},1334422:(i,u)=>{r.hc(\"QuickGelu\",i,{alpha:u})},1334486:(i,u,c,m,g)=>{r.hc(\"RotaryEmbedding\",i,{interleaved:!!u,numHeads:c,rotaryEmbeddingDim:m,scale:g})},1334625:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334727:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334829:(i,u,c,m)=>{r.hc(\"GatherBlockQuantized\",i,{gatherAxis:u,quantizeAxis:c,blockSize:m})},1334950:i=>{r.Wd(i)},1334984:(i,u)=>r.Zd(Number(i),Number(u),r.Cd.be,r.Cd.errors)};function dp(i,u,c){return gi(async()=>{await r.Ud(Number(i),Number(u),Number(c))})}function lp(){return typeof wasmOffsetConverter<\"u\"}class gn{name=\"ExitStatus\";constructor(u){this.message=`Program terminated with exit(${u})`,this.status=u}}var Ro=i=>{i.terminate(),i.onmessage=()=>{}},yn=[],Uo=i=>{ft.length==0&&(Ho(),Go(ft[0]));var u=ft.pop();if(!u)return 6;Ft.push(u),St[i.xd]=u,u.xd=i.xd;var c={yd:\"run\",de:i.ce,Fd:i.Fd,xd:i.xd};return u.postMessage(c,i.Ld),0},mt=0,Te=(i,u,...c)=>{for(var m=2*c.length,g=ie(),x=Mn(8*m),I=x>>>3,z=0;z<c.length;z++){var B=c[z];typeof B==\"bigint\"?(W[I+2*z]=1n,W[I+2*z+1]=B):(W[I+2*z]=0n,fe()[I+2*z+1>>>0]=B)}return i=Ui(i,0,m,x,u),oe(g),i};function bn(i){if(d)return Te(0,1,i);if(A=i,!(0<mt)){for(var u of Ft)Ro(u);for(u of ft)Ro(u);ft=[],Ft=[],St={},ee=!0}_(0,new gn(i))}function No(i){if(d)return Te(1,0,i);_n(i)}var _n=i=>{if(A=i,d)throw No(i),\"unwind\";bn(i)},ft=[],Ft=[],Vo=[],St={},Wo=i=>{var u=i.xd;delete St[u],ft.push(i),Ft.splice(Ft.indexOf(i),1),i.xd=0,Ni(u)};function Lo(){Vo.forEach(i=>i())}var Go=i=>new Promise(u=>{i.onmessage=g=>{var x=(g=g.data).yd;if(g.Ed&&g.Ed!=gr()){var I=St[g.Ed];I?I.postMessage(g,g.Ld):v(`Internal error! Worker sent a message \"${x}\" to target pthread ${g.Ed}, but that thread no longer exists!`)}else x===\"checkMailbox\"?ur():x===\"spawnThread\"?Uo(g):x===\"cleanupThread\"?Wo(St[g.ee]):x===\"loaded\"?(i.loaded=!0,u(i)):x===\"alert\"?alert(`Thread ${g.fe}: ${g.text}`):g.target===\"setimmediate\"?i.postMessage(g):x===\"callHandler\"?r[g.Nd](...g.args):x&&v(`worker sent an unknown command ${x}`)},i.onerror=g=>{throw v(`worker sent an error! ${g.filename}:${g.lineno}: ${g.message}`),g};var c,m=[];for(c of[])r.propertyIsEnumerable(c)&&m.push(c);i.postMessage({yd:\"load\",Od:m,he:T,ie:C})});function Ho(){var i=new Worker(\"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\".startsWith(\"file:\")?/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d91e\")):new URL(\"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});ft.push(i)}var cp=i=>{be();var u=R()[i+52>>>2>>>0];i=R()[i+56>>>2>>>0],Li(u,u-i),oe(u)},pp=(i,u)=>{mt=0,i=Rn(i,u),0<mt?A=i:Bn(i)},sr=[];function mp(i){var u=new wn(i>>>=0);if(Z()[u.wd+12>>>0]==0){var c=1;Z()[u.wd+12>>>0]=c}return c=0,Z()[u.wd+13>>>0]=c,sr.push(u),Hi(i),qi(i)}var Dt=0,fp=()=>{se(0,0);var i=sr.pop();Gi(i.Gd),Dt=0};class wn{constructor(u){this.Gd=u,this.wd=u-24}}function hp(i){throw Dt||=i>>>0,Dt}var vn=i=>{var u=Dt;if(!u)return Kt(0),0;var c=new wn(u);R()[c.wd+16>>>2>>>0]=u;var m=R()[c.wd+4>>>2>>>0];if(!m)return Kt(0),u;for(var g of i){if(g===0||g===m)break;if(Fi(g,m,c.wd+16))return Kt(g),u}return Kt(m),u};function gp(){return vn([])}function yp(i){return vn([i>>>0])}function bp(i,u){return vn([i>>>0,u>>>0])}var _p=()=>{var i=sr.pop();i||ut(\"no exception to throw\");var u=i.Gd;if(Z()[i.wd+13>>>0]==0){sr.push(i);var c=1;Z()[i.wd+13>>>0]=c,c=0,Z()[i.wd+12>>>0]=c}throw Dt=u};function wp(i,u,c){var m=new wn(i>>>=0);throw u>>>=0,c>>>=0,R()[m.wd+16>>>2>>>0]=0,R()[m.wd+4>>>2>>>0]=u,R()[m.wd+8>>>2>>>0]=c,Dt=i}function Fo(i,u,c,m){return d?Te(2,1,i,u,c,m):qo(i,u,c,m)}function qo(i,u,c,m){if(i>>>=0,c>>>=0,m>>>=0,l===void 0)return 6;var g=[];return d&&g.length===0?Fo(i,u>>>=0,c,m):(i={ce:c,xd:i,Fd:m,Ld:g},d?(i.yd=\"spawnThread\",postMessage(i,g),0):Uo(i))}var Ko=typeof TextDecoder<\"u\"?new TextDecoder:void 0,jo=(i,u=0,c=NaN)=>{var m=(u>>>=0)+c;for(c=u;i[c]&&!(c>=m);)++c;if(16<c-u&&i.buffer&&Ko)return Ko.decode(i.buffer instanceof ArrayBuffer?i.subarray(u,c):i.slice(u,c));for(m=\"\";u<c;){var g=i[u++];if(128&g){var x=63&i[u++];if((224&g)==192)m+=String.fromCharCode((31&g)<<6|x);else{var I=63&i[u++];65536>(g=(240&g)==224?(15&g)<<12|x<<6|I:(7&g)<<18|x<<12|I<<6|63&i[u++])?m+=String.fromCharCode(g):(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g))}}else m+=String.fromCharCode(g)}return m},Ae=(i,u)=>(i>>>=0)?jo(pe(),i,u):\"\";function Zo(i,u,c){return d?Te(3,1,i,u,c):0}function Qo(i,u){if(d)return Te(4,1,i,u)}var Yo=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);127>=m?u++:2047>=m?u+=2:55296<=m&&57343>=m?(u+=4,++c):u+=3}return u},Bt=(i,u,c)=>{var m=pe();if(u>>>=0,0<c){var g=u;c=u+c-1;for(var x=0;x<i.length;++x){var I=i.charCodeAt(x);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&i.charCodeAt(++x)),127>=I){if(u>=c)break;m[u++>>>0]=I}else{if(2047>=I){if(u+1>=c)break;m[u++>>>0]=192|I>>6}else{if(65535>=I){if(u+2>=c)break;m[u++>>>0]=224|I>>12}else{if(u+3>=c)break;m[u++>>>0]=240|I>>18,m[u++>>>0]=128|I>>12&63}m[u++>>>0]=128|I>>6&63}m[u++>>>0]=128|63&I}}m[u>>>0]=0,i=u-g}else i=0;return i};function Xo(i,u){if(d)return Te(5,1,i,u)}function Jo(i,u,c){if(d)return Te(6,1,i,u,c)}function ei(i,u,c){return d?Te(7,1,i,u,c):0}function ti(i,u){if(d)return Te(8,1,i,u)}function ri(i,u,c){if(d)return Te(9,1,i,u,c)}function ni(i,u,c,m){if(d)return Te(10,1,i,u,c,m)}function oi(i,u,c,m){if(d)return Te(11,1,i,u,c,m)}function ii(i,u,c,m){if(d)return Te(12,1,i,u,c,m)}function ai(i){if(d)return Te(13,1,i)}function si(i,u){if(d)return Te(14,1,i,u)}function ui(i,u,c){if(d)return Te(15,1,i,u,c)}var di,ht,vp=()=>ut(\"\"),Xe=i=>{for(var u=\"\";pe()[i>>>0];)u+=di[pe()[i++>>>0]];return u},$n={},xn={},$p={};function dt(i,u,c={}){return function(m,g,x={}){var I=g.name;if(!m)throw new ht(`type \"${I}\" must have a positive integer typeid pointer`);if(xn.hasOwnProperty(m)){if(x.Pd)return;throw new ht(`Cannot register type '${I}' twice`)}xn[m]=g,delete $p[m],$n.hasOwnProperty(m)&&(g=$n[m],delete $n[m],g.forEach(z=>z()))}(i,u,c)}var li=(i,u,c)=>{switch(u){case 1:return c?m=>Z()[m>>>0]:m=>pe()[m>>>0];case 2:return c?m=>ke()[m>>>1>>>0]:m=>Se()[m>>>1>>>0];case 4:return c?m=>D()[m>>>2>>>0]:m=>R()[m>>>2>>>0];case 8:return c?m=>W[m>>>3]:m=>J[m>>>3];default:throw new TypeError(`invalid integer width (${u}): ${i}`)}};function xp(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:function(m,g){if(typeof g!=\"bigint\"&&typeof g!=\"number\")throw g=g===null?\"null\":(m=typeof g)==\"object\"||m===\"array\"||m===\"function\"?g.toString():\"\"+g,new TypeError(`Cannot convert \"${g}\" to ${this.name}`);return typeof g==\"number\"&&(g=BigInt(g)),g},zd:gt,readValueFromPointer:li(u,c,u.indexOf(\"u\")==-1),Ad:null})}var gt=8;function Sp(i,u,c,m){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(g){return!!g},toWireType:function(g,x){return x?c:m},zd:gt,readValueFromPointer:function(g){return this.fromWireType(pe()[g>>>0])},Ad:null})}var Sn=[],lt=[];function Tn(i){9<(i>>>=0)&&--lt[i+1]==0&&(lt[i]=void 0,Sn.push(i))}var Re=i=>{if(!i)throw new ht(\"Cannot use deleted val. handle = \"+i);return lt[i]},We=i=>{switch(i){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let u=Sn.pop()||lt.length;return lt[u]=i,lt[u+1]=1,u}};function Cn(i){return this.fromWireType(R()[i>>>2>>>0])}var Tp={name:\"emscripten::val\",fromWireType:i=>{var u=Re(i);return Tn(i),u},toWireType:(i,u)=>We(u),zd:gt,readValueFromPointer:Cn,Ad:null};function Cp(i){return dt(i>>>0,Tp)}var Ip=(i,u)=>{switch(u){case 4:return function(c){return this.fromWireType(Y()[c>>>2>>>0])};case 8:return function(c){return this.fromWireType(fe()[c>>>3>>>0])};default:throw new TypeError(`invalid float width (${u}): ${i}`)}};function Ap(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:(m,g)=>g,zd:gt,readValueFromPointer:Ip(u,c),Ad:null})}function kp(i,u,c,m,g){if(i>>>=0,c>>>=0,u=Xe(u>>>0),g===-1&&(g=4294967295),g=z=>z,m===0){var x=32-8*c;g=z=>z<<x>>>x}var I=u.includes(\"unsigned\")?function(z,B){return B>>>0}:function(z,B){return B};dt(i,{name:u,fromWireType:g,toWireType:I,zd:gt,readValueFromPointer:li(u,c,m!==0),Ad:null})}function Ep(i,u,c){function m(x){var I=R()[x>>>2>>>0];return x=R()[x+4>>>2>>>0],new g(Z().buffer,x,I)}var g=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][u];dt(i>>>=0,{name:c=Xe(c>>>0),fromWireType:m,zd:gt,readValueFromPointer:m},{Pd:!0})}function Pp(i,u){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(c){for(var m,g=R()[c>>>2>>>0],x=c+4,I=x,z=0;z<=g;++z){var B=x+z;z!=g&&pe()[B>>>0]!=0||(I=Ae(I,B-I),m===void 0?m=I:(m+=\"\\0\",m+=I),I=B+1)}return et(c),m},toWireType:function(c,m){m instanceof ArrayBuffer&&(m=new Uint8Array(m));var g=typeof m==\"string\";if(!(g||m instanceof Uint8Array||m instanceof Uint8ClampedArray||m instanceof Int8Array))throw new ht(\"Cannot pass non-string to std::string\");var x=g?Yo(m):m.length,I=yr(4+x+1),z=I+4;if(R()[I>>>2>>>0]=x,g)Bt(m,z,x+1);else if(g)for(g=0;g<x;++g){var B=m.charCodeAt(g);if(255<B)throw et(I),new ht(\"String has UTF-16 code units that do not fit in 8 bits\");pe()[z+g>>>0]=B}else for(g=0;g<x;++g)pe()[z+g>>>0]=m[g];return c!==null&&c.push(et,I),I},zd:gt,readValueFromPointer:Cn,Ad(c){et(c)}})}var ci=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,zp=(i,u)=>{for(var c=i>>1,m=c+u/2;!(c>=m)&&Se()[c>>>0];)++c;if(32<(c<<=1)-i&&ci)return ci.decode(pe().slice(i,c));for(c=\"\",m=0;!(m>=u/2);++m){var g=ke()[i+2*m>>>1>>>0];if(g==0)break;c+=String.fromCharCode(g)}return c},Op=(i,u,c)=>{if(c??=2147483647,2>c)return 0;var m=u;c=(c-=2)<2*i.length?c/2:i.length;for(var g=0;g<c;++g){var x=i.charCodeAt(g);ke()[u>>>1>>>0]=x,u+=2}return ke()[u>>>1>>>0]=0,u-m},Dp=i=>2*i.length,Bp=(i,u)=>{for(var c=0,m=\"\";!(c>=u/4);){var g=D()[i+4*c>>>2>>>0];if(g==0)break;++c,65536<=g?(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g)):m+=String.fromCharCode(g)}return m},Mp=(i,u,c)=>{if(u>>>=0,c??=2147483647,4>c)return 0;var m=u;c=m+c-4;for(var g=0;g<i.length;++g){var x=i.charCodeAt(g);if(55296<=x&&57343>=x&&(x=65536+((1023&x)<<10)|1023&i.charCodeAt(++g)),D()[u>>>2>>>0]=x,(u+=4)+4>c)break}return D()[u>>>2>>>0]=0,u-m},Rp=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);55296<=m&&57343>=m&&++c,u+=4}return u};function Up(i,u,c){if(i>>>=0,u>>>=0,c=Xe(c>>>=0),u===2)var m=zp,g=Op,x=Dp,I=z=>Se()[z>>>1>>>0];else u===4&&(m=Bp,g=Mp,x=Rp,I=z=>R()[z>>>2>>>0]);dt(i,{name:c,fromWireType:z=>{for(var B,L=R()[z>>>2>>>0],q=z+4,X=0;X<=L;++X){var ue=z+4+X*u;X!=L&&I(ue)!=0||(q=m(q,ue-q),B===void 0?B=q:(B+=\"\\0\",B+=q),q=ue+u)}return et(z),B},toWireType:(z,B)=>{if(typeof B!=\"string\")throw new ht(`Cannot pass non-string to C++ string type ${c}`);var L=x(B),q=yr(4+L+u);return R()[q>>>2>>>0]=L/u,g(B,q+4,L+u),z!==null&&z.push(et,q),q},zd:gt,readValueFromPointer:Cn,Ad(z){et(z)}})}function Np(i,u){dt(i>>>=0,{Qd:!0,name:u=Xe(u>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function Vp(i){Dn(i>>>0,!s,1,!a,131072,!1),Lo()}var In=i=>{if(!ee)try{if(i(),!(0<mt))try{d?Bn(A):_n(A)}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}};function An(i){i>>>=0,typeof Atomics.ge==\"function\"&&(Atomics.ge(D(),i>>>2,i).value.then(ur),i+=128,Atomics.store(D(),i>>>2,1))}var ur=()=>{var i=gr();i&&(An(i),In(Wi))};function Wp(i,u){(i>>>=0)==u>>>0?setTimeout(ur):d?postMessage({Ed:i,yd:\"checkMailbox\"}):(i=St[i])&&i.postMessage({yd:\"checkMailbox\"})}var kn=[];function Lp(i,u,c,m,g){for(u>>>=0,m/=2,kn.length=m,c=g>>>0>>>3,g=0;g<m;g++)kn[g]=W[c+2*g]?W[c+2*g+1]:fe()[c+2*g+1>>>0];return(u?hn[u]:Bm[i])(...kn)}var Gp=()=>{mt=0};function Hp(i){i>>>=0,d?postMessage({yd:\"cleanupThread\",ee:i}):Wo(St[i])}function Fp(i){}var dr=(i,u)=>{var c=xn[i];if(c===void 0)throw i=Bi(i),c=Xe(i),et(i),new ht(`${u} has unknown type ${c}`);return c},pi=(i,u,c)=>{var m=[];return i=i.toWireType(m,c),m.length&&(R()[u>>>2>>>0]=We(m)),i};function qp(i,u,c){return u>>>=0,c>>>=0,i=Re(i>>>0),u=dr(u,\"emval::as\"),pi(u,c,i)}function Kp(i,u){return u>>>=0,i=Re(i>>>0),(u=dr(u,\"emval::as\")).toWireType(null,i)}var lr=i=>{try{i()}catch(u){ut(u)}},yt=0,Je=null,mi=0,cr=[],fi={},hi={},jp=0,En=null,Zp=[];function gi(i){return function(u){if(!ee){if(yt===0){var c=!1,m=!1;u((g=0)=>{if(!ee&&(mi=g,c=!0,m)){yt=2,lr(()=>Na(Je)),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.resume(),g=!1;try{var x=function(){var B=D()[Je+8>>>2>>>0];return B=U[hi[B]],--mt,B()}()}catch(B){x=B,g=!0}var I=!1;if(!Je){var z=En;z&&(En=null,(g?z.reject:z.resolve)(x),I=!0)}if(g&&!I)throw x}}),m=!0,c||(yt=1,Je=function(){var g=yr(65548),x=g+12;R()[g>>>2>>>0]=x,R()[g+4>>>2>>>0]=x+65536,x=cr[0];var I=fi[x];return I===void 0&&(I=jp++,fi[x]=I,hi[I]=x),x=I,D()[g+8>>>2>>>0]=x,g}(),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.pause(),lr(()=>Ra(Je)))}else yt===2?(yt=0,lr(Va),et(Je),Je=null,Zp.forEach(In)):ut(`invalid state: ${yt}`);return mi}}(u=>{i().then(u)})}function Qp(i){return i>>>=0,gi(async()=>{var u=await Re(i);return We(u)})}var pr=[];function Yp(i,u,c,m){return c>>>=0,m>>>=0,(i=pr[i>>>0])(null,u=Re(u>>>0),c,m)}var Xp={},mr=i=>{var u=Xp[i];return u===void 0?Xe(i):u};function Jp(i,u,c,m,g){return c>>>=0,m>>>=0,g>>>=0,(i=pr[i>>>0])(u=Re(u>>>0),u[c=mr(c)],m,g)}var yi=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function em(i){return(i>>>=0)==0?We(yi()):(i=mr(i),We(yi()[i]))}var tm=i=>{var u=pr.length;return pr.push(i),u},rm=(i,u)=>{for(var c=Array(i),m=0;m<i;++m)c[m]=dr(R()[u+4*m>>>2>>>0],\"parameter \"+m);return c},bi=(i,u)=>Object.defineProperty(u,\"name\",{value:i});function nm(i,u,c){var m=(u=rm(i,u>>>0)).shift();i--;var g=`return function (obj, func, destructorsRef, args) {\n`,x=0,I=[];c===0&&I.push(\"obj\");for(var z=[\"retType\"],B=[m],L=0;L<i;++L)I.push(\"arg\"+L),z.push(\"argType\"+L),B.push(u[L]),g+=`  var arg${L} = argType${L}.readValueFromPointer(args${x?\"+\"+x:\"\"});\n`,x+=u[L].zd;return g+=`  var rv = ${c===1?\"new func\":\"func.call\"}(${I.join(\", \")});\n`,m.Qd||(z.push(\"emval_returnValue\"),B.push(pi),g+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),z.push(g+`};\n`),i=function(q){var X=Function;if(!(X instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof X} which is not a function`);var ue=bi(X.name||\"unknownFunctionName\",function(){});return ue.prototype=X.prototype,ue=new ue,(q=X.apply(ue,q))instanceof Object?q:ue}(z)(...B),c=`methodCaller<(${u.map(q=>q.name).join(\", \")}) => ${m.name}>`,tm(bi(c,i))}function om(i){return i=mr(i>>>0),We(r[i])}function im(i,u){return u>>>=0,i=Re(i>>>0),u=Re(u),We(i[u])}function am(i){9<(i>>>=0)&&(lt[i+1]+=1)}function sm(){return We([])}function um(i){i=Re(i>>>0);for(var u=Array(i.length),c=0;c<i.length;c++)u[c]=i[c];return We(u)}function dm(i){return We(mr(i>>>0))}function lm(){return We({})}function cm(i){for(var u=Re(i>>>=0);u.length;){var c=u.pop();u.pop()(c)}Tn(i)}function pm(i,u,c){u>>>=0,c>>>=0,i=Re(i>>>0),u=Re(u),c=Re(c),i[u]=c}function mm(i,u){return u>>>=0,i=(i=dr(i>>>0,\"_emval_take_value\")).readValueFromPointer(u),We(i)}function fm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getUTCSeconds(),D()[u+4>>>2>>>0]=i.getUTCMinutes(),D()[u+8>>>2>>>0]=i.getUTCHours(),D()[u+12>>>2>>>0]=i.getUTCDate(),D()[u+16>>>2>>>0]=i.getUTCMonth(),D()[u+20>>>2>>>0]=i.getUTCFullYear()-1900,D()[u+24>>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,D()[u+28>>>2>>>0]=i}var _i=i=>i%4==0&&(i%100!=0||i%400==0),wi=[0,31,60,91,121,152,182,213,244,274,305,335],vi=[0,31,59,90,120,151,181,212,243,273,304,334];function hm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getSeconds(),D()[u+4>>>2>>>0]=i.getMinutes(),D()[u+8>>>2>>>0]=i.getHours(),D()[u+12>>>2>>>0]=i.getDate(),D()[u+16>>>2>>>0]=i.getMonth(),D()[u+20>>>2>>>0]=i.getFullYear()-1900,D()[u+24>>>2>>>0]=i.getDay();var c=(_i(i.getFullYear())?wi:vi)[i.getMonth()]+i.getDate()-1|0;D()[u+28>>>2>>>0]=c,D()[u+36>>>2>>>0]=-60*i.getTimezoneOffset(),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var m=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=0|(c!=m&&i.getTimezoneOffset()==Math.min(m,c)),D()[u+32>>>2>>>0]=i}function gm(i){i>>>=0;var u=new Date(D()[i+20>>>2>>>0]+1900,D()[i+16>>>2>>>0],D()[i+12>>>2>>>0],D()[i+8>>>2>>>0],D()[i+4>>>2>>>0],D()[i>>>2>>>0],0),c=D()[i+32>>>2>>>0],m=u.getTimezoneOffset(),g=new Date(u.getFullYear(),6,1).getTimezoneOffset(),x=new Date(u.getFullYear(),0,1).getTimezoneOffset(),I=Math.min(x,g);return 0>c?D()[i+32>>>2>>>0]=+(g!=x&&I==m):0<c!=(I==m)&&(g=Math.max(x,g),u.setTime(u.getTime()+6e4*((0<c?I:g)-m))),D()[i+24>>>2>>>0]=u.getDay(),c=(_i(u.getFullYear())?wi:vi)[u.getMonth()]+u.getDate()-1|0,D()[i+28>>>2>>>0]=c,D()[i>>>2>>>0]=u.getSeconds(),D()[i+4>>>2>>>0]=u.getMinutes(),D()[i+8>>>2>>>0]=u.getHours(),D()[i+12>>>2>>>0]=u.getDate(),D()[i+16>>>2>>>0]=u.getMonth(),D()[i+20>>>2>>>0]=u.getYear(),i=u.getTime(),BigInt(isNaN(i)?-1:i/1e3)}function $i(i,u,c,m,g,x,I){return d?Te(16,1,i,u,c,m,g,x,I):-52}function xi(i,u,c,m,g,x){if(d)return Te(17,1,i,u,c,m,g,x)}var qt={},ym=()=>performance.timeOrigin+performance.now();function Si(i,u){if(d)return Te(18,1,i,u);if(qt[i]&&(clearTimeout(qt[i].id),delete qt[i]),!u)return 0;var c=setTimeout(()=>{delete qt[i],In(()=>Vi(i,performance.timeOrigin+performance.now()))},u);return qt[i]={id:c,ke:u},0}function bm(i,u,c,m){i>>>=0,u>>>=0,c>>>=0,m>>>=0;var g=new Date().getFullYear(),x=new Date(g,0,1).getTimezoneOffset();g=new Date(g,6,1).getTimezoneOffset();var I=Math.max(x,g);R()[i>>>2>>>0]=60*I,D()[u>>>2>>>0]=+(x!=g),i=(u=z=>{var B=Math.abs(z);return`UTC${0<=z?\"-\":\"+\"}${String(Math.floor(B/60)).padStart(2,\"0\")}${String(B%60).padStart(2,\"0\")}`})(x),u=u(g),g<x?(Bt(i,c,17),Bt(u,m,17)):(Bt(i,m,17),Bt(u,c,17))}var _m=()=>Date.now(),wm=1;function vm(i,u,c){if(!(0<=i&&3>=i))return 28;if(i===0)i=Date.now();else{if(!wm)return 52;i=performance.timeOrigin+performance.now()}return W[c>>>0>>>3]=BigInt(Math.round(1e6*i)),0}var Pn=[],Ti=(i,u)=>{Pn.length=0;for(var c;c=pe()[i++>>>0];){var m=c!=105;u+=(m&=c!=112)&&u%8?4:0,Pn.push(c==112?R()[u>>>2>>>0]:c==106?W[u>>>3]:c==105?D()[u>>>2>>>0]:fe()[u>>>3>>>0]),u+=m?8:4}return Pn};function $m(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}function xm(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}var Sm=()=>{};function Tm(i,u){return v(Ae(i>>>0,u>>>0))}var Cm=()=>{throw mt+=1,\"unwind\"};function Im(){return 4294901760}var Am=()=>navigator.hardwareConcurrency;function km(){return ut(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Em(i){i>>>=0;var u=pe().length;if(i<=u||4294901760<i)return!1;for(var c=1;4>=c;c*=2){var m=u*(1+.2/c);m=Math.min(m,i+100663296);e:{m=(Math.min(4294901760,65536*Math.ceil(Math.max(i,m)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(m),be();var g=1;break e}catch{}g=void 0}if(g)return!0}return!1}var fr=()=>(ut(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Mt={},Ci=i=>{i.forEach(u=>{var c=fr();c&&(Mt[c]=u)})};function Pm(){var i=Error().stack.toString().split(`\n`);return i[0]==\"Error\"&&i.shift(),Ci(i),Mt.Kd=fr(),Mt.ae=i,Mt.Kd}function zm(i,u,c){if(i>>>=0,u>>>=0,Mt.Kd==i)var m=Mt.ae;else(m=Error().stack.toString().split(`\n`))[0]==\"Error\"&&m.shift(),Ci(m);for(var g=3;m[g]&&fr()!=i;)++g;for(i=0;i<c&&m[i+g];++i)D()[u+4*i>>>2>>>0]=fr();return i}var zn,On={},Ii=()=>{if(!zn){var i,u={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:\"./this.program\"};for(i in On)On[i]===void 0?delete u[i]:u[i]=On[i];var c=[];for(i in u)c.push(`${i}=${u[i]}`);zn=c}return zn};function Ai(i,u){if(d)return Te(19,1,i,u);i>>>=0,u>>>=0;var c=0;return Ii().forEach((m,g)=>{var x=u+c;for(g=R()[i+4*g>>>2>>>0]=x,x=0;x<m.length;++x)Z()[g++>>>0]=m.charCodeAt(x);Z()[g>>>0]=0,c+=m.length+1}),0}function ki(i,u){if(d)return Te(20,1,i,u);i>>>=0,u>>>=0;var c=Ii();R()[i>>>2>>>0]=c.length;var m=0;return c.forEach(g=>m+=g.length+1),R()[u>>>2>>>0]=m,0}function Ei(i){return d?Te(21,1,i):52}function Pi(i,u,c,m){return d?Te(22,1,i,u,c,m):52}function zi(i,u,c,m){return d?Te(23,1,i,u,c,m):70}var Om=[null,[],[]];function Oi(i,u,c,m){if(d)return Te(24,1,i,u,c,m);u>>>=0,c>>>=0,m>>>=0;for(var g=0,x=0;x<c;x++){var I=R()[u>>>2>>>0],z=R()[u+4>>>2>>>0];u+=8;for(var B=0;B<z;B++){var L=pe()[I+B>>>0],q=Om[i];L===0||L===10?((i===1?$:v)(jo(q)),q.length=0):q.push(L)}g+=z}return R()[m>>>2>>>0]=g,0}function Dm(i){return i>>>0}d||function(){for(var i=r.numThreads-1;i--;)Ho();yn.unshift(()=>{xt++,function(u){d?u():Promise.all(ft.map(Go)).then(u)}(()=>Bo())})}();for(var Di=Array(256),hr=0;256>hr;++hr)Di[hr]=String.fromCharCode(hr);di=Di,ht=r.BindingError=class extends Error{constructor(i){super(i),this.name=\"BindingError\"}},r.InternalError=class extends Error{constructor(i){super(i),this.name=\"InternalError\"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>lt.length/2-5-Sn.length;var U,Bm=[bn,No,Fo,Zo,Qo,Xo,Jo,ei,ti,ri,ni,oi,ii,ai,si,ui,$i,xi,Si,Ai,ki,Ei,Pi,zi,Oi];(async function(){function i(m,g){return U=m.exports,U=function(){var x=U,I={};for(let[z,B]of Object.entries(x))I[z]=typeof B==\"function\"?(...L)=>{cr.push(z);try{return B(...L)}finally{ee||(cr.pop(),Je&&yt===1&&cr.length===0&&(yt=0,mt+=1,lr(Ua),typeof Fibers<\"u\"&&Fibers.le()))}}:B;return I}(),U=function(){var x=U,I=B=>L=>B(L)>>>0,z=B=>()=>B()>>>0;return(x=Object.assign({},x)).Cb=I(x.Cb),x.fc=z(x.fc),x.ic=I(x.ic),x.vc=I(x.vc),x.wc=z(x.wc),x.Ac=I(x.Ac),x}(),Vo.push(U.jc),C=g,Bo(),U}xt++;var u=Mo();if(r.instantiateWasm)return new Promise(m=>{r.instantiateWasm(u,(g,x)=>{i(g,x),m(g.exports)})});if(d)return new Promise(m=>{Fe=g=>{var x=new WebAssembly.Instance(g,Mo());m(i(x,g))}});Gt??=r.locateFile?r.locateFile?r.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",b):b+\"ort-wasm-simd-threaded.jsep.wasm\":/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href;try{var c=await async function(m){var g=Gt;if(!Q&&typeof WebAssembly.instantiateStreaming==\"function\"&&!le(g))try{var x=fetch(g,{credentials:\"same-origin\"});return await WebAssembly.instantiateStreaming(x,m)}catch(I){v(`wasm streaming compile failed: ${I}`),v(\"falling back to ArrayBuffer instantiation\")}return async function(I,z){try{var B=await async function(L){if(!Q)try{var q=await f(L);return new Uint8Array(q)}catch{}if(L==Gt&&Q)L=new Uint8Array(Q);else{if(!h)throw\"both async and sync fetching of the wasm failed\";L=h(L)}return L}(I);return await WebAssembly.instantiate(B,z)}catch(L){v(`failed to asynchronously prepare wasm: ${L}`),ut(L)}}(g,m)}(u);return i(c.instance,c.module)}catch(m){return n(m),Promise.reject(m)}})();var Bi=i=>(Bi=U.Cb)(i),Mi=()=>(Mi=U.Db)();r._OrtInit=(i,u)=>(r._OrtInit=U.Eb)(i,u),r._OrtGetLastError=(i,u)=>(r._OrtGetLastError=U.Fb)(i,u),r._OrtCreateSessionOptions=(i,u,c,m,g,x,I,z,B,L)=>(r._OrtCreateSessionOptions=U.Gb)(i,u,c,m,g,x,I,z,B,L),r._OrtAppendExecutionProvider=(i,u)=>(r._OrtAppendExecutionProvider=U.Hb)(i,u),r._OrtAddFreeDimensionOverride=(i,u,c)=>(r._OrtAddFreeDimensionOverride=U.Ib)(i,u,c),r._OrtAddSessionConfigEntry=(i,u,c)=>(r._OrtAddSessionConfigEntry=U.Jb)(i,u,c),r._OrtReleaseSessionOptions=i=>(r._OrtReleaseSessionOptions=U.Kb)(i),r._OrtCreateSession=(i,u,c)=>(r._OrtCreateSession=U.Lb)(i,u,c),r._OrtReleaseSession=i=>(r._OrtReleaseSession=U.Mb)(i),r._OrtGetInputOutputCount=(i,u,c)=>(r._OrtGetInputOutputCount=U.Nb)(i,u,c),r._OrtGetInputName=(i,u)=>(r._OrtGetInputName=U.Ob)(i,u),r._OrtGetOutputName=(i,u)=>(r._OrtGetOutputName=U.Pb)(i,u),r._OrtFree=i=>(r._OrtFree=U.Qb)(i),r._OrtCreateTensor=(i,u,c,m,g,x)=>(r._OrtCreateTensor=U.Rb)(i,u,c,m,g,x),r._OrtGetTensorData=(i,u,c,m,g)=>(r._OrtGetTensorData=U.Sb)(i,u,c,m,g),r._OrtReleaseTensor=i=>(r._OrtReleaseTensor=U.Tb)(i),r._OrtCreateRunOptions=(i,u,c,m)=>(r._OrtCreateRunOptions=U.Ub)(i,u,c,m),r._OrtAddRunConfigEntry=(i,u,c)=>(r._OrtAddRunConfigEntry=U.Vb)(i,u,c),r._OrtReleaseRunOptions=i=>(r._OrtReleaseRunOptions=U.Wb)(i),r._OrtCreateBinding=i=>(r._OrtCreateBinding=U.Xb)(i),r._OrtBindInput=(i,u,c)=>(r._OrtBindInput=U.Yb)(i,u,c),r._OrtBindOutput=(i,u,c,m)=>(r._OrtBindOutput=U.Zb)(i,u,c,m),r._OrtClearBoundOutputs=i=>(r._OrtClearBoundOutputs=U._b)(i),r._OrtReleaseBinding=i=>(r._OrtReleaseBinding=U.$b)(i),r._OrtRunWithBinding=(i,u,c,m,g)=>(r._OrtRunWithBinding=U.ac)(i,u,c,m,g),r._OrtRun=(i,u,c,m,g,x,I,z)=>(r._OrtRun=U.bc)(i,u,c,m,g,x,I,z),r._OrtEndProfiling=i=>(r._OrtEndProfiling=U.cc)(i),r._JsepOutput=(i,u,c)=>(r._JsepOutput=U.dc)(i,u,c),r._JsepGetNodeName=i=>(r._JsepGetNodeName=U.ec)(i);var gr=()=>(gr=U.fc)(),et=r._free=i=>(et=r._free=U.gc)(i),yr=r._malloc=i=>(yr=r._malloc=U.ic)(i),Dn=(i,u,c,m,g,x)=>(Dn=U.kc)(i,u,c,m,g,x),Ri=()=>(Ri=U.lc)(),Ui=(i,u,c,m,g)=>(Ui=U.mc)(i,u,c,m,g),Ni=i=>(Ni=U.nc)(i),Bn=i=>(Bn=U.oc)(i),Vi=(i,u)=>(Vi=U.pc)(i,u),Wi=()=>(Wi=U.qc)(),se=(i,u)=>(se=U.rc)(i,u),Kt=i=>(Kt=U.sc)(i),Li=(i,u)=>(Li=U.tc)(i,u),oe=i=>(oe=U.uc)(i),Mn=i=>(Mn=U.vc)(i),ie=()=>(ie=U.wc)(),Gi=i=>(Gi=U.xc)(i),Hi=i=>(Hi=U.yc)(i),Fi=(i,u,c)=>(Fi=U.zc)(i,u,c),qi=i=>(qi=U.Ac)(i),Ki=r.dynCall_iii=(i,u,c)=>(Ki=r.dynCall_iii=U.Bc)(i,u,c),ji=r.dynCall_vi=(i,u)=>(ji=r.dynCall_vi=U.Cc)(i,u),Rn=r.dynCall_ii=(i,u)=>(Rn=r.dynCall_ii=U.Dc)(i,u),Zi=r.dynCall_vii=(i,u,c)=>(Zi=r.dynCall_vii=U.Ec)(i,u,c),Qi=r.dynCall_iiii=(i,u,c,m)=>(Qi=r.dynCall_iiii=U.Fc)(i,u,c,m),Yi=r.dynCall_viii=(i,u,c,m)=>(Yi=r.dynCall_viii=U.Gc)(i,u,c,m),Xi=r.dynCall_iiiii=(i,u,c,m,g)=>(Xi=r.dynCall_iiiii=U.Hc)(i,u,c,m,g),Ji=r.dynCall_viiii=(i,u,c,m,g)=>(Ji=r.dynCall_viiii=U.Ic)(i,u,c,m,g),ea=r.dynCall_viiiiii=(i,u,c,m,g,x,I)=>(ea=r.dynCall_viiiiii=U.Jc)(i,u,c,m,g,x,I),ta=r.dynCall_viiiiiii=(i,u,c,m,g,x,I,z)=>(ta=r.dynCall_viiiiiii=U.Kc)(i,u,c,m,g,x,I,z),ra=r.dynCall_ji=(i,u)=>(ra=r.dynCall_ji=U.Lc)(i,u),na=r.dynCall_v=i=>(na=r.dynCall_v=U.Mc)(i),oa=r.dynCall_viiiii=(i,u,c,m,g,x)=>(oa=r.dynCall_viiiii=U.Nc)(i,u,c,m,g,x),ia=r.dynCall_i=i=>(ia=r.dynCall_i=U.Oc)(i),aa=r.dynCall_fii=(i,u,c)=>(aa=r.dynCall_fii=U.Pc)(i,u,c),sa=r.dynCall_viiiiiiii=(i,u,c,m,g,x,I,z,B)=>(sa=r.dynCall_viiiiiiii=U.Qc)(i,u,c,m,g,x,I,z,B),ua=r.dynCall_viiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ua=r.dynCall_viiiiiiiiii=U.Rc)(i,u,c,m,g,x,I,z,B,L,q),da=r.dynCall_jiii=(i,u,c,m)=>(da=r.dynCall_jiii=U.Sc)(i,u,c,m),la=r.dynCall_dii=(i,u,c)=>(la=r.dynCall_dii=U.Tc)(i,u,c),ca=r.dynCall_viiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ca=r.dynCall_viiiiiiiii=U.Uc)(i,u,c,m,g,x,I,z,B,L),pa=r.dynCall_viiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X)=>(pa=r.dynCall_viiiiiiiiiii=U.Vc)(i,u,c,m,g,x,I,z,B,L,q,X),ma=r.dynCall_iiiiii=(i,u,c,m,g,x)=>(ma=r.dynCall_iiiiii=U.Wc)(i,u,c,m,g,x),fa=r.dynCall_iij=(i,u,c)=>(fa=r.dynCall_iij=U.Xc)(i,u,c),ha=r.dynCall_iiiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ha=r.dynCall_iiiiiiiiii=U.Yc)(i,u,c,m,g,x,I,z,B,L),ga=r.dynCall_iiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ga=r.dynCall_iiiiiiiiiii=U.Zc)(i,u,c,m,g,x,I,z,B,L,q),ya=r.dynCall_vij=(i,u,c)=>(ya=r.dynCall_vij=U._c)(i,u,c),ba=r.dynCall_iiif=(i,u,c,m)=>(ba=r.dynCall_iiif=U.$c)(i,u,c,m),_a=r.dynCall_iiij=(i,u,c,m)=>(_a=r.dynCall_iiij=U.ad)(i,u,c,m),wa=r.dynCall_fiii=(i,u,c,m)=>(wa=r.dynCall_fiii=U.bd)(i,u,c,m),va=r.dynCall_viiiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>(va=r.dynCall_viiiiiiiiiiiii=U.cd)(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e),$a=r.dynCall_vjiii=(i,u,c,m,g)=>($a=r.dynCall_vjiii=U.dd)(i,u,c,m,g),xa=r.dynCall_vif=(i,u,c)=>(xa=r.dynCall_vif=U.ed)(i,u,c),Sa=r.dynCall_iiiiiii=(i,u,c,m,g,x,I)=>(Sa=r.dynCall_iiiiiii=U.fd)(i,u,c,m,g,x,I),Ta=r.dynCall_iiiij=(i,u,c,m,g)=>(Ta=r.dynCall_iiiij=U.gd)(i,u,c,m,g),Ca=r.dynCall_iiiiiiii=(i,u,c,m,g,x,I,z)=>(Ca=r.dynCall_iiiiiiii=U.hd)(i,u,c,m,g,x,I,z),Ia=r.dynCall_viiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue)=>(Ia=r.dynCall_viiiiiiiiiiii=U.id)(i,u,c,m,g,x,I,z,B,L,q,X,ue),Aa=r.dynCall_diii=(i,u,c,m)=>(Aa=r.dynCall_diii=U.jd)(i,u,c,m),ka=r.dynCall_jiiii=(i,u,c,m,g)=>(ka=r.dynCall_jiiii=U.kd)(i,u,c,m,g),Ea=r.dynCall_viiij=(i,u,c,m,g)=>(Ea=r.dynCall_viiij=U.ld)(i,u,c,m,g),Pa=r.dynCall_fiiii=(i,u,c,m,g)=>(Pa=r.dynCall_fiiii=U.md)(i,u,c,m,g),za=r.dynCall_viiif=(i,u,c,m,g)=>(za=r.dynCall_viiif=U.nd)(i,u,c,m,g),Oa=r.dynCall_diiii=(i,u,c,m,g)=>(Oa=r.dynCall_diiii=U.od)(i,u,c,m,g),Da=r.dynCall_viiid=(i,u,c,m,g)=>(Da=r.dynCall_viiid=U.pd)(i,u,c,m,g),Ba=r.dynCall_iiiijii=(i,u,c,m,g,x,I)=>(Ba=r.dynCall_iiiijii=U.qd)(i,u,c,m,g,x,I),Ma=r.dynCall_iiiiiij=(i,u,c,m,g,x,I)=>(Ma=r.dynCall_iiiiiij=U.rd)(i,u,c,m,g,x,I),Ra=i=>(Ra=U.sd)(i),Ua=()=>(Ua=U.td)(),Na=i=>(Na=U.ud)(i),Va=()=>(Va=U.vd)();function Mm(i,u,c){var m=ie();try{Zi(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Rm(i,u,c){var m=ie();try{return Ki(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Um(i,u){var c=ie();try{ji(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Nm(i,u){var c=ie();try{return Rn(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Vm(i,u,c,m){var g=ie();try{return Qi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Wm(i,u,c,m,g){var x=ie();try{Ji(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Lm(i,u,c,m,g){var x=ie();try{return Xi(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Gm(i,u,c,m){var g=ie();try{Yi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Hm(i,u,c,m,g,x,I){var z=ie();try{return Sa(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Fm(i){var u=ie();try{na(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function qm(i,u,c){var m=ie();try{return fa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Km(i,u,c,m,g,x){var I=ie();try{oa(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function jm(i,u,c){var m=ie();try{ya(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Zm(i,u,c,m,g,x,I){var z=ie();try{ea(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Qm(i,u,c,m,g,x,I,z){var B=ie();try{ta(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Ym(i,u,c,m,g,x){var I=ie();try{return ma(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function Xm(i,u,c,m,g,x,I,z){var B=ie();try{return Ca(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Jm(i,u,c,m,g,x,I,z,B,L){var q=ie();try{ca(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function ef(i,u,c,m,g,x,I,z,B){var L=ie();try{sa(i,u,c,m,g,x,I,z,B)}catch(q){if(oe(L),q!==q+0)throw q;se(1,0)}}function tf(i){var u=ie();try{return ia(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function rf(i,u,c,m,g,x,I,z,B,L){var q=ie();try{return ha(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function nf(i,u,c){var m=ie();try{return aa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function of(i,u,c,m){var g=ie();try{return da(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;return se(1,0),0n}}function af(i,u,c){var m=ie();try{return la(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function sf(i,u,c,m,g,x,I,z,B,L,q,X){var ue=ie();try{pa(i,u,c,m,g,x,I,z,B,L,q,X)}catch($e){if(oe(ue),$e!==$e+0)throw $e;se(1,0)}}function uf(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{ua(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function df(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{return ga(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function lf(i,u,c,m){var g=ie();try{return ba(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function cf(i,u,c,m){var g=ie();try{return _a(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function pf(i,u,c,m){var g=ie();try{return wa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function mf(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e){var Le=ie();try{va(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)}catch(jt){if(oe(Le),jt!==jt+0)throw jt;se(1,0)}}function ff(i,u,c,m,g){var x=ie();try{$a(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function hf(i,u,c){var m=ie();try{xa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function gf(i,u){var c=ie();try{return ra(i,u)}catch(m){if(oe(c),m!==m+0)throw m;return se(1,0),0n}}function yf(i,u,c,m,g){var x=ie();try{return Ta(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function bf(i,u,c,m,g,x,I,z,B,L,q,X,ue){var $e=ie();try{Ia(i,u,c,m,g,x,I,z,B,L,q,X,ue)}catch(Le){if(oe($e),Le!==Le+0)throw Le;se(1,0)}}function _f(i,u,c,m){var g=ie();try{return Aa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function wf(i,u,c,m,g){var x=ie();try{return ka(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;return se(1,0),0n}}function vf(i,u,c,m,g){var x=ie();try{Ea(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function $f(i,u,c,m,g){var x=ie();try{return Pa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function xf(i,u,c,m,g){var x=ie();try{za(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Sf(i,u,c,m,g){var x=ie();try{return Oa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Tf(i,u,c,m,g){var x=ie();try{Da(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Cf(i,u,c,m,g,x,I){var z=ie();try{return Ba(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function If(i,u,c,m,g,x,I){var z=ie();try{return Ma(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}return r.stackSave=()=>ie(),r.stackRestore=i=>oe(i),r.stackAlloc=i=>Mn(i),r.setValue=function(i,u,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":Z()[i>>>0]=u;break;case\"i16\":ke()[i>>>1>>>0]=u;break;case\"i32\":D()[i>>>2>>>0]=u;break;case\"i64\":W[i>>>3]=BigInt(u);break;case\"float\":Y()[i>>>2>>>0]=u;break;case\"double\":fe()[i>>>3>>>0]=u;break;case\"*\":R()[i>>>2>>>0]=u;break;default:ut(`invalid type for setValue: ${c}`)}},r.getValue=function(i,u=\"i8\"){switch(u.endsWith(\"*\")&&(u=\"*\"),u){case\"i1\":case\"i8\":return Z()[i>>>0];case\"i16\":return ke()[i>>>1>>>0];case\"i32\":return D()[i>>>2>>>0];case\"i64\":return W[i>>>3];case\"float\":return Y()[i>>>2>>>0];case\"double\":return fe()[i>>>3>>>0];case\"*\":return R()[i>>>2>>>0];default:ut(`invalid type for getValue: ${u}`)}},r.UTF8ToString=Ae,r.stringToUTF8=Bt,r.lengthBytesUTF8=Yo,function i(){if(0<xt)Ht=i;else if(d)t(r),Ye();else{for(;0<yn.length;)yn.shift()(r);0<xt?Ht=i:(r.calledRun=!0,ee||(Ye(),t(r)))}}(),r.PTR_SIZE=4,o}),Bf=ws,Mf=globalThis.self?.name?.startsWith(\"em-pthread\");Mf&&ws()});var Ts,Rf,Ve,Cs,jn,Uf,Nf,Is,Vf,xs,As,Ss,ks,Sr=G(()=>{\"use strict\";xr();Ts=typeof location>\"u\"?void 0:location.origin,Rf=()=>{if(true)return \"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d91e\")).href,Ts).href:\"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\"},Ve=Rf(),Cs=()=>{if(Ve&&!Ve.startsWith(\"blob:\"))return Ve.substring(0,Ve.lastIndexOf(\"/\")+1)},jn=(e,t)=>{try{let n=t??Ve;return(n?new URL(e,n):new URL(e)).origin===Ts}catch{return!1}},Uf=(e,t)=>{let n=t??Ve;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Nf=(e,t)=>`${t??\"./\"}${e}`,Is=async e=>{let n=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(n)},Vf=async e=>(await import(/*webpackIgnore:true*/e)).default,xs=(_s(),br(bs)).default,As=async()=>{if(!Ve)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(jn(Ve))return[void 0,xs()];let e=await Is(Ve);return[e,xs(e)]},Ss=($s(),br(vs)).default,ks=async(e,t,n)=>{if(!e&&!t&&Ss&&Ve&&jn(Ve))return[void 0,Ss];{let r=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Uf(r,t),a= true&&n&&o&&!jn(o,t),s=a?await Is(o):o??Nf(r,t);return[a?s:void 0,await Vf(s)]}}});var Zn,Qn,Or,Es,Wf,Lf,Tr,Ie,bt=G(()=>{\"use strict\";Sr();Qn=!1,Or=!1,Es=!1,Wf=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lf=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Tr=async e=>{if(Qn)return Promise.resolve();if(Or)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Es)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Or=!0;let t=e.initTimeout,n=e.numThreads;if(!Lf())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let r=Wf();n>1&&!r&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+n+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=n=1);let o=e.wasmPaths,a=typeof o==\"string\"?o:void 0,s=o?.mjs,d=s?.href??s,l=o?.wasm,p=l?.href??l,f=e.wasmBinary,[h,y]=await ks(d,a,n>1),_=!1,b=[];if(t>0&&b.push(new Promise(w=>{setTimeout(()=>{_=!0,w()},t)})),b.push(new Promise((w,S)=>{let $={numThreads:n};if(f)$.wasmBinary=f;else if(p||a)$.locateFile=v=>p??a+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(h){let v=Cs();v&&($.locateFile=T=>v+T)}y($).then(v=>{Or=!1,Qn=!0,Zn=v,w(),h&&URL.revokeObjectURL(h)},v=>{Or=!1,Es=!0,S(v)})})),await Promise.race(b),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ie=()=>{if(Qn&&Zn)return Zn;throw new Error(\"WebAssembly is not initialized yet.\")}});var Pe,Xt,he,Dr=G(()=>{\"use strict\";bt();Pe=(e,t)=>{let n=Ie(),r=n.lengthBytesUTF8(e)+1,o=n._malloc(r);return n.stringToUTF8(e,o,r),t.push(o),o},Xt=(e,t,n,r)=>{if(typeof e==\"object\"&&e!==null){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach(([o,a])=>{let s=t?t+o:o;if(typeof a==\"object\")Xt(a,s+\".\",n,r);else if(typeof a==\"string\"||typeof a==\"number\")r(s,a.toString());else if(typeof a==\"boolean\")r(s,a?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},he=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetLastError(o,o+r);let a=Number(t.getValue(o,r===4?\"i32\":\"i64\")),s=t.getValue(o+r,\"*\"),d=s?t.UTF8ToString(s):\"\";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(n)}}});var Ps,zs=G(()=>{\"use strict\";bt();Dr();Ps=e=>{let t=Ie(),n=0,r=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let a=0;return e?.tag!==void 0&&(a=Pe(e.tag,r)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),n===0&&he(\"Can't create run options.\"),e?.extra!==void 0&&Xt(e.extra,\"\",new WeakSet,(s,d)=>{let l=Pe(s,r),p=Pe(d,r);t._OrtAddRunConfigEntry(n,l,p)!==0&&he(`Can't set a run config entry: ${s} - ${d}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),r.forEach(s=>t._free(s)),a}}});var Gf,Hf,Ff,qf,Os,Ds=G(()=>{\"use strict\";bt();Dr();Gf=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Hf=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ff=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(n=>(typeof n==\"string\"?n:n.name)===\"webgpu\")&&(e.enableMemPattern=!1)},qf=(e,t,n)=>{for(let r of t){let o=typeof r==\"string\"?r:r.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof r!=\"string\"){let d=r?.deviceType;if(d){let l=Pe(\"deviceType\",n),p=Pe(d,n);Ie()._OrtAddSessionConfigEntry(e,l,p)!==0&&he(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof r!=\"string\"){let s=r;if(s?.preferredLayout){if(s.preferredLayout!==\"NCHW\"&&s.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let d=Pe(\"preferredLayout\",n),l=Pe(s.preferredLayout,n);Ie()._OrtAddSessionConfigEntry(e,d,l)!==0&&he(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let a=Pe(o,n);Ie()._OrtAppendExecutionProvider(e,a)!==0&&he(`Can't append execution provider: ${o}.`)}},Os=e=>{let t=Ie(),n=0,r=[],o=e||{};Ff(o);try{let a=Gf(o.graphOptimizationLevel??\"all\"),s=Hf(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?Pe(o.logId,r):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let f=typeof o.optimizedModelFilePath==\"string\"?Pe(o.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(a,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,d,l,p,f),n===0&&he(\"Can't create session options.\"),o.executionProviders&&qf(n,o.executionProviders,r),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let h=Pe(\"enableGraphCapture\",r),y=Pe(o.enableGraphCapture.toString(),r);t._OrtAddSessionConfigEntry(n,h,y)!==0&&he(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[h,y]of Object.entries(o.freeDimensionOverrides)){if(typeof h!=\"string\")throw new Error(`free dimension override name must be a string: ${h}`);if(typeof y!=\"number\"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let _=Pe(h,r);t._OrtAddFreeDimensionOverride(n,_,y)!==0&&he(`Can't set a free dimension override: ${h} - ${y}.`)}return o.extra!==void 0&&Xt(o.extra,\"\",new WeakSet,(h,y)=>{let _=Pe(h,r),b=Pe(y,r);t._OrtAddSessionConfigEntry(n,_,b)!==0&&he(`Can't set a session config entry: ${h} - ${y}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&he(\"Can't release session options.\"),r.forEach(s=>t._free(s)),a}}});var Rt,_t,wt,Br,Jt,Mr,Rr,Yn,te=G(()=>{\"use strict\";Rt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},_t=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},wt=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r=typeof t==\"number\"?t:t.reduce((o,a)=>o*a,1);return n>0?Math.ceil(r*n):void 0},Br=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Jt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Mr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Rr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Yn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var er,Xn=G(()=>{\"use strict\";xr();er=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get(\"Content-Length\"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),a;try{a=new ArrayBuffer(r)}catch(d){if(d instanceof RangeError){let l=Math.ceil(r/65536);a=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let s=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(a,s,p).set(l),s+=p}return new Uint8Array(a,0,r)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Kf,jf,Bs,Ms,Ur,Zf,me,tt=G(()=>{\"use strict\";te();Kf=[\"V\",\"I\",\"W\",\"E\",\"F\"],jf=(e,t)=>{console.log(`[${Kf[e]},${new Date().toISOString()}]${t}`)},Ur=(e,t)=>{Bs=e,Ms=t},Zf=(e,t)=>{let n=Jt(e),r=Jt(Bs);n>=r&&jf(n,typeof t==\"function\"?t():t)},me=(...e)=>{Ms&&Zf(...e)}});var Nr,Jn=G(()=>{\"use strict\";te();Nr=(e,t)=>new(Br(t))(e)});var Vr=G(()=>{\"use strict\"});var Rs,eo,to,Qf,Yf,Us,no,ro,Vs,Ws=G(()=>{\"use strict\";tt();Vr();Rs=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),eo=[],to=e=>Math.ceil(Number(e)/16)*16,Qf=e=>{for(let t=0;t<eo.length;t++){let n=eo[t];if(e<=n)return n}return Math.ceil(e/16)*16},Yf=1,Us=()=>Yf++,no=async(e,t,n,r)=>{let o=to(n),a=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,a,0,o),e.flush(),await a.mapAsync(GPUMapMode.READ);let d=a.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(d,0,n)),l}else return new Uint8Array(d.slice(0,n))}finally{a.destroy()}},ro=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[n]of Rs)eo.push(n),this.freeBuffers.set(n,[]),this.freeUniformBuffers.set(n,[]);this.sessionCount=0}upload(t,n){let r=n.buffer,o=n.byteOffset,a=n.byteLength,s=to(a),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==a)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${a}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(r,o,a)),l.unmap();let f=this.backend.device.createCommandEncoder();f.copyBufferToBuffer(l,0,d.gpuData.buffer,0,s),this.backend.device.queue.submit([f.finish()]),l.destroy(),me(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,n){let r=this.storageCache.get(t);if(!r)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(n);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(r.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let a=to(r.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(r.gpuData.buffer,0,o.gpuData.buffer,0,a)}registerExternalBuffer(t,n,r){let o;if(r){if(o=r[0],t===r[1])return me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Us();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:n}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),me(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r=Qf(t),o,a=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||s){let p=(a?this.freeBuffers:this.freeUniformBuffers).get(r);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:r,usage:n}):o=this.backend.device.createBuffer({size:r,usage:n})}else o=this.backend.device.createBuffer({size:r,usage:n});let d={id:Us(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let n=typeof t==\"bigint\"?Number(t):t,r=this.storageCache.get(n);if(!r){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return me(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${n}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(n),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,n){let r=this.storageCache.get(Number(t));if(!r)throw new Error(\"data does not exist\");await no(this.backend,r.gpuData.buffer,r.originalSize,n)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let n=Rs.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let n of this.buffersPending)t.push(n);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let n=this.capturedPendingBuffers.get(t);n&&(n.forEach(r=>{r.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(me(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Vs=(...e)=>new ro(...e)});var oo,re,Ce=G(()=>{\"use strict\";oo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},re=e=>new oo(e)});var io,rt,E,kt,Wr,Ls,Gs,ae=G(()=>{\"use strict\";io=class{static calcMatMulShape(t,n){return t[1]!==n[0]?void 0:[t[0],n[1]]}},rt=class{static calcShape(t,n,r=!1){let o=t.length,a=n.length;if(o===0)return n;if(a===0)return t;let s=Math.max(t.length,n.length),d=new Array(s);if(r){if(o<2||a<2)return;let l=io.calcMatMulShape([t[o-2],t[o-1]],[n[a-2],n[a-1]]);if(l===void 0)return;[d[s-2],d[s-1]]=l}for(let l=r?3:1;l<=s;l++){let p=o-l<0?1:t[o-l],f=a-l<0?1:n[a-l];if(p!==f&&p>1&&f>1)return;let h=Math.max(p,f);if(p&&f)d[s-l]=Math.max(p,f);else{if(h>1)return;d[s-l]=0}}return d}static isValidBroadcast(t,n){let r=t.length,o=n.length;if(r>o)return!1;for(let a=1;a<=r;a++)if(t[r-a]!==1&&t[r-a]!==n[o-a])return!1;return!0}},E=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let r=t.length;if(r===0)return[];let o=new Array(r),a=r-1;for(;a>=0;){if(t[a]%n===0){o[a]=t[a]/n;break}if(n%t[a]!==0)throw new Error(\"cannot convert shape\");o[a]=1,n/=t[a],a--}for(a--;a>=0;a--)o[a]=t[a];return o}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,r){let o=1;for(let a=n;a<r;a++){if(t[a]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[a])}return o}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=t[n-1];for(let o=n-3;o>=0;--o)r[o]=r[o+1]*t[o+1];return r}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error(\"unsupported axis for this operation.\");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(r=>this.normalizeAxis(r,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(r=>t[r]):t.slice().reverse()}static padShape(t,n){let r=t.length;return t.map((o,a)=>o+n[a]+n[a+r])}static areEqual(t,n){return t.length!==n.length?!1:t.every((r,o)=>r===n[o])}},kt=class e{static adjustPoolAttributes(t,n,r,o,a,s){if(!t&&r.length!==n.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<n.length-2;d++)d>=r.length?r.push(n[d+2]):r[d]=n[d+2];for(let d=0;d<r.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<r.length;d++)if(d<a.length){if(a[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else a.push(1);for(let d=0;d<r.length*2;d++)if(d<s.length){if(s[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else s.push(0);for(let d=0;d<r.length;d++){if(r[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(s[d]>=r[d]||s[d+r.length]>=r[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,n,r,o,a,s,d){if(d){if(a.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(n.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(s?1:2)],n[l],r[l],o[l],a,l,l+t.length-2,d)}}static computePoolOutputShape(t,n,r,o,a,s,d){if(n.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,o,a,s,d),l}static computeConvOutputShape(t,n,r,o,a,s,d){if(t.length<=0||n.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,o,a,s,d),l}static computeShapeHelper(t,n,r,o,a,s,d,l){if(t)for(let p=0;p<n.length-2;p++)r.push(1);else for(let p=0;p<n.length-2;p++)r.push(e.adjustPadAndReturnShape(n[p+2],o[p],a[p],s[p],d,p,p+n.length-2,l))}static adjustPadAndReturnShape(t,n,r,o,a,s,d,l){let p=r*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return a[s]=0,a[d]=0,Math.floor((t-p)/n+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(r!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let h=((t+n-1)/n-1)*n+o-t;return a[s]=Math.floor(l===\"SAME_LOWER\"?(h+1)/2:h/2),a[d]=h-a[s],Math.floor((t+h-o)/n+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+a[s]+a[d]-p)/n+1)}},Wr=class{static getShapeOfGemmResult(t,n,r,o,a){if(t.length!==2||r.length!==2)throw new Error(\"shape need to be of size 2\");let s,d,l;n?(s=t[1],d=t[0]):(s=t[0],d=t[1]);let p=-1;if(o?(l=r[0],p=1):(l=r[1],p=0),r[p]!==d)throw new Error(\"dimension mismatch\");if(s<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(a&&!rt.isValidBroadcast(a,[s,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[s,l,d]}},Ls=-34028234663852886e22,Gs=34028234663852886e22});var Et,so,_e,ze,H,ge,uo,Pt,Ke,K,Lr,P,N,Hs,Gr,ao,Fs,ce=G(()=>{\"use strict\";te();ae();Et=64,so=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},_e=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[0]},ze=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[1]},H=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:E.computeStrides(n)})}),t},ge=e=>e%4===0?4:e%2===0?2:1,uo=(e=\"f32\",t,n=\"0\")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,Pt=(e,t,n)=>e===\"f32\"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,Ke=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,K=(e,t,n,r)=>e.startsWith(\"uniforms.\")&&n>4?typeof t==\"string\"?r===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:r===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Lr=(e,t,n,r,o)=>{let a=typeof n==\"number\",s=a?n:n.length,d=[...new Array(s).keys()],l=s<2?\"u32\":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,p=so(t,o),f=typeof p==\"string\"?p:p[1],h=typeof p==\"string\"?p:p[0],y={indices:l,value:f,storage:h,tensor:t},_=R=>typeof R==\"string\"?R:`${R}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=a?\"uniforms.\":\"\",S=`${w}${e}_shape`,$=`${w}${e}_strides`,v=\"\";for(let R=0;R<s-1;R++)v+=`\n    let dim${R} = current / ${K($,R,s)};\n    let rest${R} = current % ${K($,R,s)};\n    indices[${R}] = dim${R};\n    current = rest${R};\n    `;v+=`indices[${s-1}] = current;`;let T=s<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${y.indices} {\n    var indices: ${y.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,C=R=>(b.offsetToIndices=!0,s<2?R:`o2i_${e}(${R})`),A=[];if(s>=2)for(let R=s-1;R>=0;R--)A.push(`${K($,R,s)} * (indices[${R}])`);let k=s<2?\"\":`\n  fn i2o_${e}(indices: ${y.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,O=R=>(b.indicesToOffset=!0,s<2?R:`i2o_${e}(${R})`),M=(...R)=>s===0?\"0u\":`${y.indices}(${R.map(_).join(\",\")})`,V=(R,Y)=>s<2?`${R}`:`${K(R,Y,s)}`,F=(R,Y,fe)=>s<2?`${R}=${fe};`:`${K(R,Y,s)}=${fe};`,j={},ne=(R,Y)=>{b.broadcastedIndicesToOffset=!0;let fe=`${Y.name}broadcastedIndicesTo${e}Offset`;if(fe in j)return`${fe}(${R})`;let Fe=[];for(let xe=s-1;xe>=0;xe--){let be=Y.indicesGet(\"outputIndices\",xe+Y.rank-s);Fe.push(`${V($,xe)} * (${be} % ${V(S,xe)})`)}return j[fe]=`fn ${fe}(outputIndices: ${Y.type.indices}) -> u32 {\n             return ${Fe.length>0?Fe.join(\"+\"):\"0u\"};\n           }`,`${fe}(${R})`},W=(R,Y)=>(()=>{if(y.storage===y.value)return`${e}[${R}]=${Y};`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), 0u);`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`${e}[${R}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),J=R=>(()=>{if(y.storage===y.value)return`${e}[${R}]`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`i32(${e}[${R}].x)`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`u32(${e}[${R}].x)`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${R}] & 0xFFu), bool(${e}[${R}] & 0xFF00u), bool(${e}[${R}] & 0xFF0000u), bool(${e}[${R}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ve=s<2?\"\":`\n  fn get_${e}ByIndices(indices: ${y.indices}) -> ${f} {\n    return ${J(`i2o_${e}(indices)`)};\n  }`,Q=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn get_${e}(${R}) -> ${f} {\n    return get_${e}ByIndices(${M(Y)});\n  }`})(),ee=(...R)=>{if(R.length!==s)throw new Error(`indices length must be ${s}`);let Y=R.map(_).join(\",\");return s===0?J(\"0u\"):s===1?J(Y[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${Y})`)},le=R=>s<2?J(R):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${R})`),Z=s<2?\"\":`\n  fn set_${e}ByIndices(indices: ${y.indices}, value: ${f}) {\n    ${W(`i2o_${e}(indices)`,\"value\")}\n  }`,pe=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn set_${e}(${R}, value: ${f}) {\n    set_${e}ByIndices(${M(Y)}, value);\n  }`})();return{impl:()=>{let R=[],Y=!1;return b.offsetToIndices&&(R.push(T),Y=!0),b.indicesToOffset&&(R.push(k),Y=!0),b.broadcastedIndicesToOffset&&(Object.values(j).forEach(fe=>R.push(fe)),Y=!0),b.set&&(R.push(pe),Y=!0),b.setByIndices&&(R.push(Z),Y=!0),b.get&&(R.push(Q),Y=!0),b.getByIndices&&(R.push(ve),Y=!0),!a&&Y&&R.unshift(`const ${S} = ${y.indices}(${n.join(\",\")});`,`const ${$} = ${y.indices}(${E.computeStrides(n).join(\",\")});`),R.join(`\n`)},type:y,offsetToIndices:C,indicesToOffset:O,broadcastedIndicesToOffset:ne,indices:M,indicesGet:V,indicesSet:F,set:(...R)=>{if(R.length!==s+1)throw new Error(`indices length must be ${s}`);let Y=R[s];if(typeof Y!=\"string\")throw new Error(\"value must be string\");let fe=R.slice(0,s).map(_).join(\",\");return s===0?W(\"0u\",Y):s===1?W(fe[0],Y):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${fe}, ${Y})`)},setByOffset:W,setByIndices:(R,Y)=>s<2?W(R,Y):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${R}, ${Y});`),get:ee,getByOffset:J,getByIndices:le,usage:r,name:e,strides:$,shape:S,rank:s}},P=(e,t,n,r=1)=>Lr(e,t,n,\"input\",r),N=(e,t,n,r=1)=>Lr(e,t,n,\"output\",r),Hs=(e,t,n)=>Lr(e,t,n,\"atomicOutput\",1),Gr=(e,t,n,r=1)=>Lr(e,t,n,\"internal\",r),ao=class{constructor(t,n){this.normalizedDispatchGroup=t;this.limits=n;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Et){let n=typeof t==\"number\"?t:t[0],r=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(n>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(n*r*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=a?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=a?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${n*r*o}u + local_idx;`;return`@compute @workgroup_size(${n}, ${r}, ${o})\n  fn main(${s}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,n){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let r=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${n}) var<storage, ${r}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(n=>this.declareVariable(n,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(n=>this.registerInternalVariable(n)),this}registerUniform(t,n,r=1){return this.uniforms.push({name:t,type:n,length:r}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:n,type:r,length:o}of this.uniforms)if(o&&o>4)r===\"f16\"?t.push(`@align(16) ${n}:array<mat2x4<${r}>, ${Math.ceil(o/8)}>`):t.push(`${n}:array<vec4<${r}>, ${Math.ceil(o/4)}>`);else{let a=o==null||o===1?r:`vec${o}<${r}>`;t.push(`${n}:${a}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=n=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(n)];return this.uniforms.map(n=>[t(n.type),n.length??1])}},Fs=(e,t)=>new ao(e,t)});var Xf,qs,Jf,eh,th,rh,Oe,Ks,js,ct=G(()=>{\"use strict\";te();ae();Ce();ce();Xf=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},qs=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),Jf=(e,t)=>E.sortBasedOnPerm(e,qs(e.length,t)),eh=(e,t,n,r)=>{let o=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let a=0;a<t;++a)o+=`a[${e[a]}]=i[${a}];`;return o+=\"return a;}\"},th=(e,t)=>{let n=[],r=[];for(let o=0;o<e.length;++o)e[o]!==1&&n.push(e[o]),e[t[o]]!==1&&r.push(t[o]);return{newShape:n,newPerm:r}},rh=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(t[e[r]]!==1){if(e[r]<n)return!1;n=e[r]}return!0},Oe=(e,t)=>{let n=e.dataType,r=e.dims.length,o=qs(r,t),a=Jf(e.dims,o),s=e.dims,d=a,l=r<2||rh(o,e.dims),p;if(l)return p=w=>{let S=P(\"input\",n,s,4),$=N(\"output\",n,d,4);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64/4)},programUniforms:[{type:12,data:Math.ceil(w/4)}]}},getShaderSource:p};let{newShape:f,newPerm:h}=th(e.dims,o),y=E.areEqual(h,[2,3,1]),_=E.areEqual(h,[3,1,2]);if(f.length===2||y||_){s=y?[f[0],f[1]*f[2]]:_?[f[0]*f[1],f[2]]:f,d=[s[1],s[0]];let w=16;return p=S=>{let $=P(\"a\",n,s.length),v=N(\"output\",n,d.length);return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${w+1}>, ${w}>;\n  ${S.mainStart([w,w,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${w} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${w}u + local_id.x;\n    let input_row = workgroup_id_x * ${w}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${w}u + local_id.x;\n    let output_row = workgroup_id_y * ${w}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let S=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/w),y:Math.ceil(d[0]/w)},programUniforms:[{type:12,data:S},...H(s,d)]}},getShaderSource:p}}return p=w=>{let S=P(\"a\",n,s.length),$=N(\"output\",n,d.length);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n\n  ${eh(o,r,S,$)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",S.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},...H(s,d)]}},getShaderSource:p}},Ks=(e,t)=>{Xf(e.inputs,t.perm),e.compute(Oe(e.inputs[0],t.perm))},js=e=>re({perm:e.perm})});var nh,oh,ih,ah,sh,uh,dh,lh,ch,ph,nt,Zs,Qs,Ys,Xs,Js,eu,tu,ru,nu,ou,iu=G(()=>{\"use strict\";te();ae();ce();Hr();ct();nh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},oh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},ih={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},ah={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},sh=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},uh=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let o=t.map(a=>e[a]);return[n,o]},dh=(e,t)=>{let n=e.length+t.length,r=[],o=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?r.push(e[o++]):r.push(1);return r},lh=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},ch=(e,t)=>{let n=[];if(!lh(e,t)){for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);e.forEach(r=>n.push(r))}return n},ph=(e,t,n,r,o,a,s)=>{let d=n[0].dims,l=E.size(a),p=E.size(s),f=P(\"_A\",n[0].dataType,d),h=N(\"output\",o,a),y=64;l===1&&(y=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${y}>;\n       `,b=w=>`\n        ${w.registerUniform(\"reduceSize\",\"u32\").declareVariables(f,h)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${w.mainStart(y)}\n\n          let outputIndex = global_idx / ${y};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${ih[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${y}) {\n           let candidate = f32(${f.getByOffset(\"offset + k\")});\n           bestValue = ${nh[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${y}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${oh[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${h.setByOffset(\"outputIndex\",`${r===\"mean\"?`${h.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${h.type.storage}(${ah[r]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${y}`,inputDependencies:[\"type\"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},nt=(e,t,n,r)=>{let o=e.inputs.length===1?n:lo(e.inputs,n),a=o.axes;a.length===0&&!o.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((_,b)=>b));let s=E.normalizeAxes(a,e.inputs[0].dims.length),d=s,l=e.inputs[0],p=ch(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Oe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=sh(d.length,l.dims.length));let[f,h]=uh(l.dims,d),y=f;o.keepDims&&(y=dh(f,s)),e.compute(ph(t,o.cacheKey,[l],r,e.inputs[0].dataType,y,h),{inputs:[l]})},Zs=(e,t)=>{nt(e,\"ReduceMeanShared\",t,\"mean\")},Qs=(e,t)=>{nt(e,\"ReduceL1Shared\",t,\"l1\")},Ys=(e,t)=>{nt(e,\"ReduceL2Shared\",t,\"l2\")},Xs=(e,t)=>{nt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},Js=(e,t)=>{nt(e,\"ReduceMaxShared\",t,\"max\")},eu=(e,t)=>{nt(e,\"ReduceMinShared\",t,\"min\")},tu=(e,t)=>{nt(e,\"ReduceProdShared\",t,\"prod\")},ru=(e,t)=>{nt(e,\"ReduceSumShared\",t,\"sum\")},nu=(e,t)=>{nt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},ou=(e,t)=>{nt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var ot,mh,Fr,lo,it,fh,hh,gh,yh,bh,_h,wh,vh,$h,xh,at,au,su,uu,du,lu,cu,pu,mu,fu,hu,Hr=G(()=>{\"use strict\";te();ae();Ce();ce();iu();ot=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},mh=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Fr=(e,t,n,r,o,a,s=!1,d=!1)=>{let l=[],p=n[0].dims,f=p.length,h=E.normalizeAxes(o,f),y=!d&&h.length===0;p.forEach((S,$)=>{y||h.indexOf($)>=0?s&&l.push(1):l.push(S)});let _=l.length,b=E.size(l);return{name:e,shaderCache:t,getShaderSource:S=>{let $=[],v=P(\"_A\",n[0].dataType,f),T=N(\"output\",a,_),C=r(v,T,h),A=C[2];for(let k=0,O=0;k<f;k++)y||h.indexOf(k)>=0?(s&&O++,A=`for(var j${k}: u32 = 0; j${k} < ${p[k]}; j${k}++) {\n                  ${C[2].includes(\"last_index\")?`let last_index = j${k};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",k,`j${k}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",k,T.indicesGet(\"output_indices\",O))};`),O++);return`\n\n        ${S.registerUniform(\"output_size\",\"u32\").declareVariables(v,T)}\n\n        ${S.mainStart()}\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${T.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${C[0]}       // init ops for reduce max/min\n          ${C[1]}\n          ${A}\n          ${C[3]}\n          ${C.length===4?T.setByOffset(\"global_idx\",\"value\"):C.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...H(p,l)]})}},lo=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),re({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},it=(e,t,n,r)=>{let o=e.inputs,a=o.length===1?n:lo(o,n);e.compute(Fr(t,{hint:a.cacheKey,inputDependencies:[\"rank\"]},[o[0]],a.noopWithEmptyAxes&&a.axes.length===0?mh:r,a.axes,o[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},fh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},hh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL1\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${r.getByIndices(\"input_indices\")});`,\"\"])},gh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL2\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},yh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSumExp\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${r.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},bh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMax\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(r.indicesSet(\"input_indices\",d,0));return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = max(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},_h=(e,t)=>{ot(e.inputs),it(e,\"ReduceMean\",t,(r,o,a)=>{let s=1;for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&(s*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${r.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${s});`]})},wh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMin\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = min(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},vh=(e,t)=>{ot(e.inputs),it(e,\"ReduceProd\",t,(r,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${r.getByIndices(\"input_indices\")};`,\"\"])},$h=(e,t)=>{ot(e.inputs),it(e,\"ReduceSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"\"])},xh=(e,t)=>{ot(e.inputs),it(e,\"ReduceSumSquare\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},at=(e,t,n)=>{if(t.length===0)return n;let r=1,o=1;for(let a=0;a<t.length;a++)t.indexOf(a)===-1?r*=e[a]:o*=e[a];return o<32&&r>1024},au=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_h(e,t):Zs(e,t)},su=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hh(e,t):Qs(e,t)},uu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gh(e,t):Ys(e,t)},du=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yh(e,t):Xs(e,t)},lu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bh(e,t):Js(e,t)},cu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wh(e,t):eu(e,t)},pu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vh(e,t):tu(e,t)},mu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$h(e,t):ru(e,t)},fu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xh(e,t):nu(e,t)},hu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fh(e,t):ou(e,t)}});var gu,yu,bu,co,_u=G(()=>{\"use strict\";te();Ce();Hr();gu=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},yu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},bu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},co=e=>re(e)});var Sh,po,Th,Ch,Ih,Ut,Ah,wu,qr=G(()=>{\"use strict\";te();ae();Vr();ce();Sh=(e,t)=>{let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],d=e[5];if(s&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(n.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=n.dims[0],p=n.dims[1],f=n.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(r.dims[0]!==f)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==r.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let h=o.dims[0]/3,y=h,_=y;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");h=t.qkvHiddenSizes[0],y=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let b=p;if(h!==y)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==h+y+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let w=0;if(s){if(y!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(s.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(s.dims[4]!==y/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(w=s.dims[3])}let S=b+w,$=-1,v=0;if(a)throw new Error(\"Mask not supported\");if(s)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==S)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:w,kvSequenceLength:b,totalSequenceLength:S,maxSequenceLength:$,inputHiddenSize:f,hiddenSize:h,vHiddenSize:_,headSize:Math.floor(h/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},po=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Th=(e,t,n,r,o,a,s,d)=>{let l=ge(s?1:a),p=64,f=a/l;f<p&&(p=32);let h=Math.ceil(a/l/p),y=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:o},{type:12,data:f},{type:12,data:h}],_=_e(e.dataType,l),b=ze(1,l),w=[\"type\"];s&&w.push(\"type\"),d&&w.push(\"type\");let S=$=>{let v=N(\"x\",e.dataType,e.dims,l),T=[v],C=s?P(\"seq_lens\",s.dataType,s.dims):void 0;C&&T.push(C);let A=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&T.push(A);let k=ze(e.dataType),O=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(O).declareVariables(...T)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${po(C,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${s?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${b}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${b}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${b}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${b}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${k}(1.0) / ${k}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${b}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${s?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${k}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:w},getShaderSource:S,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(a/p),y:o,z:t*n},programUniforms:y})}},Ch=(e,t,n,r,o,a,s,d,l)=>{let p=s+a.kvSequenceLength,f=[a.batchSize,a.numHeads,a.sequenceLength,p],h=e>1&&r,y=a.kvNumHeads?a.kvNumHeads:a.numHeads,_=h?[a.batchSize,y,p,a.headSize]:void 0,b=a.nReps?a.nReps:1,w=a.scale===0?1/Math.sqrt(a.headSize):a.scale,S=ge(a.headSize),$=a.headSize/S,v=12,T={x:Math.ceil(p/v),y:Math.ceil(a.sequenceLength/v),z:a.batchSize*a.numHeads},C=[{type:12,data:a.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:w},{type:12,data:s},{type:12,data:a.kvSequenceLength},{type:12,data:b}],A=h&&r&&E.size(r.dims)>0,k=[\"type\",\"type\"];A&&k.push(\"type\"),o&&k.push(\"type\"),d&&k.push(\"type\"),l&&k.push(\"type\");let O=[{dims:f,dataType:t.dataType,gpuDataType:0}];h&&O.push({dims:_,dataType:t.dataType,gpuDataType:0});let M=V=>{let F=P(\"q\",t.dataType,t.dims,S),j=P(\"key\",n.dataType,n.dims,S),ne=[F,j];if(A){let Z=P(\"past_key\",r.dataType,r.dims,S);ne.push(Z)}o&&ne.push(P(\"attention_bias\",o.dataType,o.dims));let W=d?P(\"seq_lens\",d.dataType,d.dims):void 0;W&&ne.push(W);let J=l?P(\"total_sequence_length_input\",l.dataType,l.dims):void 0;J&&ne.push(J);let ve=N(\"output\",t.dataType,f),Q=[ve];h&&Q.push(N(\"present_key\",t.dataType,_,S));let ee=ze(1,S),le=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${F.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${F.type.storage}, ${v*v}>;\n  ${V.registerUniforms(le).declareVariables(...ne,...Q)}\n  ${V.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${b===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${b===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${po(W,J,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&h?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${h?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${ee}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${A&&h?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`}\n      ${h?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(S){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${S}`)}})()};\n        output[outputIdx] = ${ve.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${S};${o!==void 0};${r!==void 0};${e}`,inputDependencies:k},getRunData:()=>({outputs:O,dispatchGroup:T,programUniforms:C}),getShaderSource:M}},Ih=(e,t,n,r,o,a,s=void 0,d=void 0)=>{let l=a+o.kvSequenceLength,p=o.nReps?o.nReps:1,f=o.vHiddenSize*p,h=e>1&&r,y=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=h?[o.batchSize,y,l,o.headSize]:void 0,b=[o.batchSize,o.sequenceLength,f],w=12,S={x:Math.ceil(o.vHeadSize/w),y:Math.ceil(o.sequenceLength/w),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:f},{type:12,data:a},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=h&&r&&E.size(r.dims)>0,T=[\"type\",\"type\"];v&&T.push(\"type\"),s&&T.push(\"type\"),d&&T.push(\"type\");let C=[{dims:b,dataType:t.dataType,gpuDataType:0}];h&&C.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=k=>{let O=P(\"probs\",t.dataType,t.dims),M=P(\"v\",n.dataType,n.dims),V=[O,M];v&&V.push(P(\"past_value\",r.dataType,r.dims));let F=s?P(\"seq_lens\",s.dataType,s.dims):void 0;s&&V.push(F);let j=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&V.push(j);let W=[N(\"output\",t.dataType,b)];h&&W.push(N(\"present_value\",t.dataType,_));let J=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${w}u;\n  var<workgroup> tileQ: array<${O.type.value}, ${w*w}>;\n  var<workgroup> tileV: array<${O.type.value}, ${w*w}>;\n  ${k.registerUniforms(J).declareVariables(...V,...W)}\n  ${k.mainStart([w,w,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${po(F,j,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&h?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${h?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${O.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${v&&h?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`}\n        ${h?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${r!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:C,dispatchGroup:S,programUniforms:$}),getShaderSource:A}},Ut=(e,t,n,r,o,a,s,d,l,p,f=void 0,h=void 0)=>{let y=Math.min(e.outputCount,1+(s?1:0)+(d?1:0)),_=y>1?p.pastSequenceLength:0,b=_+p.kvSequenceLength,w=l&&E.size(l.dims)>0?l:void 0,S=[t,n];y>1&&s&&E.size(s.dims)>0&&S.push(s),w&&S.push(w),f&&S.push(f),h&&S.push(h);let $=e.compute(Ch(y,t,n,s,w,p,_,f,h),{inputs:S,outputs:y>1?[-1,1]:[-1]})[0];e.compute(Th($,p.batchSize,p.numHeads,_,p.sequenceLength,b,f,h),{inputs:f&&h?[$,f,h]:[$],outputs:[]});let v=[$,r];y>1&&d&&E.size(d.dims)>0&&v.push(d),f&&v.push(f),h&&v.push(h),e.compute(Ih(y,$,r,d,p,_,f,h),{inputs:v,outputs:y>1?[0,2]:[0]})},Ah=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,o=t.inputHiddenSize,a=t.headSize,s=12,d={x:Math.ceil(t.headSize/s),y:Math.ceil(t.sequenceLength/s),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:r},{type:12,data:o},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],f=h=>{let y=N(\"output_q\",l[0].dataType,n),_=N(\"output_k\",l[0].dataType,n),b=N(\"output_v\",l[0].dataType,n),w=P(\"input\",l[0].dataType,l[0].dims),S=P(\"weight\",l[1].dataType,l[1].dims),$=P(\"bias\",l[2].dataType,l[2].dims),v=w.type.storage,T=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileInput: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightQ: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightK: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightV: array<${v}, ${s*s}>;\n  ${h.registerUniforms(T).declareVariables(w,S,$,y,_,b)}\n  ${h.mainStart([s,s,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:f},{inputs:l,outputs:[-1,-1,-1]})},wu=(e,t)=>{let n=Sh(e.inputs,t),[r,o,a]=Ah(e,n);return Ut(e,r,o,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}});var kh,Eh,Ph,vu,$u=G(()=>{\"use strict\";Ge();te();ae();Ce();ce();kh=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let n=(r,o,a)=>{let s=o.length;if(s!==r.length)throw new Error(`${a}: num dimensions != ${s}`);o.forEach((d,l)=>{if(d!==r[l])throw new Error(`${a}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let r=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,\"Invalid input scale\"),n(e[2].dims,r,\"Invalid input B\"),n(e[3].dims,r,\"Invalid input mean\"),n(e[4].dims,r,\"Invalid input var\")}else n(e[1].dims,[1],\"Invalid input scale\"),n(e[2].dims,[1],\"Invalid input B\"),n(e[3].dims,[1],\"Invalid input mean\"),n(e[4].dims,[1],\"Invalid input var\")},Eh=(e,t)=>{let{epsilon:n,spatial:r,format:o}=t,a=e[0].dims,s=r?ge(a[a.length-1]):1,d=o===\"NHWC\"&&a.length>1?s:1,l=E.size(a)/s,p=r,f=p?a.length:a,h=P(\"x\",e[0].dataType,e[0].dims,s),y=P(\"scale\",e[1].dataType,e[1].dims,d),_=P(\"bias\",e[2].dataType,e[2].dims,d),b=P(\"inputMean\",e[3].dataType,e[3].dims,d),w=P(\"inputVar\",e[4].dataType,e[4].dims,d),S=N(\"y\",e[0].dataType,f,s),$=()=>{let T=\"\";if(r)T=`let cOffset = ${a.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${a.length-1}] / ${s}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")T=`\n            ${S.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${S.indicesToOffset(\"outputIndices\")};`;else{T=`var cIndices = ${y.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let C=1;C<y.rank;C++)T+=`cIndices[${C}] = outputIndices[${C}];`;T+=`let cOffset = ${y.indicesToOffset(\"cIndices\")};`}return T},v=T=>`\n  const epsilon = ${n};\n  ${T.registerUniform(\"outputSize\",\"u32\").declareVariables(h,y,_,b,w,S)}\n  ${T.mainStart()}\n  ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${S.offsetToIndices(`global_idx * ${s}`)};\n    ${$()}\n    let scale = ${y.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${b.getByOffset(\"cOffset\")};\n    let inputVar = ${w.getByOffset(\"cOffset\")};\n    let x = ${h.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${S.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${s}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...H(a)]:[{type:12,data:l}]})}},Ph=e=>re(e),vu=(e,t)=>{let{inputs:n,outputCount:r}=e,o=Ph({...t,outputCount:r});if(we.webgpu.validateInputContent&&kh(n,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Eh(n,o))}});var zh,Oh,xu,Su=G(()=>{\"use strict\";ae();ce();zh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Oh=e=>{let t=e[0].dims,n=e[0].dims[2],r=E.size(t)/4,o=e[0].dataType,a=P(\"input\",o,t,4),s=P(\"bias\",o,[n],4),d=P(\"residual\",o,t,4),l=N(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:f=>`\n  const channels = ${n}u / 4;\n  ${f.declareVariables(a,s,d,l)}\n\n  ${f.mainStart()}\n    ${f.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${a.getByOffset(\"global_idx\")}\n      + ${s.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},xu=e=>{zh(e.inputs),e.compute(Oh(e.inputs))}});var Dh,ye,Tu,Cu,Iu,Au,ku,Eu,Pu,zu,Ou,Bh,Du,Bu,Mu,Ru,tr,Uu,Kr,Nu,Vu,Wu,Lu,Gu,Hu,Fu,qu,Ku,ju,Zu,Qu,Yu,Xu,Ju,ed,td,rd,mo,fo,nd,od,id,Mh,Rh,ad,jr=G(()=>{\"use strict\";te();ae();Ce();ce();Dh=(e,t,n,r,o,a,s)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=P(\"inputData\",n,[d],4),f=N(\"outputData\",r,[d],4),h=[{name:\"vec_size\",type:\"u32\"}];return s&&h.push(...s),`\n      ${e.registerUniforms(h).declareVariables(p,f)}\n\n  ${a??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${f.setByOffset(\"global_idx\",l)}\n  }`},ye=(e,t,n,r,o,a=e.dataType,s,d)=>{let l=[{type:12,data:Math.ceil(E.size(e.dims)/4)}];return s&&l.push(...s),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Dh(p,E.size(e.dims),e.dataType,a,n,r,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(E.size(p[0].dims)/64/4)},programUniforms:l})}},Tu=e=>{e.compute(ye(e.inputs[0],\"Abs\",\"abs\"))},Cu=e=>{e.compute(ye(e.inputs[0],\"Acos\",\"acos\"))},Iu=e=>{e.compute(ye(e.inputs[0],\"Acosh\",\"acosh\"))},Au=e=>{e.compute(ye(e.inputs[0],\"Asin\",\"asin\"))},ku=e=>{e.compute(ye(e.inputs[0],\"Asinh\",\"asinh\"))},Eu=e=>{e.compute(ye(e.inputs[0],\"Atan\",\"atan\"))},Pu=e=>{e.compute(ye(e.inputs[0],\"Atanh\",\"atanh\"))},zu=e=>re(e),Ou=(e,t)=>{let n;switch(t.to){case 10:n=\"vec4<f16>\";break;case 1:n=\"vec4<f32>\";break;case 12:n=\"vec4<u32>\";break;case 6:n=\"vec4<i32>\";break;case 9:n=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(ye(e.inputs[0],\"Cast\",n,void 0,t.cacheKey,t.to))},Bh=e=>{let t,n,r=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return re({min:t,max:n})},Du=(e,t)=>{let n=t||Bh(e.inputs),r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:\"min\",type:r},{name:\"max\",type:r}]),{inputs:[0]})},Bu=e=>{e.compute(ye(e.inputs[0],\"Ceil\",\"ceil\"))},Mu=e=>{e.compute(ye(e.inputs[0],\"Cos\",\"cos\"))},Ru=e=>{e.compute(ye(e.inputs[0],\"Cosh\",\"cosh\"))},tr=e=>re(e),Uu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Elu\",r=>`elu_vf32(${r})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Kr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Nu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Erf\",n=>`erf_vf32(${n})`,Kr(t)))},Vu=e=>{e.compute(ye(e.inputs[0],\"Exp\",\"exp\"))},Wu=e=>{e.compute(ye(e.inputs[0],\"Floor\",\"floor\"))},Lu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Gelu\",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Kr(t)))},Gu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"LeakyRelu\",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Hu=e=>{e.compute(ye(e.inputs[0],\"Not\",t=>`!${t}`))},Fu=e=>{e.compute(ye(e.inputs[0],\"Neg\",t=>`-${t}`))},qu=e=>{e.compute(ye(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},Ku=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Relu\",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},ju=e=>{e.compute(ye(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},Zu=e=>re(e),Qu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"HardSigmoid\",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${r} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},Yu=e=>{e.compute(ye(e.inputs[0],\"Sin\",\"sin\"))},Xu=e=>{e.compute(ye(e.inputs[0],\"Sinh\",\"sinh\"))},Ju=e=>{e.compute(ye(e.inputs[0],\"Sqrt\",\"sqrt\"))},ed=e=>{e.compute(ye(e.inputs[0],\"Tan\",\"tan\"))},td=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,rd=e=>{e.compute(ye(e.inputs[0],\"Tanh\",td))},mo=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${td(\"v\")};\n}\n`,fo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,nd=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"FastGelu\",fo,mo(t),void 0,e.inputs[0].dataType))},od=(e,t)=>{let n=ze(e.inputs[0].dataType);return e.compute(ye(e.inputs[0],\"ThresholdedRelu\",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},id=e=>{e.compute(ye(e.inputs[0],\"Log\",\"log\"))},Mh=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Rh=e=>`quick_gelu_impl(${e})`,ad=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"QuickGelu\",Rh,Mh(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Uh,Nh,ud,dd=G(()=>{\"use strict\";ae();ce();jr();Uh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Nh=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=P(\"input\",e[0].dataType,e[0].dims,4),r=P(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=N(\"output\",e[0].dataType,t,4),a=E.size(t)/4,s=_e(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(n,r,o)}\n\n  ${Kr(s)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},ud=e=>{Uh(e.inputs),e.compute(Nh(e.inputs))}});var Vh,Wh,st,ld,cd,pd,md,fd,hd,gd,yd,bd,_d,wd=G(()=>{\"use strict\";te();ae();ce();Vh=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y,_;typeof d==\"string\"?y=_=(v,T)=>`${d}((${v}),(${T}))`:typeof d==\"function\"?y=_=d:(y=d.scalar,_=d.vector);let b=N(\"outputData\",f,r.length,4),w=P(\"aData\",l,t.length,4),S=P(\"bData\",p,n.length,4),$;if(o)if(a){let v=E.size(t)===1,T=E.size(n)===1,C=t.length>0&&t[t.length-1]%4===0,A=n.length>0&&n[n.length-1]%4===0;v||T?$=b.setByOffset(\"global_idx\",_(v?`${w.type.value}(${w.getByOffset(\"0\")}.x)`:w.getByOffset(\"global_idx\"),T?`${S.type.value}(${S.getByOffset(\"0\")}.x)`:S.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${b.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${w.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            let offsetB = ${S.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            ${b.setByOffset(\"global_idx\",_(s||C?w.getByOffset(\"offsetA / 4u\"):`${w.type.value}(${w.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,s||A?S.getByOffset(\"offsetB / 4u\"):`${S.type.value}(${S.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=b.setByOffset(\"global_idx\",_(w.getByOffset(\"global_idx\"),S.getByOffset(\"global_idx\")));else{if(!a)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(T,C,A=\"\")=>{let k=`aData[indexA${C}][componentA${C}]`,O=`bData[indexB${C}][componentB${C}]`;return`\n            let outputIndices${C} = ${b.offsetToIndices(`global_idx * 4u + ${C}u`)};\n            let offsetA${C} = ${w.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let offsetB${C} = ${S.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let indexA${C} = offsetA${C} / 4u;\n            let indexB${C} = offsetB${C} / 4u;\n            let componentA${C} = offsetA${C} % 4u;\n            let componentB${C} = offsetB${C} % 4u;\n            ${T}[${C}] = ${A}(${y(k,O)});\n          `};f===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(w,S,b)}\n\n        ${h??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Wh=(e,t,n,r,o,a,s=n.dataType)=>{let d=n.dims.map(w=>Number(w)??1),l=r.dims.map(w=>Number(w)??1),p=!E.areEqual(d,l),f=d,h=E.size(d),y=!1,_=!1,b=[p];if(p){let w=rt.calcShape(d,l,!1);if(!w)throw new Error(\"Can't perform binary op on the given tensors\");f=w.slice(),h=E.size(f);let S=E.size(d)===1,$=E.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;b.push(S),b.push($),b.push(v),b.push(T);let C=1;for(let A=1;A<f.length;A++){let k=d[d.length-A],O=l[l.length-A];if(k===O)C*=k;else break}C%4===0?(_=!0,y=!0):(S||$||v||T)&&(y=!0)}else y=!0;return b.push(y),{name:e,shaderCache:{hint:t+b.map(w=>w.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:w=>Vh(w,d,l,f,y,p,_,o,n.dataType,r.dataType,s,a),getRunData:()=>({outputs:[{dims:f,dataType:s}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(E.size(f)/4)},...H(d,l,f)]})}},st=(e,t,n,r,o,a)=>{e.compute(Wh(t,o??\"\",e.inputs[0],e.inputs[1],n,r,a))},ld=e=>{st(e,\"Add\",(t,n)=>`${t}+${n}`)},cd=e=>{st(e,\"Div\",(t,n)=>`${t}/${n}`)},pd=e=>{st(e,\"Equal\",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},md=e=>{st(e,\"Mul\",(t,n)=>`${t}*${n}`)},fd=e=>{let t=P(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;st(e,\"Pow\",{scalar:(r,o)=>`pow_custom(${r},${o})`,vector:(r,o)=>`pow_vector_custom(${r},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},hd=e=>{st(e,\"Sub\",(t,n)=>`${t}-${n}`)},gd=e=>{st(e,\"Greater\",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},yd=e=>{st(e,\"Less\",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},bd=e=>{st(e,\"GreaterOrEqual\",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},_d=e=>{st(e,\"LessOrEqual\",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}});var Gh,Hh,Fh,qh,vd,$d,xd=G(()=>{\"use strict\";te();ae();Ce();ce();Gh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let n=0,r=e[n],o=r.dataType,a=r.dims.length;e.forEach((s,d)=>{if(d!==n){if(s.dataType!==o)throw new Error(\"input tensors should be one type\");if(s.dims.length!==a)throw new Error(\"input tensors should have the same shape\");s.dims.forEach((l,p)=>{if(p!==t&&l!==r.dims[p])throw new Error(\"non concat dimensions must match\")})}})},Hh=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Fh=(e,t)=>{let n=e.length,r=[];for(let o=0;o<n;++o){let a=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));n===1?r.push(a):o===0?r.push(`if (inputIndex == ${o}u) { ${a} }`):o===n-1?r.push(`else { ${a} }`):r.push(`else if (inputIndex == ${o}) { ${a} }`)}return r.join(`\n`)},qh=(e,t,n,r)=>{let o=E.size(n),a=new Array(e.length),s=new Array(e.length),d=0,l=[],p=[],f=[{type:12,data:o}];for(let w=0;w<e.length;++w)d+=e[w].dims[t],a[w]=d,p.push(e[w].dims.length),s[w]=P(`input${w}`,r,p[w]),l.push(\"rank\"),f.push({type:12,data:a[w]});for(let w=0;w<e.length;++w)f.push(...H(e[w].dims));f.push(...H(n));let h=N(\"output\",r,n.length),y=h.indicesGet(\"indices\",t),_=Array.from(Array(a.length).keys()).map(w=>`uniforms.sizeInConcatAxis${w}`).join(\",\"),b=w=>`\n\n  ${(()=>{w.registerUniform(\"outputSize\",\"u32\");for(let S=0;S<e.length;S++)w.registerUniform(`sizeInConcatAxis${S}`,\"u32\");return w.declareVariables(...s,h)})()}\n\n  ${Hh(a.length,_)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${h.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${y});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${_});\n      ${y} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Fh(s,h)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:b}},vd=(e,t)=>{let n=e.inputs,r=n[0].dims,o=E.normalizeAxis(t.axis,r.length);Gh(n,o);let a=r.slice();a[o]=n.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let s=n.filter(d=>E.size(d.dims)>0);e.compute(qh(s,o,a,n[0].dataType),{inputs:s})},$d=e=>re({axis:e.axis})});var je,Ze,Qe,Zr,vt=G(()=>{\"use strict\";te();ae();je=(e,t,n=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ze=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Qe=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},Zr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}else if(t===\"Clip\"){let[n,r]=e?.activation_params||[Ls,Gs];return{activation:t,clipMax:r,clipMin:n}}else if(t===\"LeakyRelu\"){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}});var Ee,Sd,Qr=G(()=>{\"use strict\";Ee=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Sd=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Td,Cd=G(()=>{\"use strict\";Td=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var rr,Yr,Xr=G(()=>{\"use strict\";te();ae();ce();vt();rr=(e,t,n,r,o)=>{let a=r-n;return`\n      ${Array.from({length:n}).map((s,d)=>`\n      if (${K(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,K(o,d+a,r))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Yr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s[s.length-2],p=d[d.length-1],f=s[s.length-1],h=ge(p),y=ge(f),_=ge(l),b=E.size(n)/h/_,w=e.length>2,S=r?r.slice(0,-2):n.slice(0,-2),v=[E.size(S),l,p],T=[{type:12,data:b},{type:12,data:l},{type:12,data:p},{type:12,data:f}];Ze(t,T),T.push(...H(S,s,d)),w&&T.push(...H(e[2].dims)),T.push(...H(v));let C=A=>{let k=Gr(\"batch_dims\",e[0].dataType,S.length),O=P(\"a\",e[0].dataType,s.length,y),M=P(\"b\",e[1].dataType,d.length,h),V=N(\"output\",e[0].dataType,v.length,h),F=_e(V.type.tensor),j=je(t,V.type.value,F),ne=[O,M],W=\"\";if(w){let Q=o?h:1;ne.push(P(\"bias\",e[2].dataType,e[2].dims.length,Q)),W=`${o?`value += bias[col / ${Q}];`:`value += ${V.type.value}(bias[row + i]);`}`}let J=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Qe(t,J);let ve=()=>{let Q=`var a_data: ${O.type.value};`;for(let ee=0;ee<y;ee++)Q+=`\n              let b_data${ee} = b[(b_offset + (k + ${ee}) * uniforms.N + col) / ${h}];`;for(let ee=0;ee<_;ee++){Q+=`a_data = a[(a_offset + (row + ${ee}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)Q+=`\n            values[${ee}] = fma(${M.type.value}(a_data${y===1?\"\":`[${le}]`}), b_data${le}, values[${ee}]);\n`}return Q};return`\n  ${A.registerUniforms(J).registerInternalVariables(k).declareVariables(...ne,V)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${n.length===2?\"\":`let batch_indices = ${k.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${O.type.indices};\n    ${rr(\"a_indices\",O,O.rank-2,k.rank,\"batch_indices\")}\n    ${O.indicesSet(\"a_indices\",O.rank-2,0)}\n    ${O.indicesSet(\"a_indices\",O.rank-1,0)}\n    let a_offset = ${O.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${M.type.indices};\n    ${rr(\"b_indices\",M,M.rank-2,k.rank,\"batch_indices\")}\n    ${M.indicesSet(\"b_indices\",M.rank-2,0)}\n    ${M.indicesSet(\"b_indices\",M.rank-1,0)}\n    let b_offset = ${M.indicesToOffset(\"b_indices\")};\n    var values: array<${V.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${ve()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${W}\n      ${j}\n      let cur_indices = ${V.type.indices}(batch, row + i, col);\n      let offset = ${V.indicesToOffset(\"cur_indices\")};\n      ${V.setByOffset(`offset / ${h}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${h};${y};${_};${o}`,inputDependencies:w?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:T}),getShaderSource:C}}});var Kh,jh,ho,Id,Zh,go,Qh,nr,Jr=G(()=>{\"use strict\";te();ae();ce();vt();Xr();Qr();Kh=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,jh=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,ho=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],f=o?l:a,h=o?a:l,y=f/t[0],_=a/t[1];if(!((o&&y===4&&e[1]===4||!o&&(y===3||y===4))&&f%t[0]===0&&a%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${y} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${y} must be 3 or 4.\n  tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${y}<${n}>, ${f/y}>, ${h}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${p/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${y};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?\"0\":\"i32(globalId.z)\"};\n  ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Kh(o,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${y===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${jh(o,y)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Id=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,Zh=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",go=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32,l=!1)=>{let p=e[1]*t[1],f=e[0]*t[0],h=o?p:a,y=o?a:p;if(!(y%t[1]===0&&h%t[0]===0&&a%t[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let _=y/t[1],b=h/t[0],w=a/t[1],S=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${f};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          ${Id(o,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${b};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Id(o,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Zh(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${h}>, ${y}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${f}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?\"0\":\"i32(globalId.z)\"};\n    ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${S}\n  }\n`},Qh=(e,t,n,r,o=!1)=>{let[a,s,d,l]=r,p=_e(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${s.type.indices};\n        ${rr(\"aIndices\",s,s.rank-2,a.rank,\"batchIndices\")}\n        ${s.indicesSet(\"aIndices\",s.rank-2,\"u32(row)\")}\n        ${s.indicesSet(\"aIndices\",s.rank-1,\"u32(colIn)\")}\n        value = ${s.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${rr(\"bIndices\",d,d.rank-2,a.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ee(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ee(e,p)}(bias[row])`};`:\"\"}\n        ${n}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},nr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s.slice(0,-2),p=d.slice(0,-2),f=r?r.slice(0,-2):n.slice(0,-2),h=E.size(f),y=s[s.length-2],_=s[s.length-1],b=d[d.length-1],w=_%4===0&&b%4===0,S=y<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(b/$[0]/S[0]),Math.ceil(y/$[1]/S[1]),Math.ceil(h/$[2]/S[2])],T=w?4:1,C=[...l,y,_/T],A=C.length,k=[...p,_,b/T],O=k.length,M=[h,y,b/T],V=[{type:6,data:y},{type:6,data:b},{type:6,data:_}];Ze(t,V),V.push(...H(f,C,k));let F=[\"rank\",\"rank\"],j=e.length>2;j&&(V.push(...H(e[2].dims)),F.push(\"rank\")),V.push(...H(M));let ne=W=>{let J=f.length,ve=Gr(\"batchDims\",e[0].dataType,J,1),Q=_e(e[0].dataType),ee=P(\"a\",e[0].dataType,A,T),le=P(\"b\",e[1].dataType,O,T),Z=N(\"result\",e[0].dataType,M.length,T),pe=[ee,le];if(j){let Y=o?T:1;pe.push(P(\"bias\",e[2].dataType,e[2].dims.length,Y))}let ke=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Qe(t,ke);let Se=_e(Z.type.tensor),D=je(t,Z.type.value,Se),R=Qh(T,j,D,[ve,ee,le,Z],o);return`\n  ${W.registerUniforms(ke).registerInternalVariables(ve).declareVariables(...pe,Z)}\n  ${R}\n  ${w?ho(S,$,Q,ve):go(S,$,Q,ve)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${S};${t.activation};${w};${o}`,inputDependencies:F},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:V}),getShaderSource:ne}}});var Yh,Ad,kd=G(()=>{\"use strict\";te();tt();ce();vt();Qr();Cd();Jr();Yh=(e,t,n,r,o=!1,a,s=4,d=4,l=4,p=\"f32\")=>{let f=F=>{switch(F){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},h=F=>{switch(F){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},y=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,b=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",w=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",S=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${S} / outWidth;\n    let outCol = ${S} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ee(s,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${w}) {\n      ${y}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${f(s)}\n    }\n    return resData;`,T=e?t&&r?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`,C=e?r&&n?h(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`,A=Ee(l,p),k=e?Ee(s,p):Ee(d,p),O=e?Ee(d,p):Ee(s,p),M=je(a,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?T:C}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${O} {\n      ${e?C:T}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Sd(o)}\n      ${M}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ad=(e,t,n,r,o,a,s,d,l)=>{let p=t.format===\"NHWC\",f=p?e[0].dims[3]:e[0].dims[1],h=n[0],y=p?n[2]:n[3],_=p?n[1]:n[2],b=p?n[3]:n[1],w=p&&(f%4===0||f%3===0)&&b%4===0,S=p?b:y*_,$=p?y*_:b,v=[8,8,1],T=r<=8?[4,1,1]:[4,4,1],C=[Math.ceil(S/v[0]/T[0]),Math.ceil($/v[1]/T[1]),Math.ceil(h/v[2]/T[2])];me(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let A=w?p&&f%4!==0?3:4:1,k=v[1]*T[1],O=v[0]*T[0],M=Math.max(v[0]*A,v[1]),V=r%k===0,F=o%O===0,j=a%M===0,ne=w?[A,4,4]:[1,1,1],W=[{type:6,data:r},{type:6,data:o},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ze(t,W),W.push(...H(e[0].dims,e[1].dims));let J=[\"rank\",\"rank\"];s&&(W.push(...H(e[2].dims)),J.push(\"rank\")),W.push(...H(n));let ve=Q=>{let ee=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Qe(t,ee);let le=w?4:1,Z=_e(e[0].dataType),pe=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        result[flatIndex] = ${w?`vec4<${Z}>`:Z}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${w?\"/ 4\":\"\"}, value);\n      }`,ke=P(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),Se=P(\"w\",e[1].dataType,e[1].dims.length,le),D=[ke,Se],R=N(\"result\",e[0].dataType,n.length,le);if(s){let Y=P(\"bias\",e[2].dataType,e[2].dims.length,le);D.push(Y),pe+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${Z}>`:Z} {\n          return bias[coords.${p?\"w\":\"y\"}${w?\"/ 4\":\"\"}];\n        }`}return`\n        ${Td(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Q.registerUniforms(ee).declareVariables(...D,R)}\n        ${pe}\n        ${Yh(p,V,F,j,s,t,ne[0],ne[1],ne[2],Z)}\n        ${w?ho(T,v,Z,void 0,!p,M):go(T,v,Z,void 0,!p,M,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${w};${V};${F};${j};${k};${O};${M}`,inputDependencies:J},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:W}),getShaderSource:ve}}});var Xh,Ed,en,Jh,Pd,eg,zd,Od,Dd=G(()=>{\"use strict\";te();tt();ae();ce();vt();Qr();Xh=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Ed=e=>typeof e==\"number\"?[e,e,e]:e,en=(e,t)=>t<=1?e:e+(e-1)*(t-1),Jh=(e,t,n,r=1)=>{let o=en(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)},Pd=(e,t,n,r,o)=>{o==null&&(o=Jh(e,t[0],r[0]));let a=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*o>=t[s]&&(a[s]=Math.trunc((e[s]-t[s]+2*o)/r[s]+1));return a},eg=(e,t,n,r,o,a,s,d,l,p)=>{let f,h,y,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){f={top:e,bottom:e,left:e,right:e,front:e,back:e};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e);h=b[0],y=b[1],_=b[2]}else if(Array.isArray(e)){if(!e.every((w,S,$)=>w===$[0]))throw Error(`Unsupported padding parameter: ${e}`);f={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e[0]);h=b[0],y=b[1],_=b[2]}else if(e===\"SAME_UPPER\"){h=Math.ceil(t/o),y=Math.ceil(n/a),_=Math.ceil(r/s);let b=(h-1)*o+d-t,w=(y-1)*a+l-n,S=(_-1)*s+p-r,$=Math.floor(b/2),v=b-$,T=Math.floor(w/2),C=w-T,A=Math.floor(S/2),k=S-A;f={top:T,bottom:C,left:A,right:k,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:h,outHeight:y,outWidth:_}},zd=(e,t,n,r,o,a=!1,s=\"channelsLast\")=>{let d,l,p,f,h;if(s===\"channelsLast\")[d,l,p,f,h]=e;else if(s===\"channelsFirst\")[d,h,l,p,f]=e;else throw new Error(`Unknown dataFormat ${s}`);let[y,,_,b,w]=t,[S,$,v]=Ed(n),[T,C,A]=Ed(r),k=en(_,T),O=en(b,C),M=en(w,A),{padInfo:V,outDepth:F,outHeight:j,outWidth:ne}=eg(o,l,p,f,S,$,v,k,O,M),W=a?y*h:y,J=[0,0,0,0,0];return s===\"channelsFirst\"?J=[d,W,F,j,ne]:s===\"channelsLast\"&&(J=[d,F,j,ne,W]),{batchSize:d,dataFormat:s,inDepth:l,inHeight:p,inWidth:f,inChannels:h,outDepth:F,outHeight:j,outWidth:ne,outChannels:W,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:b,filterWidth:w,effectiveFilterDepth:k,effectiveFilterHeight:O,effectiveFilterWidth:M,dilationDepth:T,dilationHeight:C,dilationWidth:A,inShape:e,outShape:J,filterShape:t}},Od=(e,t,n,r,o,a)=>{let s=a===\"channelsLast\",d=s?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],f={x:n.map((v,T)=>T)},h=[Math.ceil(Xh(f.x.map(v=>n[v]))/p[0]),1,1];me(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${h}`);let y=l?s&&d%4!==0?3:4:1,_=E.size(n),b=[{type:12,data:_},{type:12,data:r},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];Ze(t,b),b.push(...H(e[0].dims,e[1].dims));let w=[\"rank\",\"rank\"],S=e.length===3;S&&(b.push(...H(e[2].dims)),w.push(\"rank\")),b.push(...H(n));let $=v=>{let T=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:r.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];Qe(t,T);let C=l?4:1,A=_e(e[0].dataType),k=P(\"x\",e[0].dataType,e[0].dims.length,y===3?1:y),O=P(\"W\",e[1].dataType,e[1].dims.length,C),M=[k,O],V=N(\"result\",e[0].dataType,n.length,C),F=\"\";if(S){let W=P(\"bias\",e[2].dataType,e[2].dims.length,C);M.push(W),F+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${s?K(\"coords\",4,5):K(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let j=Ee(y,A),ne=je(t,j,A);return`\n            ${F}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${k.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${O.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(T).declareVariables(...M,V)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${V.offsetToIndices(\"global_idx\")};\n              let batch = ${K(\"coords\",0,k.rank)};\n              let d2 = ${s?K(\"coords\",k.rank-1,k.rank):K(\"coords\",1,k.rank)};\n              let xFRCCorner = vec3<u32>(${s?K(\"coords\",1,k.rank):K(\"coords\",2,k.rank)},\n              ${s?K(\"coords\",2,k.rank):K(\"coords\",3,k.rank)},\n              ${s?K(\"coords\",3,k.rank):K(\"coords\",4,k.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${s?K(\"uniforms.x_shape\",1,k.rank):K(\"uniforms.x_shape\",2,k.rank)};\n              let xShapeZ = ${s?K(\"uniforms.x_shape\",2,k.rank):K(\"uniforms.x_shape\",3,k.rank)};\n              let xShapeW = ${s?K(\"uniforms.x_shape\",3,k.rank):K(\"uniforms.x_shape\",4,k.rank)};\n              let xShapeU = ${s?K(\"uniforms.x_shape\",4,k.rank):K(\"uniforms.x_shape\",1,k.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${s?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${s?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${s?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${s?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${S?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${ne}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${s};${y};${S}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:b}),getShaderSource:$}}});var Bd,Md,Rd=G(()=>{\"use strict\";te();ae();ce();vt();Bd=(e,t,n,r)=>{let o=e.length>2,a=o?\"value += b[output_channel];\":\"\",s=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?n[3]:n[1],f=p/t.group,h=l&&f>=4?ge(p):1,y=E.size(n)/h,_=[{type:12,data:y},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:f}];Ze(t,_),_.push(...H(s,[d[0],d[1],d[2],d[3]/h]));let b=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...H([n[0],n[1],n[2],n[3]/h]));let w=S=>{let $=N(\"output\",e[0].dataType,n.length,h),v=_e($.type.tensor),T=je(t,$.type.value,v),C=P(\"x\",e[0].dataType,s.length),A=P(\"w\",e[1].dataType,d.length,h),k=[C,A];o&&k.push(P(\"b\",e[2].dataType,e[2].dims,h));let O=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];Qe(t,O);let M=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${C.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${C.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${S.registerUniforms(O).declareVariables(...k,$)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${h} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${M}\n    ${a}\n    ${T}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${h}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},Md=(e,t,n,r)=>{let o=e.length>2,a=ge(n[3]),s=ge(n[2]),d=E.size(n)/a/s,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],f=[n[0],n[1],n[2],n[3]/a],h=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ze(t,h),h.push(...H(l,p,f));let y=(s-1)*t.strides[1]+p[1],_=b=>{let w=N(\"output\",e[0].dataType,f.length,a),S=_e(w.type.tensor),$=je(t,w.type.value,S),v=P(\"x\",e[0].dataType,l.length,a),T=P(\"w\",e[1].dataType,p.length,a),C=[v,T];o&&C.push(P(\"b\",e[2].dataType,e[2].dims,a));let A=o?\"value += b[output_channel];\":\"\",k=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Qe(t,k),`\n  ${b.registerUniforms(k).declareVariables(...C,w)}\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${y}>;\n    var values: array<${w.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${T.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${w.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${a};${s};${y};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:_}}});var tg,yo,rg,bo,_o,Ud,ng,og,wo,Nd=G(()=>{\"use strict\";ae();kd();Dd();Jr();Rd();vt();Xr();ct();tg=(e,t,n,r,o,a)=>{let s=e[0],d=e.slice(a?1:2,a?3:4),l=d.length,p=t[0],h=t.slice(2).map((b,w)=>b+(b-1)*(n[w]-1)),_=d.map((b,w)=>b+r[w]+r[w+l]).map((b,w)=>Math.floor((b-h[w]+o[w])/o[w]));return _.splice(0,0,s),_.splice(a?3:1,0,p),_},yo=[2,3,1,0],rg=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[1]*t.group;if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},bo=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let a=2;a<t[1].dims.length;++a)n[a-2]===0&&(n[a-2]=t[1].dims[a]);let r=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:n,pads:r}),o},_o=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,a=e.group,s=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Ud=(e,t,n,r)=>{let o=n.format===\"NHWC\",a=tg(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,o);if(n.group!==1){let k=[t[0]];if(o){let M=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),k.push(M)}else k.push(t[1]);t.length===3&&k.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(Md(k,n,a,r),{inputs:k}):e.compute(Bd(k,n,a,r),{inputs:k});return}let s=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],f=t[1].dims[2],h=t[1].dims[3],y=a[o?1:2],_=a[o?2:3],b=a[o?3:1],w=o&&f===d&&h===l&&n.pads[0]===0&&n.pads[1]===0;if(w||f===1&&h===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let k=a[0],O,M,V,F=[];if(o){let W=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=W),w){let J=d*l*p;O=t[0].reshape([1,k,J]),M=W.reshape([1,J,b]),V=[1,k,b]}else O=t[0].reshape([k,d*l,p]),M=W.reshape([1,p,b]),V=[k,y*_,b];F.push(O),F.push(M)}else O=t[0].reshape([k,p,d*l]),M=t[1].reshape([1,b,p]),V=[k,b,y*_],F.push(M),F.push(O);s&&F.push(t[2]);let j=V[2],ne=F[0].dims[F[0].dims.length-1];j<8&&ne<8?e.compute(Yr(F,n,a,V,o,r),{inputs:F}):e.compute(nr(F,n,a,V,o,r),{inputs:F});return}let S=!0,$=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];s&&v.push(t[2]);let T=o?y*_:b,C=o?b:y*_,A=f*h*p;e.compute(Ad(v,n,a,T,C,A,s,S,r),{inputs:v})},ng=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=bo({...t,pads:o,strides:a,dilations:s,kernelShape:d},r);Ud(e,r,l,p=>n?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},og=(e,t,n)=>{let r=n.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=bo(n,t),a=n.autoPad===\"NOTSET\"?n.pads:n.autoPad,s=zd(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,r);e.compute(Od(t,o,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],r))},wo=(e,t)=>{if(rg(e.inputs,t),e.inputs[0].dims.length===3)ng(e,t);else if(e.inputs[0].dims.length===5)og(e,e.inputs,t);else{let n=bo(t,e.inputs);Ud(e,e.inputs,n)}}});var Vd,Wd=G(()=>{\"use strict\";te();tt();ae();ce();Vd=(e,t,n)=>{let r=e.length>2,o=t.outputShape,a=t.format===\"NHWC\",s=t.group,d=e[1].dims,l=d[2]/s,p=d[3],f=a?ge(l):1,h=a?ge(p):1,y=a?p===1?f:h:1,_=E.size(o)/h,b=[Math.ceil(_/64),1,1];me(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let w=[\"rank\",\"rank\"],S=[t.strides[0],t.strides[1]],$=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],v=[t.dilations[0],t.dilations[1]],T=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],C=[T[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),T[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:S},{type:12,data:$},{type:12,data:v},{type:12,data:T},{type:6,data:C},{type:12,data:l},{type:12,data:p},...H(e[0].dims,e[1].dims)];r&&(A.push(...H(e[2].dims)),w.push(\"rank\")),A.push(...H(o));let k=O=>{let M=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:S.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:T.length},{name:\"pads\",type:\"i32\",length:C.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],V=_e(e[0].dataType),F=a?1:2,j=a?2:3,ne=a?3:1,W=P(\"W\",e[1].dataType,e[1].dims.length,y),J=P(\"Dy\",e[0].dataType,e[0].dims.length,f),ve=[J,W];r&&ve.push(P(\"bias\",e[2].dataType,[o[ne]].length,h));let Q=N(\"result\",e[0].dataType,o.length,h),ee=()=>{let Z=\"\";if(f===1)Z+=`\n        let w_offset = ${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${W.getByOffset(`w_offset / ${y}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)Z+=`\n          let wValue = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${y}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let pe=0;pe<f;pe++)Z+=`\n            let wValue${pe} = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${pe}, wOutChannel)`)} / ${y}`)};\n            dotProd = dotProd + xValue[${pe}] * wValue${pe};`;return Z},le=`\n            let outputIndices = ${Q.offsetToIndices(`global_idx * ${h}`)};\n            let batch = ${Q.indicesGet(\"outputIndices\",0)};\n            let d1 = ${Q.indicesGet(\"outputIndices\",ne)};\n            let r = ${Q.indicesGet(\"outputIndices\",F)};\n            let c = ${Q.indicesGet(\"outputIndices\",j)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${Q.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${V}(dyRCorner) + ${V}(wR)) / ${V}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${V}(uniforms.Dy_shape[${F}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${V}(dyCCorner) + ${V}(wC)) / ${V}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${V}(uniforms.Dy_shape[${j}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${f}) {\n                  let xValue = ${a?J.getByOffset(`${J.indicesToOffset(`${J.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${f}`):J.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${ee()}\n                  inputChannel = inputChannel + ${f};\n                }\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${r?` + bias[d1 / ${h}]`:\"\"};\n            ${Q.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${O.registerUniforms(M).declareVariables(...ve,Q)}\n      ${O.mainStart()}\n      ${O.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${le}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${f}${y}${h}${p===1}`,inputDependencies:w},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:n?n(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:k}}});var ig,ag,sg,Ld,Gd,ug,Hd,dg,Fd,qd=G(()=>{\"use strict\";Wd();vt();ct();ig=(e,t,n,r,o,a)=>(e-1)*t+n+(r-1)*o+1-a,ag=(e,t,n,r,o)=>{let a=Math.floor(e/2);t===\"SAME_UPPER\"?(n[r]=a,n[o]=e-a):t===\"SAME_LOWER\"&&(n[r]=e-a,n[o]=a)},sg=(e,t,n,r,o,a,s,d,l,p)=>{let f=e.length-2,h=p.length===0;l.length<f&&l.push(...Array(f-l.length).fill(0));let y=e[0],_=t[d?3:1]*o;for(let b=0,w=e.length-f-(d?1:0);b<f;++b,++w){let S=e[w],$=h?S*s[b]:p[b],v=ig(S,s[b],a[b],t[w],n[b],$);ag(v,r,a,b,b+f),h&&p.push(s[b]*(S-1)+l[b]+(t[w]-1)*n[b]+1-a[b]-a[b+f])}p.splice(0,0,y),p.splice(d?3:1,0,_)},Ld=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((h,y)=>h*y,1)===0){n.length=0;for(let h=2;h<t[1].dims.length;++h)n.push(t[1].dims[h])}let r=e.format===\"NHWC\";n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let o=e.pads.slice(),a=e.outputShape.slice(),s=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;l=new Array(h).fill(1)}let p=e.strides.slice();if(p.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;p=new Array(h).fill(1)}sg(d,n,l,e.autoPad,e.group,o,p,r,s,a);let f=Object.assign({},e);return Object.assign(f,{kernelShape:n,pads:o,outputPadding:s,outputShape:a,dilations:l,strides:p}),f},Gd=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,a=e.group,s=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),f=e.outputPadding,h=e.outputShape;return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,outputPadding:f,outputShape:h,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},ug=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[0];if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let a=e[0].dims.length-2;if(t.dilations.reduce((f,h)=>f+h,0)>0&&t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.reduce((f,h)=>f+h,0)>0&&t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.reduce((f,h)=>f+h,0)>0&&t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.outputPadding.length!==a&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${a}D`);if(t.kernelShape.reduce((f,h)=>f+h,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},Hd=(e,t,n,r)=>{let o=e.kernelCustomData.wT??e.compute(Oe(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let a=[t[0],o];t.length===3&&a.push(t[2]),e.compute(Vd(a,n,r),{inputs:a})},dg=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let a=t.dilations;(a.length===0||a[0]===0)&&(a=[1]);let s=t.strides;(s.length===0||s[0]===0)&&(s=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],s=[1].concat(s),a=[1].concat(a),o=[1].concat(o);let l=t.outputPadding;l=[0].concat(l);let p=Ld({...t,pads:d,strides:s,dilations:a,kernelShape:o,outputPadding:l},r);Hd(e,r,p,f=>n?[f[0],f[2],f[3]]:[f[0],f[1],f[3]])},Fd=(e,t)=>{if(ug(e.inputs,t),e.inputs[0].dims.length===3)dg(e,t);else{let n=Ld(t,e.inputs);Hd(e,e.inputs,n)}}});var lg,Kd,jd,Zd=G(()=>{\"use strict\";te();ae();Ce();ce();lg=(e,t,n,r)=>{let o=E.size(t),a=t.length,s=P(\"input\",e,a),d=N(\"output\",e,a),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),p=E.normalizeAxis(l,a),f=h=>{let y=` i32(${s.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=K(\"uniforms.input_shape\",\"uniforms.axis\",a),b=r.reverse?y+(r.exclusive?\" + 1\":\"\"):\"0\",w=r.reverse?_:y+(r.exclusive?\"\":\" + 1\");return`\n                ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(s,d)}\n                ${h.mainStart()}\n                  ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${b};\n                  let last : i32 = ${w};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${s.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:r.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...H(t,t)]}),getShaderSource:f}},Kd=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,o=e.inputs[1];e.compute(lg(r,n,o,t),{inputs:[0]})},jd=e=>{let t=e.exclusive===1,n=e.reverse===1;return re({exclusive:t,reverse:n})}});var cg,pg,mg,Qd,Yd,Xd=G(()=>{\"use strict\";te();ae();Ce();ce();cg=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},pg=(e,t,n,r)=>{let o=[];o.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let a=0;a<t;++a)o.push(n.indicesSet(\"a\",e[a],`i[${a}]`));return o.push(\"return a;}\"),o.join(`\n`)},mg=(e,t)=>{let n,r,o,a,s,d,l=t.format===\"NHWC\",p=t.blocksize,f=t.mode===\"DCR\";l?([n,r,o,a]=e.dims,s=f?[n,r,o,p,p,a/p**2]:[n,r,o,a/p**2,p,p],d=f?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,o,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=f?[n,p,p,a/p**2,r,o]:[n,a/p**2,p,p,r,o],d=f?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let h=e.reshape(s),y=h.dims.length,_=e.dataType,b=P(\"a\",_,y),w=N(\"output\",_,y),S=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(b,w)}\n\n  ${pg(d,y,b,w)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${w.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${w.setByOffset(\"global_idx\",b.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[n,r*p,o*p,a/p**2]:[n,a/p**2,r*p,o*p],T=E.size(v),C=h.dims,A=E.sortBasedOnPerm(C,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...H(C,A)]}},getShaderSource:S}},Qd=(e,t)=>{cg(e.inputs),e.compute(mg(e.inputs[0],t))},Yd=e=>re({blocksize:e.blocksize,mode:e.mode,format:e.format})});var vo,tn,Jd,fg,hg,$o,xo,el,gg,tl,rl,nl=G(()=>{\"use strict\";te();ae();Ce();ce();vo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",tn=\"(\"+vo+\")+\",Jd=\"^\"+tn+\"$\",fg=\"(\"+tn+\",)*\"+tn,hg=\"^\"+fg+\"$\",$o=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,n){let r=this.symbolToIndices.get(t);r===void 0?r=[n]:r.push(n),this.symbolToIndices.set(t,r)}},xo=class{constructor(t,n){this.equation=n;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[r,o]=n.includes(\"->\")?n.split(\"->\",2):[n,\"\"];if(!r.match(RegExp(hg)))throw new Error(\"Invalid LHS term\");if(r.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(Jd)))throw new Error(\"Invalid LHS term\");let f=this.processTerm(d,!0,p,l);this.lhs.push(f)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(tn)))throw new Error(\"Invalid RHS\");o.match(RegExp(vo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,n,r){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==n&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(r)}else o={count:1,dimValue:n,inputIndices:[r]};this.symbolToInfo.set(t,o)}processTerm(t,n,r,o=-1){let a=r.length,s=!1,d=[],l=0;if(!t.match(RegExp(Jd))&&!n&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(vo,\"g\")),f=new $o(o);return p?.forEach((h,y)=>{if(h===\"...\"){if(s)throw new Error(\"Only one ellipsis is allowed per input term\");s=!0;let _=a-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=r.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let b=0;b<d.length;b++){let w=String.fromCharCode(48+b);f.addSymbol(w,y+b),this.addSymbol(w,r[l++],o)}}else f.addSymbol(h,y+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(h,r[l++],o)}),f}},el=e=>e+\"_max\",gg=(e,t,n,r)=>{let a=e.map(f=>f.length).map((f,h)=>P(`input${h}`,t,f)),s=E.size(r),d=N(\"output\",t,r.length),l=[...n.symbolToInfo.keys()].filter(f=>!n.rhs.symbolToIndices.has(f)),p=f=>{let h=[],y=\"var prod = 1.0;\",_=\"var sum = 0.0;\",b=\"sum += prod;\",w=[],S=[],$=[],v=[],T=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((A,k)=>{if(n.rhs.symbolToIndices.has(k)){let O=n.rhs.symbolToIndices.get(k)?.[0];O!==void 0&&n.lhs.forEach((M,V)=>{if(A.inputIndices.includes(V)){let F=M.symbolToIndices.get(k);if(F===void 0)throw new Error(\"Invalid symbol error\");F.forEach(j=>{h.push(`${a[V].indicesSet(`input${V}Indices`,j,d.indicesGet(\"outputIndices\",O))}`)})}})}else n.lhs.forEach((O,M)=>{if(A.inputIndices.includes(M)){let V=O.symbolToIndices.get(k);if(V===void 0)throw new Error(\"Invalid symbol error\");V.forEach(F=>{w.push(`${a[M].indicesSet(`input${M}Indices`,F,`${k}`)}`)}),v.push(`prod *= ${a[M].getByIndices(`input${M}Indices`)};`)}}),S.push(`for(var ${k}: u32 = 0; ${k} < uniforms.${el(k)}; ${k}++) {`),$.push(\"}\")});let C=T?[...h,`let sum = ${a.map((A,k)=>A.getByIndices(`input${k}Indices`)).join(\" * \")};`]:[...h,_,...S,...w,y,...v,b,...$];return`\n            ${f.registerUniforms(l.map(A=>({name:`${el(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...a,d)}\n\n            ${f.mainStart()}\n            ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${a.map((A,k)=>`var input${k}Indices: ${a[k].type.indices};`).join(`\n`)}\n            ${C.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let f=l.filter(y=>n.symbolToInfo.has(y)).map(y=>({type:12,data:n.symbolToInfo.get(y)?.dimValue||0}));f.push({type:12,data:s});let h=e.map((y,_)=>[...H(y)]).reduce((y,_)=>y.concat(_),f);return h.push(...H(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:h}},getShaderSource:p}},tl=(e,t)=>{let n=new xo(e.inputs,t.equation),r=n.outputDims,o=e.inputs.map((a,s)=>a.dims);e.compute(gg(o,e.inputs[0].dataType,n,r))},rl=e=>{let t=e.equation.replace(/\\s+/g,\"\");return re({equation:t})}});var yg,ol,bg,_g,il,al=G(()=>{\"use strict\";te();ae();ce();yg=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,o=t.length<n.length?0:t.length-n.length;for(;r<n.length&&o<t.length;++r,++o)if(n[r]!==t[o]&&n[r]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},ol=(e,t)=>{let n=e.length-t.length,r=[];for(let o=0;o<n;++o)r.push(e[o]);for(let o=0;o<t.length;++o)r.push(t[o]===1?e[o+n]:t[o]);return r},bg=(e,t)=>e.length>t.length?ol(e,t):ol(t,e),_g=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=bg(t,n),o=e[0].dataType,a=o===9||E.size(t)===1,s=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=a||r.length>0&&r[r.length-1]%4===0?4:1,l=Math.ceil(E.size(r)/d),p=h=>{let y=P(\"input\",o,t.length,s),_=N(\"output\",o,r.length,d),b;if(o===9){let w=(S,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${y.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${S}[${$}] = ${v}(${y.getByOffset(`index${$}`)}[component${$}]);\n        `;b=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${w(\"data\",0,\"u32\")}\n        ${w(\"data\",1,\"u32\")}\n        ${w(\"data\",2,\"u32\")}\n        ${w(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else b=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${y.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${y.getByOffset(`inputOffset / ${s}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${h.registerUniform(\"vec_size\",\"u32\").declareVariables(y,_)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${b}`},f=[{type:12,data:l},...H(t,r)];return{name:\"Expand\",shaderCache:{hint:`${r.length};${s}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:f})}},il=e=>{yg(e.inputs),e.compute(_g(e.inputs),{inputs:[0]})}});var wg,sl,ul=G(()=>{\"use strict\";te();ae();ce();jr();wg=e=>{let t=e[0].dataType,n=E.size(e[0].dims),r=E.size(e[1].dims),o=r%4===0,a=s=>{let d=P(\"x\",t,[1],4),l=P(\"bias\",t,[1],4),p=N(\"y\",t,[1],4),f=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],h=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,y=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${h(0)}${h(1)}${h(2)}${h(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${s.registerUniforms(f).declareVariables(d,l,p)}\n\n    ${mo(ze(t))}\n\n    ${s.mainStart(Et)}\n      ${s.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${y}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",fo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:a,getRunData:s=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Et/4)}})}},sl=e=>{e.inputs.length<2||E.size(e.inputs[1].dims)===0?nd(e):e.compute(wg(e.inputs))}});var vg,$g,dl,ll,cl=G(()=>{\"use strict\";te();ae();Ce();ce();vg=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},$g=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.axis,o),s=n.slice(0);s.splice(a,1,...r);let d=n[a],l=e[0].dataType===9?4:1,p=Math.ceil(E.size(s)/l),f=[{type:12,data:p},{type:6,data:d},{type:12,data:a},...H(e[0].dims,e[1].dims,s)],h=y=>{let _=P(\"data\",e[0].dataType,e[0].dims.length,l),b=P(\"inputIndices\",e[1].dataType,e[1].dims.length),w=N(\"output\",e[0].dataType,s.length,l),S=v=>{let T=r.length,C=`var indicesIndices${v}  = ${b.type.indices}(0);`;for(let A=0;A<T;A++)C+=`${T>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${s.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;C+=`\n          var idx${v} = ${b.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,k=0;A<o;A++)A===a?(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,k+=T):(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${s.length>1?`outputIndices${v}[${k}]`:`outputIndices${v}`};`,k++);return C},$;if(e[0].dataType===9){let v=(T,C,A=\"\")=>`\n          let outputIndices${C} = ${w.offsetToIndices(`outputOffset + ${C}u`)};\n          ${S(C)};\n          let offset${C} = ${_.indicesToOffset(`dataIndices${C}`)};\n          let index${C} = offset${C} / 4u;\n          let component${C} = offset${C} % 4u;\n          ${T}[${C}] = ${A}(${_.getByOffset(`index${C}`)}[component${C}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${w.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${w.offsetToIndices(\"global_idx\")};\n      ${S(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${w.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${y.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,b,w)}\n      ${y.mainStart()}\n        ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:h}},dl=e=>re({axis:e.axis}),ll=(e,t)=>{let n=e.inputs;vg(n),e.compute($g(e.inputs,t))}});var xg,pl,ml,fl=G(()=>{\"use strict\";te();ae();ce();xg=(e,t,n,r,o,a,s,d,l)=>{let p=[{type:12,data:a},{type:12,data:r},{type:12,data:o},{type:12,data:n},{type:12,data:s},{type:12,data:d},{type:12,data:l}],f=[a];p.push(...H(t.dims,f));let h=y=>{let _=P(\"indices_data\",t.dataType,t.dims.length),b=N(\"input_slice_offsets_data\",12,1,1),w=[_,b],S=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:n.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${y.registerUniforms(S).declareVariables(...w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${n.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${n.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:f,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:h},{inputs:[t],outputs:[-1]})[0]},pl=(e,t)=>{let n=e.inputs,r=n[0].dims,o=n[0].dataType,a=n[1].dims,s=a[a.length-1],d=E.sizeToDimension(a,a.length-1),l=E.sizeFromDimension(r,t.batchDims+s),p=E.sizeToDimension(r,t.batchDims),f=E.sizeFromDimension(r,t.batchDims),h=d/p,y=new Array(s),_=l;for(let C=0;C<s;++C)y[s-1-C]=_,_*=r[t.batchDims+s-1-C];let b=xg(e,n[1],y,t.batchDims,r,d,h,f,s),w=t.batchDims+s;if(w>r.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let S=a.slice(0,-1).concat(r.slice(w)),$=E.size(S),v=[{type:12,data:$},{type:12,data:l},...H(n[0].dims,b.dims,S)],T=C=>{let A=P(\"data\",n[0].dataType,n[0].dims.length),k=P(\"slice_offsets\",12,b.dims.length),O=N(\"output\",n[0].dataType,S.length);return`\n          ${C.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,k,O)}\n            ${C.mainStart()}\n            ${C.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:S,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:T},{inputs:[n[0],b]})},ml=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Sg,Tg,hl,gl,yl=G(()=>{\"use strict\";te();ae();Ce();ce();Sg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let n=E.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,o=e[0],a=e[2],s=e.length===4?e[3]:void 0;if(a.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===n?Math.ceil(d/r)===a.dims[l]:d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(s){if(s.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(s.dims.length!==a.dims.length||!s.dims.map((d,l)=>d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Tg=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.gatherAxis,o),s=E.normalizeAxis(t.quantizeAxis,o),d=n.slice(0);d.splice(a,1,...r);let l=E.size(d),p=e[2].dataType,h=e[0].dataType===22,y=[{type:12,data:l},{type:12,data:s},{type:12,data:a},{type:12,data:t.blockSize},...H(...e.map((b,w)=>b.dims),d)],_=b=>{let w=P(\"data\",e[0].dataType,e[0].dims.length),S=P(\"inputIndices\",e[1].dataType,e[1].dims.length),$=P(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?P(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,T=N(\"output\",p,d.length),C=[w,S,$];v&&C.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${b.registerUniforms(A).declareVariables(...C,T)}\n        ${b.mainStart()}\n        let output_indices = ${T.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${S.type.indices}(0);\n        ${r.length>1?`\n          for (var i: u32 = 0; i < ${r.length}; i++) {\n            let index = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${S.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`};\n        var data_indices = ${w.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${T.indicesGet(\"output_indices\",\"i\")};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${S.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${w.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${T.indicesGet(\"output_indices\",`i + ${r.length} - 1`)};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${w.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${w.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\"};\n        let dequantized_data = ${ze(p)}(quantized_data - zero_point) * scale;\n        ${T.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((b,w)=>w!==1).map(b=>b.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(b,w)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:y}),getShaderSource:_}},hl=(e,t)=>{let n=e.inputs;Sg(n,t),e.compute(Tg(e.inputs,t))},gl=e=>re({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Cg,Ig,bl,_l,wl=G(()=>{\"use strict\";te();ae();Ce();ce();Cg=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Ig=(e,t)=>{let n=e[0].dims,r=e[0].dataType,o=n.length,a=e[1].dims,s=e[1].dataType,d=E.normalizeAxis(t.axis,o),l=n[d],p=a.slice(0),f=E.size(p),h=P(\"input\",r,o),y=P(\"indicesInput\",s,a.length),_=N(\"output\",r,p.length),b=[{type:12,data:f},{type:6,data:l},{type:12,data:d}];return b.push(...H(n,a,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(h,y,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${y.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${h.type.indices}(outputIndices);\n      ${h.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${h.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},bl=e=>re({axis:e.axis}),_l=(e,t)=>{let n=e.inputs;Cg(n),e.compute(Ig(e.inputs,t))}});var Ag,kg,vl,$l,xl=G(()=>{\"use strict\";te();ae();ce();Ag=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},kg=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[o,a,s]=Wr.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),d=[o,a];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(a/l),f=Math.ceil(o/l),h=!0,y=E.size(d),_=[{type:12,data:h?p:y},{type:12,data:o},{type:12,data:a},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}],b=[\"type\",\"type\"];e.length===3&&(_.push(...H(e[2].dims)),b.push(\"rank\")),_.push(...H(d));let w=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let T=t.alpha===1?\"\":\"value *= uniforms.alpha;\",C=P(\"a\",e[0].dataType,e[0].dims),A=P(\"b\",e[1].dataType,e[1].dims),k=C.type.value,O=null,M=[C,A];e.length===3&&(O=P(\"c\",e[2].dataType,e[2].dims.length),M.push(O));let V=N(\"output\",e[0].dataType,d.length);M.push(V);let F=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(F).declareVariables(...M)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${k}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${T}\n    ${O!=null?`let cOffset = ${O.broadcastedIndicesToOffset(\"vec2(m, n)\",V)}; value += ${k}(uniforms.beta) * ${O.getByOffset(\"cOffset\")};`:\"\"}\n    output[global_idx] = value;\n  }`},S=$=>{let v=P(\"a\",e[0].dataType,e[0].dims),T=P(\"b\",e[1].dataType,e[1].dims),C=null,A=[v,T];e.length===3&&(C=P(\"c\",e[2].dataType,e[2].dims.length),A.push(C));let k=N(\"output\",e[0].dataType,d.length);A.push(k);let O=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],M=\"\",V=\"\";t.transA&&t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let F=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(O).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${k.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${V}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${M}\n      }\n      workgroupBarrier();\n    }\n\n    ${F}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset(\"vec2(m, n)\",k)}; value += ${k.type.value}(uniforms.beta) * ${C.getByOffset(\"cOffset\")};`:\"\"}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return h?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*f},programUniforms:_}),getShaderSource:S}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},vl=e=>{let t=e.transA,n=e.transB,r=e.alpha,o=e.beta;return{transA:t,transB:n,alpha:r,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},$l=(e,t)=>{Ag(e.inputs),e.compute(kg(e.inputs,t))}});var pt,$t,Nt,Vt,Eg,Pg,zg,Og,Dg,Bg,Mg,Rg,Sl,Tl,Cl=G(()=>{\"use strict\";te();ae();Ce();ce();[pt,$t,Nt,Vt]=[0,1,2,3],Eg=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Pg=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,zg=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Og=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,Dg=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Bg=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${pt}] = batch;\n     indices[${$t}] = channel;`+(()=>{switch(n.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,Mg=(e,t,n)=>(()=>{switch(n.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${pt}], indices[${$t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${pt}], indices[${$t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Rg=(e,t)=>{let n=P(\"x\",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=P(\"grid\",e[1].dataType,r.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[pt,$t,Nt,Vt]=[0,3,1,2]);let s=N(\"output\",e[0].dataType,a.length),d=n.type.value,l=E.size(a),p=[{type:12,data:l},...H(e[0].dims,r,a)],f=h=>`\n  ${h.registerUniform(\"output_size\",\"u32\").declareVariables(n,o,s)}\n  ${Pg}\n  ${zg(d)}\n  ${Og(t)}\n  ${Dg(t)}\n  ${Bg(n,d,t)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${s.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${pt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Mg(s,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:h=>{let y=E.size(a);return{outputs:[{dims:a,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:p}},getShaderSource:f}},Sl=(e,t)=>{Eg(e.inputs),e.compute(Rg(e.inputs,t))},Tl=e=>re({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Me,Vg,Al,Il,Wg,or,kl,So=G(()=>{\"use strict\";te();ae();Ce();Vr();qr();ce();ct();Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Vg=(e,t)=>{let n=e[0],r=Me(e,1),o=Me(e,2),a=Me(e,3),s=Me(e,4),d=Me(e,5),l=Me(e,6),p=Me(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let f=n.dims[0],h=n.dims[1],y=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],_=h,b=0,w=0,S=Math.floor(y/t.numHeads);if(l&&p&&E.size(l.dims)&&E.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==f||l.dims[1]!==t.numHeads||l.dims[3]!==S)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==f||p.dims[1]!==t.numHeads||p.dims[3]!==S)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');b=l.dims[2],w=l.dims[2]}else if(l&&E.size(l.dims)||p&&E.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(r&&E.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==S)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==S)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(a&&E.size(a.dims)>0){if(a.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=b+_,T=0;if(s&&E.size(s.dims)>0){T=8;let O=s.dims;throw O.length===1?O[0]===f?T=1:O[0]===3*f+2&&(T=3):O.length===2&&O[0]===f&&O[1]===v&&(T=5),T===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let C=!1,A=y;if(o&&E.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=!1;if(s&&E.size(s.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&E.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==f||d.dims[1]!==t.numHeads||d.dims[2]!==h||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:f,sequenceLength:h,pastSequenceLength:b,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:w,inputHiddenSize:0,hiddenSize:y,vHiddenSize:A,headSize:S,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:k,passPastInKv:C,qkvFormat:$}},Al=e=>re({...e}),Il=re({perm:[0,2,1,3]}),Wg=(e,t,n,r,o,a,s)=>{let d=[r,o,a],l=E.size(d),p=[{type:12,data:l},{type:12,data:s},{type:12,data:a}],f=h=>{let y=N(\"qkv_with_bias\",t.dataType,d),_=P(\"qkv\",t.dataType,d),b=P(\"bias\",n.dataType,d),w=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${h.registerUniforms(w).declareVariables(_,b,y)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:f},{inputs:[t,n],outputs:[-1]})[0]},or=(e,t,n,r,o,a,s,d)=>{let l=a;if(s&&E.size(s.dims)>0){if(r===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Wg(e,a,s,t,r,n*o,d),l=l.reshape([t,r,n,o]),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]}else return a.dims.length===3&&(l=a.reshape([t,r,n,o])),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]},kl=(e,t)=>{let n=Vg(e.inputs,t),r=e.inputs[0],o=Me(e.inputs,1),a=Me(e.inputs,2),s=Me(e.inputs,3),d=Me(e.inputs,4),l=Me(e.inputs,5),p=Me(e.inputs,6),f=Me(e.inputs,7);if(r.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let h=o&&a&&o.dims.length===4&&a.dims.length===4,y=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,s,0);if(h)return Ut(e,y,o,a,d,void 0,p,f,l,n);if(!o||!a)throw new Error(\"key and value must be provided\");let _=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,o,s,n.hiddenSize),b=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,s,2*n.hiddenSize);Ut(e,y,_,b,d,void 0,p,f,l,n)}});var Lg,Gg,Hg,Fg,To,El,Pl,Co=G(()=>{\"use strict\";te();ae();Ce();ce();Lg=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},Gg=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>n.push(Number(o))),r=n.length),re({numOutputs:r,axis:t.axis,splitSizes:n})},Hg=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${K(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Fg=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let o=e[r].setByIndices(\"indices\",\"input[global_idx]\");t===1?n.push(o):r===0?n.push(`if (output_number == ${r}u) { ${o} }`):r===t-1?n.push(`else { ${o} }`):n.push(`else if (output_number == ${r}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join(`\n`)}\n      }`},To=(e,t)=>{let n=e[0].dims,r=E.size(n),o=e[0].dataType,a=E.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),d=P(\"input\",o,n.length),l=new Array(t.numOutputs),p=[],f=[],h=0,y=[{type:12,data:r}];for(let b=0;b<t.numOutputs;b++){h+=t.splitSizes[b],l[b]=h;let w=n.slice();w[a]=t.splitSizes[b],f.push(w),s[b]=N(`output${b}`,o,w.length),p.push({dims:f[b],dataType:e[0].dataType})}y.push({type:12,data:l},...H(n,...f));let _=b=>`\n  ${b.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...s)}\n  ${Hg(l.length)}\n  ${Fg(s)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${K(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",a,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:y})}},El=(e,t)=>{Lg(e.inputs);let n=e.inputs.length===1?t:Gg(e.inputs,t);e.compute(To(e.inputs,n),{inputs:[0]})},Pl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return re({axis:t,numOutputs:r,splitSizes:n})}});var qg,Kg,zl,Ol,Dl=G(()=>{\"use strict\";Ce();qr();So();Co();ct();qg=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=n.dims[0],p=n.dims[1],f=n.dims.length===3?d?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],h=p,y=0,_=!r||r.dims.length===0,b=Math.floor(_?f/(t.numHeads+2*t.kvNumHeads):f/t.numHeads);_&&(f=b*t.numHeads);let w=a&&a.dims.length!==0,S=s&&s.dims.length!==0;if(w&&a.dims.length===4&&a.dims[0]===l&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===b)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(w&&S){if(a.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(s.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=a.dims[2]}else if(w||S)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');h=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==b)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');h=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==b)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');h=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let T=0,C=!1,A=t.kvNumHeads?b*t.kvNumHeads:f;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(h!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(h!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=e.length>4?e[5]:void 0;if(k&&k.dims.length!==1&&k.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:h,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:f,vHiddenSize:A,headSize:b,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:T,scale:t.scale,broadcastResPosBias:!1,passPastInKv:C,qkvFormat:v}},Kg=re({perm:[0,2,1,3]}),zl=(e,t,n)=>{let r=t,o=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(r=t.reshape([n.batchSize,n.kvSequenceLength,o,n.headSize]),r=e.compute(Oe(r,Kg.perm),{inputs:[r],outputs:[-1]})[0]),r},Ol=(e,t)=>{let n=qg(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let r=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,a=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,s=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,f=n.kvNumHeads?n.kvNumHeads:n.numHeads,h=re({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,f*n.headSize,f*n.headSize]}),[y,_,b]=!o&&!a?e.compute(To([r],h),{inputs:[r],outputs:[-1,-1,-1]}):[r,o,a],w=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,y,void 0,0);Ut(e,w,zl(e,_,n),zl(e,b,n),void 0,void 0,s,d,void 0,n,l,p)}});var Bl,jg,Zg,Ml,Rl=G(()=>{\"use strict\";te();ae();ct();ce();Bl=(e,t,n,r,o,a,s,d)=>{let l=ge(a),p=l===1?\"f32\":`vec${l}f`,f=l===1?\"vec2f\":`mat2x${l}f`,h=o*s,y=64;h===1&&(y=256);let _=[o,s,a/l],b=[o,s,2],w=[\"rank\",\"type\",\"type\"],S=[];S.push(...H(_,b));let $=v=>{let T=P(\"x\",t.dataType,3,l),C=P(\"scale\",n.dataType,n.dims),A=P(\"bias\",r.dataType,r.dims),k=N(\"output\",1,3,2),O=[T,C,A,k];return`\n  var<workgroup> workgroup_shared : array<${f}, ${y}>;\n  const workgroup_size = ${y}u;\n  ${v.declareVariables(...O)}\n  ${v.mainStart(y)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${T.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${f}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Ke(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${Ke(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${y}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:b,dataType:1}],dispatchGroup:{x:h},programUniforms:S}),getShaderSource:$},{inputs:[t,n,r],outputs:[-1]})[0]},jg=(e,t,n)=>{let r=t[0].dims,o=r,a=2,s=r[0],d=r[1],l=E.sizeFromDimension(r,a),p=ge(l),f=E.size(o)/p,h=Bl(e,t[0],t[1],t[2],s,l,d,n.epsilon),y=[s,d,l/p],_=[s,d],b=[\"type\",\"none\"],w=S=>{let $=P(\"x\",t[0].dataType,y.length,p),v=P(\"scale_shift\",1,_.length,2),T=N(\"output\",t[0].dataType,y.length,p),C=[$,v,T];return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables(...C)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${T.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);\n      ${T.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...H(y,_,y)]}),getShaderSource:w},{inputs:[t[0],h]})},Zg=(e,t,n)=>{let r=t[0].dims,o=r,a=r[0],s=r[r.length-1],d=E.sizeFromDimension(r,1)/s,l=ge(s),p=E.size(o)/l,f=[{type:12,data:d},{type:12,data:Math.floor(s/l)}],h=[\"type\",\"type\"],y=!1,_=[0,r.length-1];for(let $=0;$<r.length-2;$++)y=y||r[$+1]!==1,_.push($+1);y=y&&r[r.length-1]!==1;let b=y?e.compute(Oe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},($,v)=>r[_[v]])),w=Bl(e,b,t[1],t[2],a,d,s,n.epsilon),S=$=>{let v=_e(t[0].dataType),T=l===1?\"vec2f\":`mat${l}x2f`,C=O=>{let M=O===0?\"x\":\"y\",V=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${V}(scale.${M}))`;case 2:return`vec2<${v}>(${V}(scale[0].${M}, scale[1].${M}))`;case 4:return`vec4<${v}>(${V}(scale[0].${M}, scale[1].${M}, scale[2].${M}, scale[3].${M}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=P(\"input\",t[0].dataType,t[0].dims,l),k=N(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:S},{inputs:[t[0],w]})},Ml=(e,t)=>{t.format===\"NHWC\"?Zg(e,e.inputs,t):jg(e,e.inputs,t)}});var Qg,Yg,Ul,Nl=G(()=>{\"use strict\";te();ae();ce();Qg=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},Yg=(e,t,n)=>{let r=t.simplified,o=e[0].dims,a=e[1],s=!r&&e[2],d=o,l=E.normalizeAxis(t.axis,o.length),p=E.sizeToDimension(o,l),f=E.sizeFromDimension(o,l),h=E.size(a.dims),y=s?E.size(s.dims):0;if(h!==f||s&&y!==f)throw new Error(`Size of X.shape()[axis:] == ${f}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${y}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let b=ge(f),w=[\"type\",\"type\"],S=[{type:12,data:p},{type:1,data:f},{type:12,data:Math.floor(f/b)},{type:1,data:t.epsilon}];s&&w.push(\"type\");let $=n>1,v=n>2,T=A=>{let k=_e(e[0].dataType),O=[P(\"x\",e[0].dataType,e[0].dims,b),P(\"scale\",a.dataType,a.dims,b)];s&&O.push(P(\"bias\",s.dataType,s.dims,b)),O.push(N(\"output\",e[0].dataType,d,b)),$&&O.push(N(\"mean_data_output\",1,_)),v&&O.push(N(\"inv_std_output\",1,_));let M=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(M).declareVariables(...O)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${uo(\"f32\",b)};\n    var mean_square_vector = ${uo(\"f32\",b)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(k,b,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Ke(\"mean_vector\",b)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Ke(\"mean_square_vector\",b)} / uniforms.norm_size ${r?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(k,b,\"x[j + offset]\")};\n      let f32scale = ${Pt(k,b,\"scale[j]\")};\n      output[j + offset] = ${O[0].type.value}((f32input ${r?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${s?`+ ${Pt(k,b,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},C=[{dims:d,dataType:e[0].dataType}];return $&&C.push({dims:_,dataType:1}),v&&C.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${b};${n};${r}`,inputDependencies:w},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:S}),getShaderSource:T}},Ul=(e,t)=>{Qg(e.inputs),e.compute(Yg(e.inputs,t,e.outputCount))}});var Xg,Vl,Wl=G(()=>{\"use strict\";ae();Xr();Jr();Xg=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Vl=e=>{Xg(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(Yr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],a=E.size(e.inputs[0].dims.slice(0,-2)),s=E.size(e.inputs[1].dims.slice(0,-2));if(a!==1&&o===1&&s===1){let d=e.inputs[0].reshape([1,a,r]),l=e.inputs[1].reshape([1,r,n]),p=[1,a,n],f=[d,l];e.compute(nr(f,{activation:\"\"},t,p),{inputs:f})}else e.compute(nr(e.inputs,{activation:\"\"},t))}}});var Jg,ey,ty,Ll,Gl,Hl=G(()=>{\"use strict\";te();ae();Ce();ce();Jg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,s=e[1];if(!E.areEqual(s.dims,[t.n,o,a]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(E.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let f=e[3].dims,h=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(E.size(f)!==h)throw new Error(\"zeroPoints input size error.\")}},ey=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=ge(s),w=d.concat([o,s]),S=o>1&&s/b%2===0?2:1,$=E.size(w)/b/S,v=64,T=[],C=[l,o,a/y],A=E.convertShape(e[1].dims).slice();A.splice(-1,1,f/_),T.push(...H(C)),T.push(...H(A)),T.push(...H(e[2].dims)),e.length===4&&T.push(...H(E.convertShape(e[3].dims)));let k=[l,o,s/b];T.push(...H(k));let O=M=>{let V=C.length,F=P(\"a\",e[0].dataType,V,y),j=P(\"b\",12,A.length,_),ne=P(\"scales\",e[2].dataType,e[2].dims.length),W=[F,j,ne],J=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;J&&W.push(J);let ve=k.length,Q=N(\"output\",e[0].dataType,ve,b),ee=_e(e[0].dataType),le=(()=>{switch(y){case 1:return`array<${ee}, 8>`;case 2:return`mat4x2<${ee}>`;case 4:return`mat2x4<${ee}>`;default:throw new Error(`${y}-component is not supported.`)}})(),Z=()=>{let Se=`\n          // reuse a data\n            var input_offset = ${F.indicesToOffset(`${F.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${le};\n            for (var j: u32 = 0; j < ${8/y}; j++) {\n              a_data[j] = ${F.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let D=0;D<b*S;D++)Se+=`\n            b_value = ${_===1?`b${D}_data`:`b${D}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${le}(${Array.from({length:4},(R,Y)=>`${ee}(b_value_lower[${Y}]), ${ee}(b_value_upper[${Y}])`).join(\", \")});\n            b_dequantized_values = ${y===1?`${le}(${Array.from({length:8},(R,Y)=>`(b_quantized_values[${Y}] - ${J?`zero_point${D}`:\"zero_point\"}) * scale${D}`).join(\", \")});`:`(b_quantized_values - ${le}(${Array(8).fill(`${J?`zero_point${D}`:\"zero_point\"}`).join(\",\")})) * scale${D};`};\n            workgroup_shared[local_id.x * ${S} + ${Math.floor(D/b)}]${b>1?`[${D%b}]`:\"\"} += ${Array.from({length:8/y},(R,Y)=>`${y===1?`a_data[${Y}] * b_dequantized_values[${Y}]`:`dot(a_data[${Y}], b_dequantized_values[${Y}])`}`).join(\" + \")};\n          `;return Se},pe=()=>{let Se=`\n            var col_index = col * ${b};\n            ${J?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${ee}(8);`}\n            `;for(let D=0;D<b*S;D++)Se+=`\n            let scale${D} = ${ne.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${J?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${J.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${D} = ${ee}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return Se},ke=()=>{let Se=`col_index = col * ${b};`;for(let D=0;D<b*S;D++)Se+=`\n            let b${D}_data = ${j.getByIndices(`${j.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return Se+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${le};\n            var b_dequantized_values: ${le};`,Se};return`\n        var<workgroup> workgroup_shared: array<${Q.type.value}, ${S*v}>;\n        ${M.declareVariables(...W,Q)}\n        ${M.mainStart([v,1,1])}\n          let output_indices = ${Q.offsetToIndices(`(global_idx / ${v}) * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/y};\n            ${pe()}\n            for (var word: u32 = 0; word < ${f}; word += ${_}) {\n              ${ke()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${Z()}\n                word_offset += ${8/y};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${S}) {\n            var output_value: ${Q.type.value} = ${Q.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${S};\n            }\n            ${Q.setByIndices(`${Q.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${y};${_};${b};${S};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:w,dataType:h}],dispatchGroup:{x:$},programUniforms:T}),getShaderSource:O}},ty=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=d.concat([o,s]),w=128,S=s%8===0?8:s%4===0?4:1,$=w/S,v=$*_*8,T=v/y,C=v/t.blockSize,A=E.size(b)/S,k=[],O=[l,o,a/y],M=E.convertShape(e[1].dims).slice();M.splice(-1,1,f/_),k.push(...H(O)),k.push(...H(M)),k.push(...H(e[2].dims)),e.length===4&&k.push(...H(E.convertShape(e[3].dims)));let V=[l,o,s];k.push(...H(V));let F=j=>{let ne=O.length,W=P(\"a\",e[0].dataType,ne,y),J=P(\"b\",12,M.length,_),ve=P(\"scales\",e[2].dataType,e[2].dims.length),Q=[W,J,ve],ee=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;ee&&Q.push(ee);let le=V.length,Z=N(\"output\",e[0].dataType,le),pe=_e(e[0].dataType),ke=()=>{switch(y){case 1:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${y}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${W.type.value}, ${T}>;\n        var<workgroup> inter_results: array<array<${Z.type.value}, ${$}>, ${S}>;\n        ${j.declareVariables(...Q,Z)}\n        ${j.mainStart([$,S,1])}\n          let output_indices = ${Z.offsetToIndices(`workgroup_index * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${C} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${T};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${w})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${W.getByIndices(`${W.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${W.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${C} + local_id.x;\n            ${ee?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${ee.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${pe}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${pe}(8);`}\n            let scale = ${ve.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${J.getByIndices(`${J.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/y};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${ke()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${pe}>(${Array.from({length:4},(Se,D)=>`${pe}(b_value_lower[${D}]), ${pe}(b_value_upper[${D}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${pe}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Se,D)=>`${`dot(a_data${D}, b_dequantized_values[${D}])`}`).join(\" + \")};\n              word_offset += ${8/y};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${S}) {\n            var output_value: ${Z.type.value} = ${Z.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${Z.setByIndices(`${Z.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${y};${_};${$};${S}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:b,dataType:h}],dispatchGroup:{x:A},programUniforms:k}),getShaderSource:F}},Ll=(e,t)=>{Jg(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(ty(e.inputs,t)):e.compute(ey(e.inputs,t))},Gl=e=>re(e)});var ry,ny,oy,iy,ay,sy,uy,dy,Fl,ql=G(()=>{\"use strict\";te();ae();ce();ry=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},ny=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},oy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${K(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},iy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${K(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},ay=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0)  {\n                  k += i32(${K(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${K(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},sy=(e,t,n)=>{switch(n.mode){case 0:return ny(e,t,n.pads.length);case 1:return oy(e,t,n.pads.length);case 2:return iy(e,t,n.pads.length);case 3:return ay(e,t,n.pads.length);default:throw new Error(\"Invalid mode\")}},uy=(e,t)=>{let n=E.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,o=E.size(n),a=[{type:12,data:o},{type:6,data:t.pads}],s=e.length>=3&&e[2].data;t.mode===0&&a.push({type:s?e[2].dataType:1,data:t.value}),a.push(...H(e[0].dims,n));let d=[\"rank\"],l=p=>{let f=N(\"output\",e[0].dataType,n.length),h=P(\"x\",e[0].dataType,r.length),y=h.type.value,_=sy(f,r.length,t),b=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&b.push({name:\"constant_value\",type:s?y:\"f32\"}),`\n            ${p.registerUniforms(b).declareVariables(h,f)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${f.offsetToIndices(\"global_idx\")};\n\n            var value = ${y}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${s}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(n)/64)},programUniforms:a}),getShaderSource:l}},dy=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,a=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)a[Number(d[l])]=Number(n[l]),a[Number(d[l])+o]=Number(n[l+d.length])}else n.forEach((d,l)=>a[Number(l)]=Number(d));let s=[];return a.forEach(d=>s.push(d)),{mode:t.mode,value:r,pads:s}}else return t},Fl=(e,t)=>{ry(e.inputs);let n=dy(e.inputs,t);e.compute(uy(e.inputs,n),{inputs:[0]})}});var rn,Kl,jl,Zl,Ql,ly,cy,Yl,Xl,Jl,ec,tc,rc,nc,oc,ic,ac,sc,uc,dc=G(()=>{\"use strict\";Ge();te();ae();ce();rn=e=>{if(we.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},Kl=(e,t,n)=>{let r=t.format===\"NHWC\",o=e.dims.slice();r&&o.splice(1,0,o.pop());let a=Object.hasOwnProperty.call(t,\"dilations\"),s=t.kernelShape.slice(),d=t.strides.slice(),l=a?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(n,o,s,d,l,p);let f=kt.computePoolOutputShape(n,o,d,l,s,p,t.autoPad),h=Object.assign({},t);a?Object.assign(h,{kernelShape:s,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(h,{kernelShape:s,strides:d,pads:p,cacheKey:t.cacheKey});let y=f.slice();return y.push(y.splice(1,1)[0]),[h,r?y:f]},jl=(e,t)=>{let n=t.format===\"NHWC\",r=E.size(e),o=E.size(t.kernelShape),a=[{type:12,data:r},{type:12,data:o}],s=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],f=t.pads[t.pads.length-1],h=!!(p+f);a.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:f}),s.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let y=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],b=t.strides[t.strides.length-2],w=t.pads[t.pads.length/2-2],S=t.pads[t.pads.length-2];y=!!(w+S),a.push({type:12,data:_},{type:12,data:b},{type:12,data:w},{type:12,data:S}),s.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[a,s,!0,h,y]}else{if(n)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=E.computeStrides(t.kernelShape);a.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,f)=>p+f);return[a,s,!!l,!1,!1]}},Zl=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y=o.format===\"NHWC\",_=t.type.value,b=N(\"output\",t.type.tensor,r);if(o.kernelShape.length<=2){let w=\"\",S=\"\",$=\"\",v=n-(y?2:1);if(f?w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`:w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`,o.kernelShape.length===2){let C=n-(y?3:2);h?S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${C}] < 0 || xIndices[${C}] >= uniforms.x_shape[${C}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${S}\n              ${w}\n              ${$}\n              ${s}\n\n              output[global_idx] = value;\n            }`}else{if(y)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let w=o.kernelShape.length,S=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${a}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${w}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${w-1}u; j++) {\n                  offsets[j] = offset / ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                  offset -= offsets[j] * ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                }\n                offsets[${w-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-w}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${K(\"uniforms.strides\",`j - ${n-w}u`,w)}\n                    + offsets[j - ${n-w}u] - ${K(\"uniforms.pads\",\"j - 2u\",S)};\n                  ${$}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Ql=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,ly=e=>`${Ql(e)};${e.countIncludePad}`,cy=e=>`${Ql(e)};${e.storageOrder};${e.dilations}`,Yl=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xl=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=P(\"x\",t.dataType,t.dims.length),d=s.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[f,h,y,_,b]=jl(a,o);f.push(...H(t.dims,a));let w=[\"rank\"];return{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:S=>Zl(S,s,t.dims.length,a.length,o,l,p,0,h,y,_,b)}},Jl=e=>{let t=e.count_include_pad!==0,n=Yl(e);if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let r={countIncludePad:t,...n,cacheKey:\"\"};return{...r,cacheKey:ly(r)}},ec=(e,t)=>{rn(e.inputs),e.compute(Xl(\"AveragePool\",e.inputs[0],!1,t))},tc={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},rc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},nc=(e,t)=>{rn(e.inputs),e.compute(Xl(\"GlobalAveragePool\",e.inputs[0],!0,t))},oc=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=`\n      value = max(x_val, value);\n    `,d=\"\",l=P(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[f,h,y,_,b]=jl(a,o);return f.push(...H(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:w=>Zl(w,l,t.dims.length,a.length,o,s,d,t.dataType===10?-65504:-1e5,h,y,_,b)}},ic=(e,t)=>{rn(e.inputs),e.compute(oc(\"MaxPool\",e.inputs[0],!1,t))},ac=e=>{let t=e.storage_order,n=e.dilations,r=Yl(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:n,...r,cacheKey:\"\"};return{...o,cacheKey:cy(o)}},sc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},uc=(e,t)=>{rn(e.inputs),e.compute(oc(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var my,fy,lc,cc,pc=G(()=>{\"use strict\";te();ae();Ce();ce();my=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((n,r)=>n===e[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,a)=>a===t.axis||o===e[0].dims[a]).reduce((o,a)=>o&&a,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},fy=(e,t)=>{let n=E.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,o=r===3,a=e[0].dims,s=e[1].dataType,d=E.size(a),l=r===3||r===2,p=l?[Math.ceil(E.size(e[0].dims)/4)]:e[0].dims,f=e[1].dims,h=e.length>2?e[2]:void 0,y=h?l?[Math.ceil(E.size(h.dims)/4)]:h.dims:void 0,_=f.length===0||f.length===1&&f[0]===1,b=_===!1&&f.length===1,w=ge(d),S=_&&(!l||w===4),$=S?w:1,v=S&&!l?w:1,T=P(\"input\",l?12:r,p.length,v),C=P(\"scale\",s,f.length),A=h?P(\"zero_point\",l?12:r,y.length):void 0,k=N(\"output\",s,a.length,$),O=[T,C];A&&O.push(A);let M=[p,f];h&&M.push(y);let V=[{type:12,data:d/$},{type:12,data:n},{type:12,data:t.blockSize},...H(...M,a)],F=j=>{let ne=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${j.registerUniforms(ne).declareVariables(...O,k)}\n      ${j.mainStart()}\n          ${j.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${k.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${l?`\n            let input = ${T.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${T.getByOffset(\"global_idx\")};`};\n\n          // Set scale input\n          ${_?`let scale_value= ${C.getByOffset(\"0\")}`:b?`\n            let scale_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${C.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${C.type.indices} = output_indices;\n            let index = ${C.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${C.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${C.getByIndices(\"scale_indices\")};`};\n\n          // Set zero-point input\n          ${A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:b?l?`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${C.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":T.type.value}(0);`};\n      // Compute and write output\n      ${k.setByOffset(\"global_idx\",`${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:F,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:V})}},lc=(e,t)=>{my(e.inputs,t),e.compute(fy(e.inputs,t))},cc=e=>re({axis:e.axis,blockSize:e.blockSize})});var hy,gy,mc,fc=G(()=>{\"use strict\";Ge();te();ce();hy=(e,t,n)=>{let r=e===t,o=e<t&&n<0,a=e>t&&n>0;if(r||o||a)throw new Error(\"Range these inputs' contents are invalid.\")},gy=(e,t,n,r)=>{let o=Math.abs(Math.ceil((t-e)/n)),a=[o],s=o,d=[{type:12,data:s},{type:r,data:e},{type:r,data:n},...H(a)],l=p=>{let f=N(\"output\",r,a.length),h=f.type.value,y=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:h},{name:\"delta\",type:h}];return`\n        ${p.registerUniforms(y).declareVariables(f)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${h}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${r}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d})}},mc=e=>{let t=0,n=0,r=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),we.webgpu.validateInputContent&&hy(t,n,r),e.compute(gy(t,n,r,e.inputs[0].dataType),{inputs:[]})}});var yy,by,hc,gc,yc=G(()=>{\"use strict\";te();ae();Ce();ce();yy=(e,t,n,r)=>{if(e!==\"none\"&&r!==\"i32\"&&r!==\"u32\"&&r!==\"f32\")throw new Error(`Input ${r} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${n};`;case\"add\":return r===\"i32\"||r===\"u32\"?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\n              ${o}bitcast<${r}>(oldValue) + (${n})${a}`;case\"max\":return r===\"i32\"||r===\"u32\"?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${n}))${a}`;case\"min\":return r===\"i32\"||r===\"u32\"?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${o}min(bitcast<${r}>(oldValue), (${n}))${a}`;case\"mul\":return`${o}(bitcast<${r}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},by=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n,a=1,s=Math.ceil(E.size(r)/a),d=r[r.length-1],l=E.sizeFromDimension(n,d),p=[{type:12,data:s},{type:12,data:d},{type:12,data:l},...H(e[1].dims,e[2].dims,o)],f=h=>{let y=P(\"indices\",e[1].dataType,e[1].dims.length),_=P(\"updates\",e[2].dataType,e[2].dims.length,a),b=t.reduction!==\"none\"&&t.reduction!==\"\"?Hs(\"output\",e[0].dataType,o.length):N(\"output\",e[0].dataType,o.length,a);return`\n      ${h.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(y,_,b)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var hasDuplicates = false;\n  if (${t.reduction===\"none\"}) {\n    let n = ${E.size(r)};\n    for (var i = 0; i < n; i = i + 1) {\n      for (var j = i + 1; j < n; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  if (${t.reduction===\"none\"} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    indices_start = 0u;\n  }\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${yy(t.reduction,\"output[data_offset + i]\",\"value\",b.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:p}),getShaderSource:f}},hc=e=>re({reduction:e.reduction}),gc=(e,t)=>{e.compute(by(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var _y,wy,vy,bc,$y,xy,Sy,Ty,Cy,Iy,Ay,ky,_c,Ey,Py,zy,Oy,Dy,wc,vc,$c=G(()=>{\"use strict\";te();ae();Ce();ce();_y=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},wy=(e,t,n)=>{t.every(o=>o>=0&&o<n||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let r=new Array(n).fill(1);return t.forEach((o,a)=>r[o]=e[a]),r},vy=(e,t,n,r,o,a)=>{let[s,d,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(f=>a.push(f));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(f=>r.push(f)),r.length!==0&&r.length!==p&&n>=18&&r.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");_y(r,t),t.axes.length>0&&wy(r,t.axes,p).forEach((f,h)=>r[h]=f)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(f=>o.push(Number(f))),o.length!==0&&o.length!==p&&n>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<\"u\"&&typeof o<\"u\"&&r.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},bc=(e,t,n,r)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${r}(big / (${n}));\n  let fract = ${r}(big % (${n})) / ${r}(${n});\n  return whole + fract;\n`,$y=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${bc(\"xResized\",\"lengthOriginal\",\"lengthResized\",t)}\n          }\n        `;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${bc(\"xResized\",\"lengthOriginal - 1\",\"lengthResized - 1\",t)}\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",xy=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Sy=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),o=e.length===0?r:e.slice();return t.length>0?(t.forEach((a,s)=>{r[a]=o[s],r[s+n]=o[t.length+s]}),r):o},Ty=(e,t,n,r)=>{let o=[];if(n.length>0)if(r.length>0){if(e.forEach(a=>o.push(a)),Math.max(...r)>e.length)throw new Error(\"axes is out of bound\");r.forEach((a,s)=>o[a]=n[s])}else n.forEach(a=>o.push(a));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((a,s)=>Math.round(a*t[s]))}return o},Cy=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case\"not_larger\":return n.axes.length>0?Math.min(...n.axes.map(a=>t[a]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return n.axes.length>0?Math.max(...n.axes.map(a=>t[a]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return n.axes.length>0?(n.axes.forEach(a=>t[a]=r),n.axes.forEach(a=>o[a]=Math.round(e[a]*t[a]))):(t.fill(r,0,t.length),o.forEach((a,s)=>o[s]=Math.round(a*t[s]))),o},Iy=(e,t,n,r,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${K(\"uniforms.scales\",\"i\",r)};\n        var roi_low = ${K(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${K(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ay=(e,t,n,r,o,a,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${K(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${K(\"uniforms.roi\",\"i\",a)};\n          var roi_hi = ${K(\"uniforms.roi\",`i + ${n.length}`,a)};\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")}\n      }\n      return input_indices;\n    }`,ky=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${K(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,_c=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",n,\"batch\")};\n`:\"\",Ey=(e,t,n,r,o)=>{let[s,d,l,p]=n.length===2?[-1,0,1,-1]:[0,2,3,1],f=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${f} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${n[l]} - 1))`)};\n      ${_c(e,p,s,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${f} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${f} = originalIndices[${d}];\n      var col:${f} = originalIndices[${l}];\n      ${r?`if (row < 0 || row > (${n[d]} - 1) || col < 0 || col > (${n[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${n[d]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${s}])`:\"0\"};\n      var x11: ${f} = getInputValue(batch, channel, row1, col1);\n      var x12: ${f} = getInputValue(batch, channel, row1, col2);\n      var x21: ${f} = getInputValue(batch, channel, row2, col1);\n      var x22: ${f} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${f} = abs(row - ${f}(row1));\n      var dx2: ${f} = abs(${f}(row2) - row);\n      var dy1: ${f} = abs(col - ${f}(col1));\n      var dy2: ${f} = abs(${f}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Py=(e,t,n,r,o,a,s,d,l,p)=>{let f=n.length===2,h=!0,[y,_]=f?[0,1]:h?[2,3]:[1,2],b=e.type.value,w=S=>{let $=S===y?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${b} {\n        var output_index = ${t.indicesGet(\"output_indices\",S)};\n        var originalIdx: ${b} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[S]},\n        ${r[S]}, ${n[S]}, ${a[S]}, ${a[S]} + ${n.length});\n        var fractOriginalIdx: ${b} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${n[S]} - 1))) {\n          return ${l};\n        }\n        var data: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${b} = originalIdx + ${b}(i);\n          if (${$} < 0 || ${$} >= ${n[S]}) {\n            ${p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${n[S]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",S,`u32(${$})`)};\n          data[i + 1] = ${S===y?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${w(y)};\n    ${w(_)};\n  fn getCubicInterpolationCoefs(s: ${b}) -> array<${b}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${b} = 1.0 - absS;\n    var twoMinusAbsS: ${b} = 2.0 - absS;\n    var onePlusAbsS: ${b} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${b}, 4>, coefs: array<${b}, 4>) -> ${b} {\n    var coefsSum: ${b} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${b} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},zy=(e,t,n,r,o)=>{let[s,d,l,p,f]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${n[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${n[p]} - 1))`)};\n      ${_c(e,f,s,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${h} = originalIndices[${d}];\n      var height:${h} = originalIndices[${l}];\n      var width:${h} = originalIndices[${p}];\n      ${r?`if (depth < 0 || depth > (${n[d]} - 1) || height < 0 || height > (${n[l]} - 1) || width < 0 || (width > ${n[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${n[d]} - 1));\n      height = max(0, min(height, ${n[l]} - 1));\n      width = max(0, min(width, ${n[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${f}])`:\"0\"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${s}])`:\"0\"};\n\n      var x111: ${h} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${h} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${h} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${h} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${h} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${h} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${h} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${h} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${h} = abs(depth - ${h}(depth1));\n      var dx2: ${h} = abs(${h}(depth2) - depth);\n      var dy1: ${h} = abs(height - ${h}(height1));\n      var dy2: ${h} = abs(${h}(height2) - height);\n      var dz1: ${h} = abs(width - ${h}(width1));\n      var dz2: ${h} = abs(${h}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Oy=(e,t,n,r,o,a)=>{let s=e.dims,d=Sy(a,t.axes,s.length),l=Ty(s,r,o,t.axes),p=r.slice();r.length===0&&(p=s.map((v,T)=>v===0?1:l[T]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Cy(s,p,t)));let f=N(\"output\",e.dataType,l.length),h=P(\"input\",e.dataType,s.length),y=E.size(l),_=s.length===l.length&&s.every((v,T)=>v===l[T]),b=t.coordinateTransformMode===\"tf_crop_and_resize\",w=t.extrapolationValue,S=h.type.value,$=v=>`\n      ${_?\"\":`\n      ${$y(t.coordinateTransformMode,S)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${ky(h,s)};\n              ${xy(t.nearestMode,n,S)};\n              ${Ay(h,f,s,l,p.length,d.length,b)};\n              `;case\"linear\":return`\n              ${Iy(f,s,l,p.length,d.length)};\n              ${(()=>{if(s.length===2||s.length===4)return`${Ey(h,f,s,b,w)}`;if(s.length===3||s.length===5)return`${zy(h,f,s,b,w)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(s.length===2||s.length===4)return`${Py(h,f,s,l,p,d,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(h,f)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${f.offsetToIndices(\"global_idx\")};\n        var input_indices: ${h.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${h.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${s.length===2||s.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${n}|${p.length>0?t.mode===\"cubic\"?p:p.length:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${t.mode===\"nearest\"?s.length:s}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},{type:1,data:p},{type:1,data:d},...H(s,l)]})}},Dy=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},wc=(e,t)=>{let n=[],r=[],o=[],a=Dy(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");vy(e.inputs,t,a,n,r,o),e.compute(Oy(e.inputs[0],t,a,n,r,o),{inputs:[0]})},vc=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,o=e.cubicCoeffA,a=e.excludeOutside!==0,s=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return re({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:o,excludeOutside:a,extrapolationValue:s,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var By,My,xc,Sc=G(()=>{\"use strict\";te();ae();Ce();ce();By=(e,t)=>{let[n,r,o,a]=e,{numHeads:s,rotaryEmbeddingDim:d}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!E.areEqual(r.dims,[])&&!E.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!E.areEqual(o.dims,a.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&s===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=n.dims[0],p=n.dims[n.dims.length-2],f=o.dims[0],h=E.sizeFromDimension(n.dims,1)/p,y=d===0?o.dims[1]*2:h/s;if(d>y)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(r.dims.length===2){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(p!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(y/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>f)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},My=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:o,scale:a}=t,s=e[0].dims[0],d=E.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,f=e[2].dims[1],h=o===0?f*2:p/r,y=new Array(s,l,p/h,h-f),_=E.computeStrides(y),b=[{type:1,data:a},{type:12,data:y},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,h,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,h,l*h,1]}):[],...H(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],w=S=>{let $=P(\"input\",e[0].dataType,e[0].dims.length),v=P(\"position_ids\",e[1].dataType,e[1].dims.length),T=P(\"cos_cache\",e[2].dataType,e[2].dims.length),C=P(\"sin_cache\",e[3].dataType,e[3].dims.length),A=N(\"output\",e[0].dataType,e[0].dims.length);return S.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:y.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${S.declareVariables($,v,T,C,A)}\n\n        ${S.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",N(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${C.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${C.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:re({interleaved:n}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(y)/Et)},programUniforms:b})}},xc=(e,t)=>{By(e.inputs,t),e.compute(My(e.inputs,t))}});var Ry,Uy,Tc,Cc=G(()=>{\"use strict\";te();ae();ce();Ry=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(n.dims.length!==3&&n.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(n.dims[n.dims.length-2]!==a)throw new Error(\"Skip must have the same sequence length as input\");if(r.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(r.dims[r.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let s=e[3];if(s.dims.length!==1)throw new Error(\"Beta must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let s=e[4];if(s.dims.length!==1)throw new Error(\"Bias must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Uy=(e,t,n,r)=>{let o=t.simplified,a=e[0].dims,s=E.size(a),d=a,l=s,p=a.slice(-1)[0],f=r?a.slice(0,-1).concat(1):[],h=!o&&e.length>3,y=e.length>4,_=r&&n>1,b=r&&n>2,w=n>3,S=64,$=ge(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],T=A=>{let k=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],O=[P(\"x\",e[0].dataType,e[0].dims,$),P(\"skip\",e[1].dataType,e[1].dims,$),P(\"gamma\",e[2].dataType,e[2].dims,$)];h&&O.push(P(\"beta\",e[3].dataType,e[3].dims,$)),y&&O.push(P(\"bias\",e[4].dataType,e[4].dims,$)),O.push(N(\"output\",e[0].dataType,d,$)),_&&O.push(N(\"mean_output\",1,f)),b&&O.push(N(\"inv_std_output\",1,f)),w&&O.push(N(\"input_skip_bias_sum\",e[0].dataType,d,$));let M=_e(e[0].dataType),V=_e(1,$);return`\n\n      ${A.registerUniforms(k).declareVariables(...O)}\n      var<workgroup> sum_shared : array<${V}, ${S}>;\n      var<workgroup> sum_squared_shared : array<${V}, ${S}>;\n\n      ${A.mainStart([S,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${S};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${S};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${S-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${y?\"bias[offset1d + i]\":M+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${w?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Pt(M,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${S};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Ke(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Ke(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${b?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${M}(mean)`}) *\n            ${M}(inv_std_dev) * gamma[offset1d + i]\n            ${h?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},C=[{dims:d,dataType:e[0].dataType}];return n>1&&C.push({dims:f,dataType:1}),n>2&&C.push({dims:f,dataType:1}),n>3&&C.push({dims:a,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${b};${w}`,inputDependencies:e.map((A,k)=>\"type\")},getShaderSource:T,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Tc=(e,t)=>{Ry(e.inputs);let r=[0];e.outputCount>1&&r.push(-3),e.outputCount>2&&r.push(-3),e.outputCount>3&&r.push(3),e.compute(Uy(e.inputs,t,e.outputCount,!1),{outputs:r})}});var Ny,nn,Vy,Ic,Wy,Ly,Ac,kc,Ec=G(()=>{\"use strict\";te();ae();Ce();ce();Ny=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((n,r)=>{if(e[r+1].dataType!==6&&e[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},nn=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},Vy=(e,t)=>{if(e.length>1){let n=nn(e,1),r=nn(e,2),o=nn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),re({starts:n,ends:r,axes:o})}else return t},Ic=(e,t,n,r,o)=>{let a=e;return e<0&&(a+=n[r[t]]),o[t]<0?Math.max(0,Math.min(a,n[r[t]]-1)):Math.max(0,Math.min(a,n[r[t]]))},Wy=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n            let steps_i = ${K(\"uniforms.steps\",\"i\",n.length)};\n            let signs_i = ${K(\"uniforms.signs\",\"i\",n.length)};\n            let starts_i = ${K(\"uniforms.starts\",\"i\",n.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,Ly=(e,t)=>{let n=e[0].dims,r=E.size(n),o=t.axes.length>0?E.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=nn(e,4);a.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),a.length===0&&(a=Array(o.length).fill(1));let s=t.starts.map(($,v)=>Ic($,v,n,o,a)),d=t.ends.map(($,v)=>Ic($,v,n,o,a));if(o.length!==s.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==n.length)for(let $=0;$<n.length;++$)o.includes($)||(s.splice($,0,0),d.splice($,0,n[$]),a.splice($,0,1));let l=a.map($=>Math.sign($));a.forEach(($,v,T)=>{if($<0){let C=(d[v]-s[v])/$,A=s[v],k=A+C*a[v];s[v]=k,d[v]=A,T[v]=-$}});let p=n.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-s[$])/a[$])});let f={dims:p,dataType:e[0].dataType},h=N(\"output\",e[0].dataType,p.length),y=P(\"input\",e[0].dataType,e[0].dims.length),_=E.size(p),b=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:s.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:a.length}],w=[{type:12,data:_},{type:12,data:s},{type:6,data:l},{type:12,data:a},...H(e[0].dims,p)],S=$=>`\n      ${$.registerUniforms(b).declareVariables(y,h)}\n        ${Wy(y,h,n)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${h.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${h.setByOffset(\"global_idx\",y.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${s.length}_${a.length}`,inputDependencies:[\"rank\"]},getShaderSource:S,getRunData:()=>({outputs:[f],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:w})}},Ac=(e,t)=>{Ny(e.inputs,t);let n=Vy(e.inputs,t);e.compute(Ly(e.inputs,n),{inputs:[0]})},kc=e=>{let t=e.starts,n=e.ends,r=e.axes;return re({starts:t,ends:n,axes:r})}});var Gy,Hy,Pc,zc,Oc=G(()=>{\"use strict\";te();ae();Ce();ct();ce();Gy=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},Hy=(e,t)=>{let n=e.inputs[0],r=n.dims,o=E.size(r),a=r.length,s=E.normalizeAxis(t.axis,a),d=s<r.length-1,l,p=[];d?(p=Array.from({length:a},(O,M)=>M),p[s]=a-1,p[a-1]=s,l=e.compute(Oe(n,p),{inputs:[n],outputs:[-1]})[0]):l=n;let f=l.dims,h=f[a-1],y=o/h,_=ge(h),b=h/_,w=64;y===1&&(w=256);let S=(O,M)=>M===4?`max(max(${O}.x, ${O}.y), max(${O}.z, ${O}.w))`:M===2?`max(${O}.x, ${O}.y)`:M===3?`max(max(${O}.x, ${O}.y), ${O}.z)`:O,$=P(\"x\",l.dataType,l.dims,_),v=N(\"result\",l.dataType,l.dims,_),T=$.type.value,C=_e(l.dataType)===\"f32\"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,A=O=>`\n      var<workgroup> rowMaxShared : ${T};\n      var<workgroup> rowSumShared : ${T};\n      var<workgroup> threadShared : array<${T}, ${w}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${O.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${O.mainStart(w)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${w};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${C}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${T}(${S(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${T}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${T}(${Ke(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,k=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${w}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:f,dataType:l.dataType}],dispatchGroup:{x:y},programUniforms:[{type:6,data:b}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Oe(k,p),{inputs:[k]})},Pc=(e,t)=>{Gy(e.inputs),Hy(e,t)},zc=e=>re({axis:e.axis})});var Dc,Fy,qy,Ky,Bc,Mc=G(()=>{\"use strict\";te();ae();ce();Dc=e=>Array.from(e.getBigInt64Array(),Number),Fy=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Dc(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},qy=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Ky=(e,t)=>{let n=e[0].dims,r=t??Dc(e[1]),o=qy(n,r),a=E.size(o),s=e[0].dataType,d=P(\"input\",s,n.length),l=N(\"output\",s,o.length),p=f=>`\n      const inputShape = ${d.indices(...n)};\n      ${f.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${f.mainStart()}\n      ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${r}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...H(e[0].dims,o)]}),getShaderSource:p}},Bc=e=>{Fy(e.inputs),e.compute(Ky(e.inputs),{inputs:[0]})}});var jy,Zy,Rc,Uc=G(()=>{\"use strict\";te();ae();ce();jy=(e,t,n,r,o)=>{let a=N(\"output_data\",o,n.length,4),s=P(\"a_data\",t[1].dataType,t[1].dims.length,4),d=P(\"b_data\",t[2].dataType,t[2].dims.length,4),l=P(\"c_data\",t[0].dataType,t[0].dims.length,4),p,f=(h,y,_)=>`select(${y}, ${h}, ${_})`;if(!r)p=a.setByOffset(\"global_idx\",f(s.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let h=(y,_,b=\"\")=>{let w=`a_data[index_a${_}][component_a${_}]`,S=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${a.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${s.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${y}[${_}] = ${b}(${f(w,S,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${h(\"data\",0,\"u32\")}\n            ${h(\"data\",1,\"u32\")}\n            ${h(\"data\",2,\"u32\")}\n            ${h(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${h(\"output_data[global_idx]\",0)}\n            ${h(\"output_data[global_idx]\",1)}\n            ${h(\"output_data[global_idx]\",2)}\n            ${h(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,s,d,a)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},Zy=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,o=e[1].dataType,a=!(E.areEqual(t,n)&&E.areEqual(n,r)),s=t,d=E.size(t);if(a){let p=rt.calcShape(rt.calcShape(t,n,!1),r,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");s=p,d=E.size(s)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>jy(p,e,s,a,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...H(r,t,n,s)]})}},Rc=e=>{e.compute(Zy(e.inputs))}});var Nc,Vc=G(()=>{\"use strict\";_u();qr();$u();Su();dd();wd();xd();Nd();qd();Zd();Xd();nl();al();ul();cl();fl();yl();wl();xl();Cl();Dl();Rl();Nl();Wl();Hl();So();ql();dc();pc();fc();yc();Hr();$c();Sc();Cc();Ec();Oc();Co();Mc();ct();jr();Uc();Nc=new Map([[\"Abs\",[Tu]],[\"Acos\",[Cu]],[\"Acosh\",[Iu]],[\"Add\",[ld]],[\"ArgMax\",[bu,co]],[\"ArgMin\",[yu,co]],[\"Asin\",[Au]],[\"Asinh\",[ku]],[\"Atan\",[Eu]],[\"Atanh\",[Pu]],[\"Attention\",[wu]],[\"AveragePool\",[ec,Jl]],[\"BatchNormalization\",[vu]],[\"BiasAdd\",[xu]],[\"BiasSplitGelu\",[ud]],[\"Cast\",[Ou,zu]],[\"Ceil\",[Bu]],[\"Clip\",[Du]],[\"Concat\",[vd,$d]],[\"Conv\",[wo,_o]],[\"ConvTranspose\",[Fd,Gd]],[\"Cos\",[Mu]],[\"Cosh\",[Ru]],[\"CumSum\",[Kd,jd]],[\"DepthToSpace\",[Qd,Yd]],[\"DequantizeLinear\",[lc,cc]],[\"Div\",[cd]],[\"Einsum\",[tl,rl]],[\"Elu\",[Uu,tr]],[\"Equal\",[pd]],[\"Erf\",[Nu]],[\"Exp\",[Vu]],[\"Expand\",[il]],[\"FastGelu\",[sl]],[\"Floor\",[Wu]],[\"FusedConv\",[wo,_o]],[\"Gather\",[ll,dl]],[\"GatherElements\",[_l,bl]],[\"GatherBlockQuantized\",[hl,gl]],[\"GatherND\",[pl,ml]],[\"Gelu\",[Lu]],[\"Gemm\",[$l,vl]],[\"GlobalAveragePool\",[nc,rc]],[\"GlobalMaxPool\",[uc,sc]],[\"Greater\",[gd]],[\"GreaterOrEqual\",[bd]],[\"GridSample\",[Sl,Tl]],[\"GroupQueryAttention\",[Ol]],[\"HardSigmoid\",[Qu,Zu]],[\"InstanceNormalization\",[Ml]],[\"LayerNormalization\",[Ul]],[\"LeakyRelu\",[Gu,tr]],[\"Less\",[yd]],[\"LessOrEqual\",[_d]],[\"Log\",[id]],[\"MatMul\",[Vl]],[\"MatMulNBits\",[Ll,Gl]],[\"MaxPool\",[ic,ac]],[\"Mul\",[md]],[\"MultiHeadAttention\",[kl,Al]],[\"Neg\",[Fu]],[\"Not\",[Hu]],[\"Pad\",[Fl]],[\"Pow\",[fd]],[\"QuickGelu\",[ad,tr]],[\"Range\",[mc]],[\"Reciprocal\",[qu]],[\"ReduceMin\",[cu]],[\"ReduceMean\",[au]],[\"ReduceMax\",[lu]],[\"ReduceSum\",[mu]],[\"ReduceProd\",[pu]],[\"ReduceL1\",[su]],[\"ReduceL2\",[uu]],[\"ReduceLogSum\",[hu]],[\"ReduceLogSumExp\",[du]],[\"ReduceSumSquare\",[fu]],[\"Relu\",[Ku]],[\"Resize\",[wc,vc]],[\"RotaryEmbedding\",[xc]],[\"ScatterND\",[gc,hc]],[\"Sigmoid\",[ju]],[\"Sin\",[Yu]],[\"Sinh\",[Xu]],[\"Slice\",[Ac,kc]],[\"SkipLayerNormalization\",[Tc]],[\"Split\",[El,Pl]],[\"Sqrt\",[Ju]],[\"Softmax\",[Pc,zc]],[\"Sub\",[hd]],[\"Tan\",[ed]],[\"Tanh\",[rd]],[\"ThresholdedRelu\",[od,tr]],[\"Tile\",[Bc]],[\"Transpose\",[Ks,js]],[\"Where\",[Rc]]])});var on,Wc=G(()=>{\"use strict\";Ge();tt();ce();on=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,n){this.repo.set(t,n)}run(t,n,r,o,a){Ne(t.programInfo.name);let s=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let f of n)l.push({binding:l.length,resource:{buffer:f.buffer}});for(let f of r)l.push({binding:l.length,resource:{buffer:f.buffer}});a&&l.push({binding:l.length,resource:a});let p=s.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let f={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(f)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Be(t.programInfo.name)}dispose(){}build(t,n){Ne(t.name);let r=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(h=>{r.features.has(h.feature)&&o.push(`enable ${h.extension};`)});let s=Fs(n,this.backend.device.limits),d=t.getShaderSource(s),l=`${o.join(`\n`)}\n${s.additionalImplementations}\n${d}`,p=r.createShaderModule({code:l,label:t.name});me(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let f=r.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return Be(t.name),{programInfo:t,computePipeline:f,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(t){let n=typeof t==\"number\"?t:t.x,r=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=a&&r<=a&&o<=a)return[n,r,o];let s=n*r*o,d=Math.ceil(Math.sqrt(s));if(d>a){if(d=Math.ceil(Math.cbrt(s)),d>a)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var Qy,Yy,Io,Ao,an,Lc=G(()=>{\"use strict\";Ge();te();tt();Jn();Ws();Vc();Wc();Qy=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let o=e[r].dataType;switch(t[r]){case\"none\":{n.push(\"\");break}case\"type\":{n.push(`${o}`);break}case\"rank\":{let a=e[r].dims.length;n.push(`${o};${a}`);break}case\"dims\":{let a=e[r].dims.join(\",\");n.push(`${o};${a}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join(\"|\")},Yy=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+=\"[\"+e.shaderCache.hint+\"]\"),r+=\":\"+n+`:${Qy(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,r},Io=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ao=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let n=t.limits;!this.subgroupsSupported||!n.minSubgroupSize||!n.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[n.minSubgroupSize,n.maxSubgroupSize]}},an=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,n){this.env=t;let r=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r},a=s=>n.features.has(s)&&r.push(s)&&!0;a(\"chromium-experimental-timestamp-query-inside-passes\")||a(\"timestamp-query\"),a(\"shader-f16\"),a(\"subgroups\")&&a(\"subgroups-f16\"),this.device=await n.requestDevice(o),this.deviceInfo=new Ao(this.device),this.adapterInfo=new Io(n.info||await n.requestAdapterInfo()),this.gpuDataManager=Vs(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ur(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:n,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),n={};this.queryType===\"at-passes\"&&(n.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(n)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ne(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let n=new BigUint64Array(t.getMappedRange()),r=this.pendingQueries.get(t);for(let o=0;o<n.length/2;o++){let a=r[o],s=a.kernelId,d=this.kernels.get(s),l=d.kernelType,p=d.kernelName,f=a.programName,h=a.inputTensorViews,y=a.outputTensorViews,_=n[o*2],b=n[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let w=Number(_-this.queryTimeBase),S=Number(b-this.queryTimeBase);if(!Number.isSafeInteger(w)||!Number.isSafeInteger(S))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:h.map($=>({dims:$.dims,dataType:_t($.dataType)})),outputsMetadata:y.map($=>({dims:$.dims,dataType:_t($.dataType)})),kernelId:s,kernelType:l,kernelName:p,programName:f,startTime:w,endTime:S});else{let $=\"\";h.forEach((T,C)=>{$+=`input[${C}]: [${T.dims}] | ${_t(T.dataType)}, `});let v=\"\";y.forEach((T,C)=>{v+=`output[${C}]: [${T.dims}] | ${_t(T.dataType)}, `}),console.log(`[profiling] kernel \"${s}|${l}|${p}|${f}\" ${$}${v}execution time: ${S-w} ns`)}vr(\"GPU\",`${f}::${_}::${b}`)}t.unmap(),this.pendingQueries.delete(t)}),Be()}run(t,n,r,o,a,s){Ne(t.name);let d=[];for(let T=0;T<n.length;++T){let C=n[T].data;if(C===0)continue;let A=this.gpuDataManager.get(C);if(!A)throw new Error(`no GPU data for input: ${C}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:f}=t.getRunData(n),h=r.length===0?l.map((T,C)=>C):r;if(h.length!==l.length)throw new Error(`Output size ${h.length} must be equal to ${l.length}.`);let y=[],_=[];for(let T=0;T<l.length;++T){if(!Number.isInteger(h[T])||h[T]<-3||h[T]>=s)throw new Error(`Invalid output index: ${h[T]}`);if(h[T]===-3)continue;let C=h[T]===-1,A=h[T]===-2,k=C||A?a(l[T].dataType,l[T].dims):o(h[T],l[T].dataType,l[T].dims);if(y.push(k),k.data===0)continue;let O=this.gpuDataManager.get(k.data);if(!O)throw new Error(`no GPU data for output: ${k.data}`);if(C&&this.temporaryData.push(O),A){let M=this.kernelPersistentData.get(this.currentKernelId);M||(M=[],this.kernelPersistentData.set(this.currentKernelId,M)),M.push(O)}_.push(O)}if(d.length!==n.length||_.length!==y.length){if(_.length===0)return Be(t.name),y;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let b;if(f){let T=0,C=[];f.forEach(M=>{let V=typeof M.data==\"number\"?[M.data]:M.data;if(V.length===0)return;let F=M.type===10?2:4,j,ne;M.type===10?(ne=V.length>4?16:V.length>2?8:V.length*F,j=V.length>4?16:F*V.length):(ne=V.length<=2?V.length*F:16,j=16),T=Math.ceil(T/ne)*ne,C.push(T);let W=M.type===10?8:4;T+=V.length>4?Math.ceil(V.length/W)*j:V.length*F});let A=16;T=Math.ceil(T/A)*A;let k=new ArrayBuffer(T);f.forEach((M,V)=>{let F=C[V],j=typeof M.data==\"number\"?[M.data]:M.data;if(M.type===6)new Int32Array(k,F,j.length).set(j);else if(M.type===12)new Uint32Array(k,F,j.length).set(j);else if(M.type===10)new Uint16Array(k,F,j.length).set(j);else if(M.type===1)new Float32Array(k,F,j.length).set(j);else throw new Error(`Unsupported uniform type: ${_t(M.type)}`)});let O=this.gpuDataManager.create(T,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(O.buffer,0,k,0,T),this.gpuDataManager.release(O.id),b={offset:0,size:T,buffer:O.buffer}}let w=this.programManager.normalizeDispatchGroupSize(p),S=w[1]===1&&w[2]===1,$=Yy(t,n,S),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,w),this.programManager.setArtifact($,v),me(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),f&&v.uniformVariablesInfo){if(f.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${f.length} in program \"${v.programInfo.name}\".`);for(let T=0;T<f.length;T++){let C=f[T],A=C.type,k=typeof C.data==\"number\"?1:C.data.length,[O,M]=v.uniformVariablesInfo[T];if(A!==O||k!==M)throw new Error(`Uniform variable ${T} mismatch: expect type ${O} with size ${M}, got type ${A} with size ${k} in program \"${v.programInfo.name}\".`)}}if(me(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${w[0]}x${w[1]}x${w[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let T={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:n,outputTensorViews:y};this.pendingKernels.push(T),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(T)}return this.programManager.run(v,d,_,w,b),Be(t.name),y}upload(t,n){this.gpuDataManager.upload(t,n)}memcpy(t,n){this.gpuDataManager.memcpy(t,n)}async download(t,n){await this.gpuDataManager.download(t,n)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,n,r,o){let a=Nc.get(t);if(!a)throw new Error(`kernel not implemented: ${t}`);let s={kernelType:t,kernelName:o,kernelEntry:a[0],attributes:[a[1],r]};this.kernels.set(n,s)}releaseKernel(t){let n=this.kernelPersistentData.get(t);if(n){for(let r of n)this.gpuDataManager.release(r.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,n,r){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let a=o.kernelType,s=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${a}] ${s}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),me(\"info\",()=>`[WebGPU] Start to run kernel \"[${a}] ${s}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(n,l[1]),0}catch(f){return r.push(Promise.resolve(`[WebGPU] Kernel \"[${a}] ${s}\" failed. ${f}`)),1}finally{p&&r.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel \"[${a}] ${s}\": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,n,r,o){let a=this.sessionExternalDataMapping.get(t);a||(a=new Map,this.sessionExternalDataMapping.set(t,a));let s=a.get(n),d=this.gpuDataManager.registerExternalBuffer(r,o,s);return a.set(n,[d,r]),d}unregisterBuffers(t){let n=this.sessionExternalDataMapping.get(t);n&&(n.forEach(r=>this.gpuDataManager.unregisterExternalBuffer(r[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let n=this.gpuDataManager.get(t);if(!n)throw new Error(`no GPU data for buffer: ${t}`);return n.buffer}createDownloader(t,n,r){return async()=>{let o=await no(this,t,n);return Nr(o.buffer,r)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){me(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){me(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){me(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),n=this.capturedPendingKernels.get(this.currentSessionId),r=t.length;this.pendingKernels=[];for(let o=0;o<r;o++){let a=this.getComputePassEncoder(),s=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),a.setPipeline(s.computePipeline),a.setBindGroup(0,s.bindGroup),a.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(n[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Xy,Gc,Jy,Hc,sn,un,ko,Fc,qc=G(()=>{\"use strict\";tt();Xy=1,Gc=()=>Xy++,Jy=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),Hc=(e,t)=>{let n=Jy.get(e);if(!n)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((r,o)=>r*o)*n/8):0},sn=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Hc(this.dataType,this.tensorShape)}destroy(){me(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,n,r){return this.mlContext===t&&this.dataType===n&&this.tensorShape.length===r.length&&this.tensorShape.every((o,a)=>o===r[a])}},un=class{constructor(t,n){this.tensorManager=t;this.wrapper=n}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,n,r,o){let a=this.tensorManager.getMLContext(t);if(this.wrapper){if(this.wrapper.canReuseTensor(a,n,r))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==Hc(n,r))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let s=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,n,r,s,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else me(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},ko=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(t){let n=this.backend.getMLContext(t);if(!n)throw new Error(\"MLContext not found for session.\");return n}reserveTensorId(){let t=Gc();return this.tensorTrackersById.set(t,new un(this)),t}releaseTensorId(t){let n=this.tensorTrackersById.get(t);n&&(this.tensorTrackersById.delete(t),n.tensorWrapper&&this.releaseTensor(n.tensorWrapper))}async ensureTensor(t,n,r,o,a){me(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${n}, dataType: ${r}, shape: ${o}, copyOld: ${a}}`);let s=this.tensorTrackersById.get(n);if(!s)throw new Error(\"Tensor not found.\");return s.ensureTensor(t,r,o,a)}upload(t,n){let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");r.upload(n)}async download(t,n){me(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${n?.byteLength}}`);let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");return r.download(n)}releaseTensorsForSession(t){for(let n of this.freeTensors)n.sessionId===t&&n.destroy();this.freeTensors=this.freeTensors.filter(n=>n.sessionId!==t)}registerTensor(t,n,r,o){let a=this.getMLContext(t),s=Gc(),d=new sn({sessionId:t,context:a,tensor:n,dataType:r,shape:o});return this.tensorTrackersById.set(s,new un(this,d)),this.externalTensors.add(d),s}async getCachedTensor(t,n,r,o,a,s){let d=this.getMLContext(t);for(let[p,f]of this.freeTensors.entries())if(f.canReuseTensor(d,n,r)){me(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${n}, shape: ${r}}`);let h=this.freeTensors.splice(p,1)[0];return h.sessionId=t,h}me(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${n}, shape: ${r}}`);let l=await d.createTensor({dataType:n,shape:r,dimensions:r,usage:o,writable:a,readable:s});return new sn({sessionId:t,context:d,tensor:l,dataType:n,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},Fc=(...e)=>new ko(...e)});var Eo,eb,dn,Kc=G(()=>{\"use strict\";te();bt();Jn();qc();tt();Eo=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),eb=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((o,a)=>o===r[a]&&e[o]===t[o])},dn=class{constructor(t){this.tensorManager=Fc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.temporaryGraphInputs=[];this.temporarySessionTensorIds=new Map;Ur(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){me(\"verbose\",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){me(\"verbose\",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let n=this.temporarySessionTensorIds.get(t);if(n){for(let r of n)me(\"verbose\",()=>`[WebNN] releasing temporary tensor {tensorId: ${r}}`),this.tensorManager.releaseTensorId(r);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let r=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let r=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let n=this.mlContextCache.findIndex(r=>eb(r.options,t));if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:r}),r}}registerMLContext(t,n){this.mlContextBySessionId.set(t,n);let r=this.sessionIdsByMLContext.get(n);r||(r=new Set,this.sessionIdsByMLContext.set(n,r)),r.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t);let n=this.mlContextBySessionId.get(t);if(!n)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let r=this.sessionIdsByMLContext.get(n);if(r.delete(t),r.size===0){this.sessionIdsByMLContext.delete(n);let o=this.mlContextCache.findIndex(a=>a.mlContext===n);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){me(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,n,r,o,a){let s=Eo.get(r);if(!s)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,n,s,o,a)}async createTemporaryTensor(t,n,r){me(\"verbose\",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${n}, shape: ${r}}`);let o=Eo.get(n);if(!o)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,a,o,r,!1);let s=this.temporarySessionTensorIds.get(t);return s?s.push(a):this.temporarySessionTensorIds.set(t,[a]),a}uploadTensor(t,n){if(!Ie().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");me(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${n.byteLength}}`),this.tensorManager.upload(t,n)}async downloadTensor(t,n){return this.tensorManager.download(t,n)}createMLTensorDownloader(t,n){return async()=>{let r=await this.tensorManager.download(t);return Nr(r,n)}}registerMLTensor(t,n,r,o){let a=Eo.get(r);if(!a)throw new Error(`Unsupported ONNX data type: ${r}`);let s=this.tensorManager.registerTensor(t,n,a,o);return me(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${n}, dataType: ${a}, dimensions: ${o}} -> {tensorId: ${s}}`),s}registerMLConstant(t,n,r,o,a,s){if(!s)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=s.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(n+r>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(n,n+r).buffer,f;switch(a.dataType){case\"float32\":f=new Float32Array(p);break;case\"float16\":f=new Uint16Array(p);break;case\"int32\":f=new Int32Array(p);break;case\"uint32\":f=new Uint32Array(p);break;case\"int64\":f=new BigInt64Array(p);break;case\"uint64\":f=new BigUint64Array(p);break;case\"int8\":f=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":f=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return me(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}}`),o.constant(a,f)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}isGraphInput(t,n){let r=this.sessionGraphInputs.get(t);return r?r.includes(n):!1}flush(){}}});var jc={};Zt(jc,{init:()=>tb});var ir,Po,tb,Zc=G(()=>{\"use strict\";te();Lc();tt();ae();Kc();ir=class e{constructor(t,n,r,o){this.module=t;this.dataType=n;this.data=r;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(E.size(t)!==E.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},Po=class{constructor(t,n,r){this.module=t;this.backend=n;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=n.adapterInfo,this.deviceInfo=n.deviceInfo;let o=t.PTR_SIZE,a=r/t.PTR_SIZE,s=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*a++,s));let d=Number(t.getValue(o*a++,s));this.outputCount=Number(t.getValue(o*a++,s)),this.customDataOffset=Number(t.getValue(o*a++,\"*\")),this.customDataSize=Number(t.getValue(o*a++,s));let l=[];for(let p=0;p<d;p++){let f=Number(t.getValue(o*a++,s)),h=Number(t.getValue(o*a++,\"*\")),y=Number(t.getValue(o*a++,s)),_=[];for(let b=0;b<y;b++)_.push(Number(t.getValue(o*a++,s)));l.push(new ir(t,f,h,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,n){let r=n?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=n?.outputs??[],a=(d,l,p)=>new ir(this.module,l,this.output(d,p),p),s=(d,l)=>{let p=wt(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let f=p>0?this.backend.gpuDataManager.create(p).id:0;return new ir(this.module,d,f,l)};return this.backend.run(t,r,o,a,s,this.outputCount)}output(t,n){let r=this.module.stackSave();try{let o=this.module.PTR_SIZE,a=o===4?\"i32\":\"i64\",s=this.module.stackAlloc((1+n.length)*o);this.module.setValue(s,n.length,a);for(let d=0;d<n.length;d++)this.module.setValue(s+o*(d+1),n[d],a);return this.module._JsepOutput(this.opKernelContext,t,s)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(r)}}},tb=async(e,t,n,r)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let a=new an;await a.initialize(n,r),o(\"webgpu\",[a,s=>a.alloc(Number(s)),s=>a.free(s),(s,d,l,p=!1)=>{if(p)me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(s)}, dst=${Number(d)}, size=${Number(l)}`),a.memcpy(Number(s),Number(d));else{me(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(s)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let f=t.HEAPU8.subarray(Number(s>>>0),Number(s>>>0)+Number(l));a.upload(Number(d),f)}},async(s,d,l)=>{me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${d}, size=${l}`),await a.download(Number(s),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(s,d,l)=>a.createKernel(s,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),s=>a.releaseKernel(s),(s,d,l,p)=>{me(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${s}, contextDataOffset=${d}`);let f=new Po(t,a,Number(d));return a.computeKernel(Number(s),f,p)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let a=new dn(n);o(\"webnn\",[a,()=>a.reserveTensorId(),s=>a.releaseTensorId(s),async(s,d,l,p,f)=>a.ensureTensor(s,d,l,p,f),(s,d)=>{a.uploadTensor(s,d)},async(s,d)=>a.downloadTensor(s,d)])}}});var rb,Cr,Ir,zt,nb,Yt,Ar,kr,Qc,Er,Pr,zr,qn=G(()=>{\"use strict\";zs();Ds();te();bt();Dr();Xn();rb=(e,t)=>{Ie()._OrtInit(e,t)!==0&&he(\"Can't initialize onnxruntime.\")},Cr=async e=>{rb(e.wasm.numThreads,Jt(e.logLevel))},Ir=async(e,t)=>{{let n=(Zc(),br(jc)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let r=e.webgpu.adapter;if(r){if(typeof r.limits!=\"object\"||typeof r.features!=\"object\"||typeof r.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let a=e.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${a}\"`);if(r=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:a}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await n(\"webgpu\",Ie(),e,r)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await n(\"webnn\",Ie(),e)}}},zt=new Map,nb=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetInputOutputCount(e,o,o+r)!==0&&he(\"Can't get session input/output count.\");let s=r===4?\"i32\":\"i64\";return[Number(t.getValue(o,s)),Number(t.getValue(o+r,s))]}finally{t.stackRestore(n)}},Yt=e=>{let t=Ie(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Ar=async(e,t)=>{let n,r,o=Ie();Array.isArray(e)?[n,r]=e:e.buffer===o.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Yt(e);let a=0,s=0,d=0,l=[],p=[],f=[];try{if([s,l]=Os(t),t?.externalData&&o.mountExternalData){let v=[];for(let T of t.externalData){let C=typeof T==\"string\"?T:T.path;v.push(er(typeof T==\"string\"?T:T.data).then(A=>{o.mountExternalData(C,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let C=v,A=C?.context,k=C?.gpuDevice,O=C?.deviceType,M=C?.powerPreference;A?o.currentContext=A:k?o.currentContext=await o.jsepCreateMLContext(k):o.currentContext=await o.jsepCreateMLContext({deviceType:O,powerPreference:M})}else o.currentContext=await o.jsepCreateMLContext();break}a=await o._OrtCreateSession(n,r,s),a===0&&he(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(a,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[h,y]=nb(a),_=!!t?.enableGraphCapture,b=[],w=[],S=[];for(let v=0;v<h;v++){let T=o._OrtGetInputName(a,v);T===0&&he(\"Can't get an input name.\"),p.push(T),b.push(o.UTF8ToString(T))}for(let v=0;v<y;v++){let T=o._OrtGetOutputName(a,v);T===0&&he(\"Can't get an output name.\"),f.push(T);let C=o.UTF8ToString(T);w.push(C);{if(_&&t?.preferredOutputLocation===void 0){S.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[C]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);S.push(A)}}let $=null;return S.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(a),d===0&&he(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:S,outputPreferredLocationsEncoded:S.map(v=>Yn(v))}),zt.set(a,[a,p,f,$,_,!1]),[a,b,w]}catch(h){throw p.forEach(y=>o._OrtFree(y)),f.forEach(y=>o._OrtFree(y)),d!==0&&o._OrtReleaseBinding(d)!==0&&he(\"Can't release IO binding.\"),a!==0&&o._OrtReleaseSession(a)!==0&&he(\"Can't release session.\"),h}finally{o._free(n),s!==0&&o._OrtReleaseSessionOptions(s)!==0&&he(\"Can't release session options.\"),l.forEach(h=>o._free(h)),o.unmountExternalData?.()}},kr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,o,a,s,d]=n;s&&(d&&t._OrtClearBoundOutputs(s.handle)!==0&&he(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(s.handle)!==0&&he(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),a.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(r)!==0&&he(\"Can't release session.\"),zt.delete(e)},Qc=async(e,t,n,r,o,a=!1)=>{if(!e){t.push(0);return}let s=Ie(),d=s.PTR_SIZE,l=e[0],p=e[1],f=e[3],h=f,y,_;if(l===\"string\"&&(f===\"gpu-buffer\"||f===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(a&&f!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(f===\"gpu-buffer\"){let S=e[2].gpuBuffer;_=wt(Rt(l),p);let $=s.jsepRegisterBuffer;if(!$)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');y=$(r,o,S,_)}else if(f===\"ml-tensor\"){let S=e[2].mlTensor;_=wt(Rt(l),p);let $=s.jsepRegisterMLTensor;if(!$)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');y=$(r,S,Rt(l),p)}else{let S=e[2];if(Array.isArray(S)){_=d*S.length,y=s._malloc(_),n.push(y);for(let $=0;$<S.length;$++){if(typeof S[$]!=\"string\")throw new TypeError(`tensor data at index ${$} is not a string`);s.setValue(y+$*d,Pe(S[$],n),\"*\")}}else{let $=s.jsepIsGraphInput;if(l!==\"string\"&&$){let v=s._OrtGetInputName(r,o),T=s.UTF8ToString(v);if($(r,T)){let C=Rt(l);_=wt(C,p),h=\"ml-tensor\";let A=s.jsepCreateTemporaryTensor,k=s.jsepUploadTensor;if(!A||!k)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');let O=await A(r,C,p);k(O,new Uint8Array(S.buffer,S.byteOffset,S.byteLength)),y=O}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}}let b=s.stackSave(),w=s.stackAlloc(4*p.length);try{p.forEach(($,v)=>s.setValue(w+v*d,$,d===4?\"i32\":\"i64\"));let S=s._OrtCreateTensor(Rt(l),y,_,w,p.length,Yn(h));S===0&&he(`Can't create tensor for input/output. session=${r}, index=${o}.`),t.push(S)}finally{s.stackRestore(b)}},Er=async(e,t,n,r,o,a)=>{let s=Ie(),d=s.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],f=l[1],h=l[2],y=l[3],_=l[4],b=l[5],w=t.length,S=r.length,$=0,v=[],T=[],C=[],A=[],k=s.stackSave(),O=s.stackAlloc(w*d),M=s.stackAlloc(w*d),V=s.stackAlloc(S*d),F=s.stackAlloc(S*d);try{[$,v]=Ps(a);for(let W=0;W<w;W++)await Qc(n[W],T,A,e,t[W],_);for(let W=0;W<S;W++)await Qc(o[W],C,A,e,w+r[W],_);for(let W=0;W<w;W++)s.setValue(O+W*d,T[W],\"*\"),s.setValue(M+W*d,f[t[W]],\"*\");for(let W=0;W<S;W++)s.setValue(V+W*d,C[W],\"*\"),s.setValue(F+W*d,h[r[W]],\"*\");if(y&&!b){let{handle:W,outputPreferredLocations:J,outputPreferredLocationsEncoded:ve}=y;if(f.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${f.length}).`);for(let Q=0;Q<w;Q++){let ee=t[Q];await s._OrtBindInput(W,f[ee],T[Q])!==0&&he(`Can't bind input[${Q}] for session=${e}.`)}for(let Q=0;Q<S;Q++){let ee=r[Q];o[Q]?.[3]?s._OrtBindOutput(W,h[ee],C[Q],0)!==0&&he(`Can't bind pre-allocated output[${Q}] for session=${e}.`):s._OrtBindOutput(W,h[ee],0,ve[ee])!==0&&he(`Can't bind output[${Q}] to ${J[Q]} for session=${e}.`)}zt.set(e,[p,f,h,y,_,!0])}s.jsepOnRunStart?.(p);let j;y?j=await s._OrtRunWithBinding(p,y.handle,S,V,$):j=await s._OrtRun(p,M,O,w,F,S,V,$),j!==0&&he(\"failed to call OrtRun().\");let ne=[];for(let W=0;W<S;W++){let J=Number(s.getValue(V+W*d,\"*\"));if(J===C[W]){ne.push(o[W]);continue}let ve=s.stackSave(),Q=s.stackAlloc(4*d),ee=!1,le,Z=0;try{s._OrtGetTensorData(J,Q,Q+d,Q+2*d,Q+3*d)!==0&&he(`Can't access output tensor data on index ${W}.`);let ke=d===4?\"i32\":\"i64\",Se=Number(s.getValue(Q,ke));Z=s.getValue(Q+d,\"*\");let D=s.getValue(Q+d*2,\"*\"),R=Number(s.getValue(Q+d*3,ke)),Y=[];for(let xe=0;xe<R;xe++)Y.push(Number(s.getValue(D+xe*d,ke)));s._OrtFree(D)!==0&&he(\"Can't free memory for tensor dims.\");let fe=Y.reduce((xe,be)=>xe*be,1);le=_t(Se);let Fe=y?.outputPreferredLocations[r[W]];if(le===\"string\"){if(Fe===\"gpu-buffer\"||Fe===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let xe=[];for(let be=0;be<fe;be++){let Ye=s.getValue(Z+be*d,\"*\"),Gt=s.getValue(Z+(be+1)*d,\"*\"),xt=be===fe-1?void 0:Gt-Ye;xe.push(s.UTF8ToString(Ye,xt))}ne.push([le,Y,xe,\"cpu\"])}else if(Fe===\"gpu-buffer\"&&fe>0){let xe=s.jsepGetBuffer;if(!xe)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let be=xe(Z),Ye=wt(Se,fe);if(Ye===void 0||!Mr(le))throw new Error(`Unsupported data type: ${le}`);ee=!0,ne.push([le,Y,{gpuBuffer:be,download:s.jsepCreateDownloader(be,Ye,le),dispose:()=>{s._OrtReleaseTensor(J)!==0&&he(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(Fe===\"ml-tensor\"&&fe>0){let xe=s.jsepEnsureTensor;if(!xe)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(wt(Se,fe)===void 0||!Rr(le))throw new Error(`Unsupported data type: ${le}`);let Ye=await xe(e,Z,Se,Y,!1);ee=!0,ne.push([le,Y,{mlTensor:Ye,download:s.jsepCreateMLTensorDownloader(Z,le),dispose:()=>{s.jsepReleaseTensorId(Z),s._OrtReleaseTensor(J)}},\"ml-tensor\"])}else{let xe=Br(le),be=new xe(fe);new Uint8Array(be.buffer,be.byteOffset,be.byteLength).set(s.HEAPU8.subarray(Z,Z+be.byteLength)),ne.push([le,Y,be,\"cpu\"])}}finally{s.stackRestore(ve),le===\"string\"&&Z&&s._free(Z),ee||s._OrtReleaseTensor(J),s.jsepOnRunEnd?.(p)}}return y&&!_&&(s._OrtClearBoundOutputs(y.handle)!==0&&he(\"Can't clear bound outputs.\"),zt.set(e,[p,f,h,y,_,!1])),ne}finally{s.stackRestore(k),T.forEach(j=>s._OrtReleaseTensor(j)),C.forEach(j=>s._OrtReleaseTensor(j)),A.forEach(j=>s._free(j)),$!==0&&s._OrtReleaseRunOptions($),v.forEach(j=>s._free(j))}},Pr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(\"invalid session id\");let r=n[0],o=t._OrtEndProfiling(r);o===0&&he(\"Can't get an profile file name.\"),t._OrtFree(o)},zr=e=>{let t=[];for(let n of e){let r=n[2];!Array.isArray(r)&&\"buffer\"in r&&t.push(r.buffer)}return t}});var Ot,He,ar,cn,pn,ln,zo,Oo,Wt,Lt,ib,Yc,Xc,Jc,ep,tp,rp,np,Do=G(()=>{\"use strict\";Ge();qn();bt();Sr();Ot=()=>!!we.wasm.proxy&&typeof document<\"u\",ar=!1,cn=!1,pn=!1,Oo=new Map,Wt=(e,t)=>{let n=Oo.get(e);n?n.push(t):Oo.set(e,[t])},Lt=()=>{if(ar||!cn||pn||!He)throw new Error(\"worker not ready\")},ib=e=>{switch(e.data.type){case\"init-wasm\":ar=!1,e.data.err?(pn=!0,zo[1](e.data.err)):(cn=!0,zo[0]()),ln&&(URL.revokeObjectURL(ln),ln=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=Oo.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},Yc=async()=>{if(!cn){if(ar)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(pn)throw new Error(\"previous call to 'initWasm()' failed.\");if(ar=!0,Ot())return new Promise((e,t)=>{He?.terminate(),As().then(([n,r])=>{try{He=r,He.onerror=a=>t(a),He.onmessage=ib,zo=[e,t];let o={type:\"init-wasm\",in:we};!o.in.wasm.wasmPaths&&(n||\"file:///Users/evobidev/Desktop/React/onnx-ml/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href}),He.postMessage(o),ln=n}catch(o){t(o)}},t)});try{await Tr(we.wasm),await Cr(we),cn=!0}catch(e){throw pn=!0,e}finally{ar=!1}}},Xc=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"init-ep\",[t,n]);let r={type:\"init-ep\",in:{epName:e,env:we}};He.postMessage(r)});await Ir(we,e)},Jc=async e=>Ot()?(Lt(),new Promise((t,n)=>{Wt(\"copy-from\",[t,n]);let r={type:\"copy-from\",in:{buffer:e}};He.postMessage(r,[e.buffer])})):Yt(e),ep=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Lt(),new Promise((n,r)=>{Wt(\"create\",[n,r]);let o={type:\"create\",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),He.postMessage(o,a)})}else return Ar(e,t)},tp=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"release\",[t,n]);let r={type:\"release\",in:e};He.postMessage(r)});kr(e)},rp=async(e,t,n,r,o,a)=>{if(Ot()){if(n.some(s=>s[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(s=>s))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Lt(),new Promise((s,d)=>{Wt(\"run\",[s,d]);let l=n,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:r,options:a}};He.postMessage(p,zr(l))})}else return Er(e,t,n,r,o,a)},np=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"end-profiling\",[t,n]);let r={type:\"end-profiling\",in:e};He.postMessage(r)});Pr(e)}});var op,ab,mn,ip=G(()=>{\"use strict\";Ge();Do();te();xr();Xn();op=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ab=e=>{switch(e[3]){case\"cpu\":return new qe(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Mr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:o}=e[2];return qe.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Rr(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:o}=e[2];return qe.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},mn=class{async fetchModelAndCopyToWasmMemory(t){return Jc(await er(t))}async loadModel(t,n){Ne();let r;typeof t==\"string\"?r=await this.fetchModelAndCopyToWasmMemory(t):r=t,[this.sessionId,this.inputNames,this.outputNames]=await ep(r,n),Be()}async dispose(){return tp(this.sessionId)}async run(t,n,r){Ne();let o=[],a=[];Object.entries(t).forEach(y=>{let _=y[0],b=y[1],w=this.inputNames.indexOf(_);if(w===-1)throw new Error(`invalid input '${_}'`);o.push(b),a.push(w)});let s=[],d=[];Object.entries(n).forEach(y=>{let _=y[0],b=y[1],w=this.outputNames.indexOf(_);if(w===-1)throw new Error(`invalid output '${_}'`);s.push(b),d.push(w)});let l=o.map((y,_)=>op(y,()=>`input \"${this.inputNames[a[_]]}\"`)),p=s.map((y,_)=>y?op(y,()=>`output \"${this.outputNames[d[_]]}\"`):null),f=await rp(this.sessionId,a,l,d,p,r),h={};for(let y=0;y<f.length;y++)h[this.outputNames[d[y]]]=s[y]??ab(f[y]);return Be(),h}startProfiling(){}endProfiling(){np(this.sessionId)}}});var sp={};Zt(sp,{OnnxruntimeWebAssemblyBackend:()=>fn,initializeFlags:()=>ap,wasmBackend:()=>sb});var ap,fn,sb,up=G(()=>{\"use strict\";Ge();Do();ip();ap=()=>{if((typeof we.wasm.initTimeout!=\"number\"||we.wasm.initTimeout<0)&&(we.wasm.initTimeout=0),we.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof we.wasm.proxy!=\"boolean\"&&(we.wasm.proxy=!1),typeof we.wasm.trace!=\"boolean\"&&(we.wasm.trace=!1),typeof we.wasm.numThreads!=\"number\"||!Number.isInteger(we.wasm.numThreads)||we.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)we.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Nn(\"node:os\").cpus().length:navigator.hardwareConcurrency;we.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},fn=class{async init(t){ap(),await Yc(),await Xc(t)}async createInferenceSessionHandler(t,n){let r=new mn;return await r.loadModel(t,n),Promise.resolve(r)}},sb=new fn});Ge();Ge();Ge();var hs=\"1.21.0\";var lT=Fn;{let e=(up(),br(sp)).wasmBackend;Ct(\"webgpu\",e,5),Ct(\"webnn\",e,5),Ct(\"cpu\",e,10),Ct(\"wasm\",e,10)}Object.defineProperty(we.versions,\"web\",{value:hs,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQuYnVuZGxlLm1pbi5tanM/ZDE2YyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDLGtDQUFrQyx1Q0FBdUMsb0VBQW9FLDZDQUE2QyxpQkFBaUIsMkRBQTJELDJEQUEyRCxFQUFFLG1DQUFtQyxlQUFlLHVCQUF1Qix1QkFBdUIsRUFBRSxnQkFBZ0IsZ0dBQWdHLG1EQUFtRCxFQUFFLFVBQVUsa0JBQWtCLGVBQWUsU0FBUyxLQUFLLDZCQUE2QixhQUFhLDhCQUE4QixxRkFBcUYsZ0JBQWdCLHdCQUF3QixxQkFBcUIsRUFBRSxLQUFLLHVCQUF1Qiw2RUFBNkUsRUFBRSxtQkFBbUIsRUFBRSxHQUFHLFNBQVMsb0JBQW9CLHVCQUF1QixZQUFZLFlBQVksa0NBQWtDLGlCQUFpQixPQUFPLFdBQVcsT0FBTywyQ0FBMkMsY0FBYyxnQkFBZ0IsaUNBQWlDLGtDQUFrQyw2QkFBNkIsc0JBQXNCLElBQUksMkZBQTJGLFNBQVMsc0JBQXNCLEVBQUUsd0JBQXdCLFFBQVEsdUJBQXVCLGNBQWMsNEdBQTRHLGdCQUFnQixrQkFBa0IsMkJBQTJCLGFBQWEsNkJBQTZCLDBEQUEwRCxhQUFhLE9BQU8sSUFBSSxNQUFNLGNBQWMsR0FBRyxRQUFRLGFBQWEsMkVBQTJFLEVBQUUsc0RBQXNELEVBQUUsR0FBRyxzREFBc0Qsc0JBQXNCLHVEQUF1RCxJQUFJLEVBQUUsY0FBYyxhQUFhLEtBQUssRUFBRSxpQkFBaUIsYUFBYSxZQUFZLEVBQUUsb0JBQW9CLGFBQWEsS0FBSyxpQkFBaUIsT0FBTyxTQUFTLFVBQVUsV0FBVyxVQUFVLGlCQUFpQixlQUFlLGtJQUFrSSxFQUFFLEdBQUcsTUFBTSxnQkFBZ0IsWUFBWSxxQ0FBcUMsY0FBYyxFQUFFLEVBQUUsaUJBQWlCLGFBQWEsS0FBSyxNQUFNLEVBQUUsb0JBQW9CLGFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQuYnVuZGxlLm1pbi5tanM/Y2E2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBVbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIEFmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIGtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBFZj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBObj0oZT0+dHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0eXBlb2YgUHJveHk8XCJ1XCI/bmV3IFByb3h5KGUse2dldDoodCxuKT0+KHR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dClbbl19KTplKShmdW5jdGlvbihlKXtpZih0eXBlb2YgcmVxdWlyZTxcInVcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrZSsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyIEc9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgWnQ9KGUsdCk9Pntmb3IodmFyIG4gaW4gdClVbihlLG4se2dldDp0W25dLGVudW1lcmFibGU6ITB9KX0sUGY9KGUsdCxuLHIpPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBvIG9mIGtmKHQpKSFFZi5jYWxsKGUsbykmJm8hPT1uJiZVbihlLG8se2dldDooKT0+dFtvXSxlbnVtZXJhYmxlOiEocj1BZih0LG8pKXx8ci5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciBicj1lPT5QZihVbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgX3IsVHQsQ3QsemYsV2EsVm49RygoKT0+e1widXNlIHN0cmljdFwiO19yPW5ldyBNYXAsVHQ9W10sQ3Q9KGUsdCxuKT0+e2lmKHQmJnR5cGVvZiB0LmluaXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIil7bGV0IHI9X3IuZ2V0KGUpO2lmKHI9PT12b2lkIDApX3Iuc2V0KGUse2JhY2tlbmQ6dCxwcmlvcml0eTpufSk7ZWxzZXtpZihyLnByaW9yaXR5Pm4pcmV0dXJuO2lmKHIucHJpb3JpdHk9PT1uJiZyLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtufWApfWlmKG4+PTApe2xldCBvPVR0LmluZGV4T2YoZSk7byE9PS0xJiZUdC5zcGxpY2UobywxKTtmb3IobGV0IGE9MDthPFR0Lmxlbmd0aDthKyspaWYoX3IuZ2V0KFR0W2FdKS5wcmlvcml0eTw9bil7VHQuc3BsaWNlKGEsMCxlKTtyZXR1cm59VHQucHVzaChlKX1yZXR1cm59dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIil9LHpmPWFzeW5jIGU9PntsZXQgdD1fci5nZXQoZSk7aWYoIXQpcmV0dXJuXCJiYWNrZW5kIG5vdCBmb3VuZC5cIjtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKXJldHVybiB0LmVycm9yO3tsZXQgbj0hIXQuaW5pdFByb21pc2U7dHJ5e3JldHVybiBufHwodC5pbml0UHJvbWlzZT10LmJhY2tlbmQuaW5pdChlKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChyKXtyZXR1cm4gbnx8KHQuZXJyb3I9YCR7cn1gLHQuYWJvcnRlZD0hMCksdC5lcnJvcn1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19LFdhPWFzeW5jIGU9PntsZXQgdD1lLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10sbj10Lm1hcChsPT50eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkscj1uLmxlbmd0aD09PTA/VHQ6bixvLGE9W10scz1uZXcgU2V0O2ZvcihsZXQgbCBvZiByKXtsZXQgcD1hd2FpdCB6ZihsKTt0eXBlb2YgcD09XCJzdHJpbmdcIj9hLnB1c2goe25hbWU6bCxlcnI6cH0pOihvfHwobz1wKSxvPT09cCYmcy5hZGQobCkpfWlmKCFvKXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHthLm1hcChsPT5gWyR7bC5uYW1lfV0gJHtsLmVycn1gKS5qb2luKFwiLCBcIil9YCk7Zm9yKGxldHtuYW1lOmwsZXJyOnB9b2YgYSluLmluY2x1ZGVzKGwpJiZjb25zb2xlLndhcm4oYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke2x9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke3B9YCk7bGV0IGQ9dC5maWx0ZXIobD0+cy5oYXModHlwZW9mIGw9PVwic3RyaW5nXCI/bDpsLm5hbWUpKTtyZXR1cm5bbyxuZXcgUHJveHkoZSx7Z2V0OihsLHApPT5wPT09XCJleGVjdXRpb25Qcm92aWRlcnNcIj9kOlJlZmxlY3QuZ2V0KGwscCl9KV19fSk7dmFyIExhPUcoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpfSk7dmFyIEdhLEhhPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHYT1cIjEuMjEuMFwifSk7dmFyIEZhLFVlLFduPUcoKCk9PntcInVzZSBzdHJpY3RcIjtIYSgpO0ZhPVwid2FybmluZ1wiLFVlPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOkdhfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7RmE9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiBGYX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShVZSxcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciB3ZSxxYT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt3ZT1VZX0pO3ZhciBLYSxqYSxaYT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S2E9KGUsdCk9PntsZXQgbj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7bi53aWR0aD1lLmRpbXNbM10sbi5oZWlnaHQ9ZS5kaW1zWzJdO2xldCByPW4uZ2V0Q29udGV4dChcIjJkXCIpO2lmKHIhPW51bGwpe2xldCBvLGE7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxhPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGE9ZS5kaW1zWzJdKTtsZXQgcz10Py5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixkPXQ/Lm5vcm0sbCxwO2Q9PT12b2lkIDB8fGQubWVhbj09PXZvaWQgMD9sPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBkLm1lYW49PVwibnVtYmVyXCI/bD1bZC5tZWFuLGQubWVhbixkLm1lYW4sZC5tZWFuXToobD1bZC5tZWFuWzBdLGQubWVhblsxXSxkLm1lYW5bMl0sMF0sZC5tZWFuWzNdIT09dm9pZCAwJiYobFszXT1kLm1lYW5bM10pKSxkPT09dm9pZCAwfHxkLmJpYXM9PT12b2lkIDA/cD1bMCwwLDAsMF06dHlwZW9mIGQuYmlhcz09XCJudW1iZXJcIj9wPVtkLmJpYXMsZC5iaWFzLGQuYmlhcyxkLmJpYXNdOihwPVtkLmJpYXNbMF0sZC5iaWFzWzFdLGQuYmlhc1syXSwwXSxkLmJpYXNbM10hPT12b2lkIDAmJihwWzNdPWQuYmlhc1szXSkpO2xldCBmPWEqbyxoPTAseT1mLF89ZioyLGI9LTE7cz09PVwiUkdCQVwiPyhoPTAseT1mLF89ZioyLGI9ZiozKTpzPT09XCJSR0JcIj8oaD0wLHk9ZixfPWYqMik6cz09PVwiUkJHXCImJihoPTAsXz1mLHk9ZioyKTtmb3IobGV0IHc9MDt3PGE7dysrKWZvcihsZXQgUz0wO1M8bztTKyspe2xldCAkPShlLmRhdGFbaCsrXS1wWzBdKSpsWzBdLHY9KGUuZGF0YVt5KytdLXBbMV0pKmxbMV0sVD0oZS5kYXRhW18rK10tcFsyXSkqbFsyXSxDPWI9PT0tMT8yNTU6KGUuZGF0YVtiKytdLXBbM10pKmxbM107ci5maWxsU3R5bGU9XCJyZ2JhKFwiKyQrXCIsXCIrditcIixcIitUK1wiLFwiK0MrXCIpXCIsci5maWxsUmVjdChTLHcsMSwxKX1pZihcInRvRGF0YVVSTFwiaW4gbilyZXR1cm4gbi50b0RhdGFVUkwoKTt0aHJvdyBuZXcgRXJyb3IoXCJ0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9LGphPShlLHQpPT57bGV0IG49dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KFwiMmRcIikscjtpZihuIT1udWxsKXtsZXQgbyxhLHM7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxhPWUuZGltc1sxXSxzPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGE9ZS5kaW1zWzJdLHM9ZS5kaW1zWzFdKTtsZXQgZD10IT09dm9pZCAwJiZ0LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGw9dD8ubm9ybSxwLGY7bD09PXZvaWQgMHx8bC5tZWFuPT09dm9pZCAwP3A9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGwubWVhbj09XCJudW1iZXJcIj9wPVtsLm1lYW4sbC5tZWFuLGwubWVhbixsLm1lYW5dOihwPVtsLm1lYW5bMF0sbC5tZWFuWzFdLGwubWVhblsyXSwyNTVdLGwubWVhblszXSE9PXZvaWQgMCYmKHBbM109bC5tZWFuWzNdKSksbD09PXZvaWQgMHx8bC5iaWFzPT09dm9pZCAwP2Y9WzAsMCwwLDBdOnR5cGVvZiBsLmJpYXM9PVwibnVtYmVyXCI/Zj1bbC5iaWFzLGwuYmlhcyxsLmJpYXMsbC5iaWFzXTooZj1bbC5iaWFzWzBdLGwuYmlhc1sxXSxsLmJpYXNbMl0sMF0sbC5iaWFzWzNdIT09dm9pZCAwJiYoZlszXT1sLmJpYXNbM10pKTtsZXQgaD1hKm87aWYodCE9PXZvaWQgMCYmKHQuZm9ybWF0IT09dm9pZCAwJiZzPT09NCYmdC5mb3JtYXQhPT1cIlJHQkFcInx8cz09PTMmJnQuZm9ybWF0IT09XCJSR0JcIiYmdC5mb3JtYXQhPT1cIkJHUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIik7bGV0IHk9NCxfPTAsYj0xLHc9MixTPTMsJD0wLHY9aCxUPWgqMixDPS0xO2Q9PT1cIlJHQkFcIj8oJD0wLHY9aCxUPWgqMixDPWgqMyk6ZD09PVwiUkdCXCI/KCQ9MCx2PWgsVD1oKjIpOmQ9PT1cIlJCR1wiJiYoJD0wLFQ9aCx2PWgqMikscj1uLmNyZWF0ZUltYWdlRGF0YShvLGEpO2ZvcihsZXQgQT0wO0E8YSpvO18rPXksYis9eSx3Kz15LFMrPXksQSsrKXIuZGF0YVtfXT0oZS5kYXRhWyQrK10tZlswXSkqcFswXSxyLmRhdGFbYl09KGUuZGF0YVt2KytdLWZbMV0pKnBbMV0sci5kYXRhW3ddPShlLmRhdGFbVCsrXS1mWzJdKSpwWzJdLHIuZGF0YVtTXT1DPT09LTE/MjU1OihlLmRhdGFbQysrXS1mWzNdKSpwWzNdfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTtyZXR1cm4gcn19KTt2YXIgTG4sUWEsWWEsWGEsSmEsZXMsdHM9RygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7TG49KGUsdCk9PntpZihlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodC5oZWlnaHQ9PT12b2lkIDB8fHQud2lkdGg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7bGV0e2hlaWdodDpuLHdpZHRoOnJ9PXQsbz10Lm5vcm0/P3ttZWFuOjI1NSxiaWFzOjB9LGEsczt0eXBlb2Ygby5tZWFuPT1cIm51bWJlclwiP2E9W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06YT1bby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sby5tZWFuWzNdPz8yNTVdLHR5cGVvZiBvLmJpYXM9PVwibnVtYmVyXCI/cz1bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXTpzPVtvLmJpYXNbMF0sby5iaWFzWzFdLG8uYmlhc1syXSxvLmJpYXNbM10/PzBdO2xldCBkPXQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCQVwiLGw9dC50ZW5zb3JGb3JtYXQhPT12b2lkIDAmJnQudGVuc29yRm9ybWF0IT09dm9pZCAwP3QudGVuc29yRm9ybWF0OlwiUkdCXCIscD1uKnIsZj1sPT09XCJSR0JBXCI/bmV3IEZsb2F0MzJBcnJheShwKjQpOm5ldyBGbG9hdDMyQXJyYXkocCozKSxoPTQseT0wLF89MSxiPTIsdz0zLFM9MCwkPXAsdj1wKjIsVD0tMTtkPT09XCJSR0JcIiYmKGg9Myx5PTAsXz0xLGI9Mix3PS0xKSxsPT09XCJSR0JBXCI/VD1wKjM6bD09PVwiUkJHXCI/KFM9MCx2PXAsJD1wKjIpOmw9PT1cIkJHUlwiJiYodj0wLCQ9cCxTPXAqMik7Zm9yKGxldCBBPTA7QTxwO0ErKyx5Kz1oLGIrPWgsXys9aCx3Kz1oKWZbUysrXT0oZVt5XStzWzBdKS9hWzBdLGZbJCsrXT0oZVtfXStzWzFdKS9hWzFdLGZbdisrXT0oZVtiXStzWzJdKS9hWzJdLFQhPT0tMSYmdyE9PS0xJiYoZltUKytdPShlW3ddK3NbM10pL2FbM10pO3JldHVybiBsPT09XCJSR0JBXCI/bmV3IERlKFwiZmxvYXQzMlwiLGYsWzEsNCxuLHJdKTpuZXcgRGUoXCJmbG9hdDMyXCIsZixbMSwzLG4scl0pfSxRYT1hc3luYyhlLHQpPT57bGV0IG49dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8XCJ1XCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LHI9dHlwZW9mIEltYWdlRGF0YTxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPXR5cGVvZiBJbWFnZUJpdG1hcDxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGE9dHlwZW9mIGU9PVwic3RyaW5nXCIscyxkPXQ/P3t9LGw9KCk9PntpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhczxcInVcIilyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO3Rocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwPWY9PnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDxcInVcIiYmZiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHxmIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzP2YuZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7aWYobil7bGV0IGY9bCgpO2Yud2lkdGg9ZS53aWR0aCxmLmhlaWdodD1lLmhlaWdodDtsZXQgaD1wKGYpO2lmKGghPW51bGwpe2xldCB5PWUuaGVpZ2h0LF89ZS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYoeT10LnJlc2l6ZWRIZWlnaHQsXz10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYoZD10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2QudGVuc29yRm9ybWF0PVwiUkdCQVwiLGQuaGVpZ2h0PXksZC53aWR0aD1ffWVsc2UgZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9eSxkLndpZHRoPV87aC5kcmF3SW1hZ2UoZSwwLDApLHM9aC5nZXRJbWFnZURhdGEoMCwwLF8seSkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihyKXtsZXQgZixoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KGY9dC5yZXNpemVkSGVpZ2h0LGg9dC5yZXNpemVkV2lkdGgpOihmPWUuaGVpZ2h0LGg9ZS53aWR0aCksdCE9PXZvaWQgMCYmKGQ9dCksZC5mb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9ZixkLndpZHRoPWgsdCE9PXZvaWQgMCl7bGV0IHk9bCgpO3kud2lkdGg9aCx5LmhlaWdodD1mO2xldCBfPXAoeSk7aWYoXyE9bnVsbClfLnB1dEltYWdlRGF0YShlLDAsMCkscz1fLmdldEltYWdlRGF0YSgwLDAsaCxmKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIHM9ZS5kYXRhfWVsc2UgaWYobyl7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBmPWwoKTtmLndpZHRoPWUud2lkdGgsZi5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IGg9cChmKTtpZihoIT1udWxsKXtsZXQgeT1lLmhlaWdodCxfPWUud2lkdGg7cmV0dXJuIGguZHJhd0ltYWdlKGUsMCwwLF8seSkscz1oLmdldEltYWdlRGF0YSgwLDAsXyx5KS5kYXRhLGQuaGVpZ2h0PXksZC53aWR0aD1fLExuKHMsZCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYoYSlyZXR1cm4gbmV3IFByb21pc2UoKGYsaCk9PntsZXQgeT1sKCksXz1wKHkpO2lmKCFlfHwhXylyZXR1cm4gaCgpO2xldCBiPW5ldyBJbWFnZTtiLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsYi5zcmM9ZSxiLm9ubG9hZD0oKT0+e3kud2lkdGg9Yi53aWR0aCx5LmhlaWdodD1iLmhlaWdodCxfLmRyYXdJbWFnZShiLDAsMCx5LndpZHRoLHkuaGVpZ2h0KTtsZXQgdz1fLmdldEltYWdlRGF0YSgwLDAseS53aWR0aCx5LmhlaWdodCk7ZC5oZWlnaHQ9eS5oZWlnaHQsZC53aWR0aD15LndpZHRoLGYoTG4ody5kYXRhLGQpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZihzIT09dm9pZCAwKXJldHVybiBMbihzLGQpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSxZYT0oZSx0KT0+e2xldHt3aWR0aDpuLGhlaWdodDpyLGRvd25sb2FkOm8sZGlzcG9zZTphfT10LHM9WzEscixuLDRdO3JldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTplLGRpbXM6cyxkb3dubG9hZDpvLGRpc3Bvc2U6YX0pfSxYYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpuLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX09dDtyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOm4/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjplLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX0pfSxKYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpuLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX09dDtyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLHR5cGU6bj8/XCJmbG9hdDMyXCIsbWxUZW5zb3I6ZSxkaW1zOnIsZG93bmxvYWQ6byxkaXNwb3NlOmF9KX0sZXM9KGUsdCxuKT0+bmV3IERlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIix0eXBlOmUsZGF0YTp0LGRpbXM6bj8/W3QubGVuZ3RoXX0pfSk7dmFyIEl0LFF0LHJzLG5zLG9zPUcoKCk9PntcInVzZSBzdHJpY3RcIjtJdD1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XSxbXCJpbnQ0XCIsVWludDhBcnJheV0sW1widWludDRcIixVaW50OEFycmF5XV0pLFF0PW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxycz0hMSxucz0oKT0+e2lmKCFycyl7cnM9ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJkJpZ0ludDY0QXJyYXkuZnJvbSx0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmQmlnVWludDY0QXJyYXkuZnJvbSxuPWdsb2JhbFRoaXMuRmxvYXQxNkFycmF5LHI9dHlwZW9mIG48XCJ1XCImJm4uZnJvbTtlJiYoSXQuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSxRdC5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSx0JiYoSXQuc2V0KFwidWludDY0XCIsQmlnVWludDY0QXJyYXkpLFF0LnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSkscj8oSXQuc2V0KFwiZmxvYXQxNlwiLG4pLFF0LnNldChuLFwiZmxvYXQxNlwiKSk6SXQuc2V0KFwiZmxvYXQxNlwiLFVpbnQxNkFycmF5KX19fSk7dmFyIGlzLGFzLHNzPUcoKCk9PntcInVzZSBzdHJpY3RcIjt3cigpO2lzPWU9PntsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgcj1lW25dO2lmKHR5cGVvZiByIT1cIm51bWJlclwifHwhTnVtYmVyLmlzU2FmZUludGVnZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtyfWApO2lmKHI8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtyfWApO3QqPXJ9cmV0dXJuIHR9LGFzPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgRGUoZS50eXBlLGUuZGF0YSx0KTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsZGF0YTplLmRhdGEsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwidGV4dHVyZVwiOnJldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHRleHR1cmU6ZS50ZXh0dXJlLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIixncHVCdWZmZXI6ZS5ncHVCdWZmZXIsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJtbC10ZW5zb3JcIixtbFRlbnNvcjplLm1sVGVuc29yLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciBEZSx3cj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WmEoKTt0cygpO29zKCk7c3MoKTtEZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4scil7bnMoKTtsZXQgbyxhO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLG89dC50eXBlLGE9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGQ9SXQuZ2V0KG8pO2lmKCFkKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGQpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2QubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYobyE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKG8hPT1cImZsb2F0MzJcIiYmbyE9PVwiZmxvYXQxNlwiJiZvIT09XCJpbnQzMlwiJiZvIT09XCJpbnQ2NFwiJiZvIT09XCJ1aW50MzJcIiYmbyE9PVwidWludDhcIiYmbyE9PVwiYm9vbFwiJiZvIT09XCJ1aW50NFwiJiZvIT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO3RoaXMuZ3B1QnVmZmVyRGF0YT10LmdwdUJ1ZmZlcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJtbC10ZW5zb3JcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50NjRcIiYmbyE9PVwiaW50OFwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBNTFRlbnNvcmApO3RoaXMubWxUZW5zb3JEYXRhPXQubWxUZW5zb3IsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGQsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihvPXQsbD1yLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtkPW59ZWxzZXtsZXQgcD1JdC5nZXQodCk7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZih0PT09XCJmbG9hdDE2XCImJnA9PT1VaW50MTZBcnJheXx8dD09PVwidWludDRcInx8dD09PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYENyZWF0aW5nIGEgJHt0fSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3AubmFtZX0gYXMgZGF0YS5gKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9kPXAuZnJvbShuLEJpZ0ludCk6ZD1wLmZyb20obil9ZWxzZSBpZihuIGluc3RhbmNlb2YgcClkPW47ZWxzZSBpZihuIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpaWYodD09PVwidWludDhcIilkPVVpbnQ4QXJyYXkuZnJvbShuKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIFVpbnQ4Q2xhbXBlZEFycmF5IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mIHVpbnQ4XCIpO2Vsc2UgaWYodD09PVwiZmxvYXQxNlwiJiZuIGluc3RhbmNlb2YgVWludDE2QXJyYXkmJnAhPT1VaW50MTZBcnJheSlkPW5ldyBnbG9iYWxUaGlzLkZsb2F0MTZBcnJheShuLmJ1ZmZlcixuLmJ5dGVPZmZzZXQsbi5sZW5ndGgpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke299IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cH1gKX1lbHNlIGlmKGw9bixBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtsZXQgcD10eXBlb2YgdFswXTtpZihwPT09XCJzdHJpbmdcIilvPVwic3RyaW5nXCIsZD10O2Vsc2UgaWYocD09PVwiYm9vbGVhblwiKW89XCJib29sXCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3B9LmApfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KW89XCJ1aW50OFwiLGQ9VWludDhBcnJheS5mcm9tKHQpO2Vsc2V7bGV0IHA9UXQuZ2V0KHQuY29uc3RydWN0b3IpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7dC5jb25zdHJ1Y3Rvcn0uYCk7bz1wLGQ9dH1pZihsPT09dm9pZCAwKWw9W2QubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTthPWwsdGhpcy5jcHVEYXRhPWQsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIn1sZXQgcz1pcyhhKTtpZih0aGlzLmNwdURhdGEmJnMhPT10aGlzLmNwdURhdGEubGVuZ3RoJiYhKChvPT09XCJ1aW50NFwifHxvPT09XCJpbnQ0XCIpJiZNYXRoLmNlaWwocy8yKT09PXRoaXMuY3B1RGF0YS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3N9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTt0aGlzLnR5cGU9byx0aGlzLmRpbXM9YSx0aGlzLnNpemU9c31zdGF0aWMgYXN5bmMgZnJvbUltYWdlKHQsbil7cmV0dXJuIFFhKHQsbil9c3RhdGljIGZyb21UZXh0dXJlKHQsbil7cmV0dXJuIFlhKHQsbil9c3RhdGljIGZyb21HcHVCdWZmZXIodCxuKXtyZXR1cm4gWGEodCxuKX1zdGF0aWMgZnJvbU1MVGVuc29yKHQsbil7cmV0dXJuIEphKHQsbil9c3RhdGljIGZyb21QaW5uZWRCdWZmZXIodCxuLHIpe3JldHVybiBlcyh0LG4scil9dG9EYXRhVVJMKHQpe3JldHVybiBLYSh0aGlzLHQpfXRvSW1hZ2VEYXRhKHQpe3JldHVybiBqYSh0aGlzLHQpfWdldCBkYXRhKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmNwdURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LlwiKTtyZXR1cm4gdGhpcy5jcHVEYXRhfWdldCBsb2NhdGlvbigpe3JldHVybiB0aGlzLmRhdGFMb2NhdGlvbn1nZXQgdGV4dHVyZSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVUZXh0dXJlRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS5cIik7cmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGF9Z2V0IGdwdUJ1ZmZlcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVCdWZmZXJEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLlwiKTtyZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhfWdldCBtbFRlbnNvcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5tbFRlbnNvckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLlwiKTtyZXR1cm4gdGhpcy5tbFRlbnNvckRhdGF9YXN5bmMgZ2V0RGF0YSh0KXtzd2l0Y2godGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZGF0YUxvY2F0aW9uKXtjYXNlXCJjcHVcIjpjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIHRoaXMuZGF0YTtjYXNlXCJ0ZXh0dXJlXCI6Y2FzZVwiZ3B1LWJ1ZmZlclwiOmNhc2VcIm1sLXRlbnNvclwiOntpZighdGhpcy5kb3dubG9hZGVyKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci5cIik7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0cnl7dGhpcy5pc0Rvd25sb2FkaW5nPSEwO2xldCBuPWF3YWl0IHRoaXMuZG93bmxvYWRlcigpO3JldHVybiB0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCIsdGhpcy5jcHVEYXRhPW4sdCYmdGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCksbn1maW5hbGx5e3RoaXMuaXNEb3dubG9hZGluZz0hMX19ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApfX1kaXNwb3NlKCl7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSx0aGlzLmNwdURhdGE9dm9pZCAwLHRoaXMuZ3B1VGV4dHVyZURhdGE9dm9pZCAwLHRoaXMuZ3B1QnVmZmVyRGF0YT12b2lkIDAsdGhpcy5tbFRlbnNvckRhdGE9dm9pZCAwLHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5pc0Rvd25sb2FkaW5nPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cIm5vbmVcIn1lbnN1cmVWYWxpZCgpe2lmKHRoaXMuZGF0YUxvY2F0aW9uPT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cIil9cmVzaGFwZSh0KXtpZih0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kb3dubG9hZGVyfHx0aGlzLmRpc3Bvc2VyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuXCIpO3JldHVybiBhcyh0aGlzLHQpfX19KTt2YXIgcWUsR249RygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7cWU9RGV9KTt2YXIgdnIsdXMsTmUsQmUsSG49RygoKT0+e1widXNlIHN0cmljdFwiO1duKCk7dnI9KGUsdCk9PnsodHlwZW9mIFVlLnRyYWNlPlwidVwiPyFVZS53YXNtLnRyYWNlOiFVZS50cmFjZSl8fGNvbnNvbGUudGltZVN0YW1wKGAke2V9OjpPUlQ6OiR7dH1gKX0sdXM9KGUsdCk9PntsZXQgbj1uZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpfHxbXSxyPSExO2ZvcihsZXQgbz0wO288bi5sZW5ndGg7bysrKXtpZihyJiYhbltvXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikpe2xldCBhPWBGVU5DXyR7ZX06OiR7bltvXS50cmltKCkuc3BsaXQoXCIgXCIpWzFdfWA7dCYmKGErPWA6OiR7dH1gKSx2cihcIkNQVVwiLGEpO3JldHVybn1uW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSYmKHI9ITApfX0sTmU9ZT0+eyh0eXBlb2YgVWUudHJhY2U+XCJ1XCI/IVVlLndhc20udHJhY2U6IVVlLnRyYWNlKXx8dXMoXCJCRUdJTlwiLGUpfSxCZT1lPT57KHR5cGVvZiBVZS50cmFjZT5cInVcIj8hVWUud2FzbS50cmFjZTohVWUudHJhY2UpfHx1cyhcIkVORFwiLGUpfX0pO3ZhciAkcixkcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm4oKTtHbigpO0huKCk7JHI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1hc3luYyBydW4odCxuLHIpe05lKCk7bGV0IG89e30sYT17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBxZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBzPSEwO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiKXtpZihuPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKG4gaW5zdGFuY2VvZiBxZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZihuLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO3M9ITE7Zm9yKGxldCBwIG9mIG4pe2lmKHR5cGVvZiBwIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihwKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtwfS5gKTtvW3BdPW51bGx9aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWE9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IHA9ITEsZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKTtmb3IobGV0IGggb2YgdGhpcy5vdXRwdXROYW1lcylpZihmLmluZGV4T2YoaCkhPT0tMSl7bGV0IHk9bltoXTsoeT09PW51bGx8fHkgaW5zdGFuY2VvZiBxZSkmJihwPSEwLHM9ITEsb1toXT15KX1pZihwKXtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBhPW59fWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBwIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtwXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3B9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYocylmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcylvW3BdPW51bGw7bGV0IGQ9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG8sYSksbD17fTtmb3IobGV0IHAgaW4gZClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChkLHApKXtsZXQgZj1kW3BdO2YgaW5zdGFuY2VvZiBxZT9sW3BdPWY6bFtwXT1uZXcgcWUoZi50eXBlLGYuZGF0YSxmLmRpbXMpfXJldHVybiBCZSgpLGx9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxuLHIsbyl7TmUoKTtsZXQgYSxzPXt9O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihhPXQsdHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKXM9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGE9dCx0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmdCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKXtsZXQgZj10LGg9MCx5PXQuYnl0ZUxlbmd0aDtpZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPDB8fGg+PWYuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtmLmJ5dGVMZW5ndGh9KS5gKTtpZih5PXQuYnl0ZUxlbmd0aC1oLHR5cGVvZiByPT1cIm51bWJlclwiKXtpZih5PXIsIU51bWJlci5pc1NhZmVJbnRlZ2VyKHkpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoeTw9MHx8aCt5PmYuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtmLmJ5dGVMZW5ndGgtaH1dLmApO2lmKHR5cGVvZiBvPT1cIm9iamVjdFwiJiZvIT09bnVsbClzPW87ZWxzZSBpZih0eXBlb2YgbzxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTthPW5ldyBVaW50OEFycmF5KGYsaCx5KX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7bGV0W2QsbF09YXdhaXQgV2EocykscD1hd2FpdCBkLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGEsbCk7cmV0dXJuIEJlKCksbmV3IGUocCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319fSk7dmFyIE9mLGxzPUcoKCk9PntcInVzZSBzdHJpY3RcIjtkcygpO09mPSRyfSk7dmFyIGNzPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBwcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgbXM9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGZzPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBGbj17fTtadChGbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+T2YsVFJBQ0U6KCk9PnZyLFRSQUNFX0ZVTkNfQkVHSU46KCk9Pk5lLFRSQUNFX0ZVTkNfRU5EOigpPT5CZSxUZW5zb3I6KCk9PnFlLGVudjooKT0+d2UscmVnaXN0ZXJCYWNrZW5kOigpPT5DdH0pO3ZhciBHZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGEoKTtxYSgpO2xzKCk7R24oKTtjcygpO3BzKCk7SG4oKTttcygpO2ZzKCl9KTt2YXIgeHI9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGJzPXt9O1p0KGJzLHtkZWZhdWx0OigpPT5EZn0pO3ZhciBncyx5cyxEZixfcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cW4oKTtidCgpO1NyKCk7Z3M9XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIix5cz1nbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1nczt5cyYmKHNlbGYub25tZXNzYWdlPWU9PntsZXR7dHlwZTp0LGluOm59PWUuZGF0YTt0cnl7c3dpdGNoKHQpe2Nhc2VcImluaXQtd2FzbVwiOlRyKG4ud2FzbSkudGhlbigoKT0+e0NyKG4pLnRoZW4oKCk9Pntwb3N0TWVzc2FnZSh7dHlwZTp0fSl9LHI9Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpyfSl9KX0scj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX0pO2JyZWFrO2Nhc2VcImluaXQtZXBcIjp7bGV0e2VwTmFtZTpyLGVudjpvfT1uO0lyKG8scikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmF9KX0pO2JyZWFrfWNhc2VcImNvcHktZnJvbVwiOntsZXR7YnVmZmVyOnJ9PW4sbz1ZdChyKTtwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpvfSk7YnJlYWt9Y2FzZVwiY3JlYXRlXCI6e2xldHttb2RlbDpyLG9wdGlvbnM6b309bjtBcihyLG8pLnRoZW4oYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0OmF9KX0sYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmF9KX0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjprcihuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7Y2FzZVwicnVuXCI6e2xldHtzZXNzaW9uSWQ6cixpbnB1dEluZGljZXM6byxpbnB1dHM6YSxvdXRwdXRJbmRpY2VzOnMsb3B0aW9uczpkfT1uO0VyKHIsbyxhLHMsbmV3IEFycmF5KHMubGVuZ3RoKS5maWxsKG51bGwpLGQpLnRoZW4obD0+e2wuc29tZShwPT5wWzNdIT09XCJjcHVcIik/cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6XCJQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLlwifSk6cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6bH0senIoWy4uLmEsLi4ubF0pKX0sbD0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmx9KX0pO2JyZWFrfWNhc2VcImVuZC1wcm9maWxpbmdcIjpQcihuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7ZGVmYXVsdDp9fWNhdGNoKHIpe3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX19KTtEZj15cz9udWxsOmU9Pm5ldyBXb3JrZXIoZT8/VmUse3R5cGU6XCJtb2R1bGVcIixuYW1lOmdzfSl9KTt2YXIgdnM9e307WnQodnMse2RlZmF1bHQ6KCk9PkJmfSk7dmFyIEtuLHdzLEJmLE1mLCRzPUcoKCk9PntcInVzZSBzdHJpY3RcIjt3cz0oS249aW1wb3J0Lm1ldGEudXJsLGFzeW5jIGZ1bmN0aW9uKGU9e30pe3ZhciB0LG4scj1lLG89bmV3IFByb21pc2UoKGksdSk9Pnt0PWksbj11fSksYT10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLHM9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlPFwidVwiLGQ9cyYmc2VsZi5uYW1lPy5zdGFydHNXaXRoKFwiZW0tcHRocmVhZFwiKTtyLm1vdW50RXh0ZXJuYWxEYXRhPShpLHUpPT57aS5zdGFydHNXaXRoKFwiLi9cIikmJihpPWkuc3Vic3RyaW5nKDIpKSwoci5CZHx8KHIuQmQ9bmV3IE1hcCkpLnNldChpLHUpfSxyLnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgci5CZH07dmFyIGw9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0IHA9KCk9PntsZXQgaT0oYyxtLGcpPT4oLi4ueCk9PntsZXQgST1KZSx6PW0/LigpO3g9YyguLi54KTtsZXQgQj1tPy4oKTtyZXR1cm4geiE9PUImJihjPUIsZyh6KSxtPWc9bnVsbCksSmUhPUk/bmV3IFByb21pc2UoKEwscSk9PntFbj17cmVzb2x2ZTpMLHJlamVjdDpxfX0pOnh9LHU9Yz0+YXN5bmMoLi4ubSk9Pnt0cnl7aWYoci5DZCl0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCBnPXIuQ2Q9e2JlOm1bMF0sZXJyb3JzOltdfSx4PWF3YWl0IGMoLi4ubSk7aWYoci5DZCE9PWcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3IuRGQ/LmZsdXNoKCk7bGV0IEk9Zy5lcnJvcnM7aWYoMDxJLmxlbmd0aCl7bGV0IHo9YXdhaXQgUHJvbWlzZS5hbGwoSSk7aWYoej16LmZpbHRlcihCPT5CKSwwPHoubGVuZ3RoKXRocm93IEVycm9yKHouam9pbihgXG5gKSl9cmV0dXJuIHh9ZmluYWxseXtyLkNkPW51bGx9fTtyLl9PcnRDcmVhdGVTZXNzaW9uPWkoci5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+ci5fT3J0Q3JlYXRlU2Vzc2lvbixjPT5yLl9PcnRDcmVhdGVTZXNzaW9uPWMpLHIuX09ydFJ1bj11KGkoci5fT3J0UnVuLCgpPT5yLl9PcnRSdW4sYz0+ci5fT3J0UnVuPWMpKSxyLl9PcnRSdW5XaXRoQmluZGluZz11KGkoci5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnIuX09ydFJ1bldpdGhCaW5kaW5nLGM9PnIuX09ydFJ1bldpdGhCaW5kaW5nPWMpKSxyLl9PcnRCaW5kSW5wdXQ9aShyLl9PcnRCaW5kSW5wdXQsKCk9PnIuX09ydEJpbmRJbnB1dCxjPT5yLl9PcnRCaW5kSW5wdXQ9YykscD12b2lkIDB9O3IuanNlcEluaXQ9KGksdSk9PntpZihwPy4oKSxpPT09XCJ3ZWJncHVcIil7W3IuRGQsci5SZCxyLlZkLHIuSGQsci5VZCxyLmhjLHIuV2Qsci5aZCxyLlNkLHIuVGQsci5YZF09dTtsZXQgYz1yLkRkO3IuanNlcFJlZ2lzdGVyQnVmZmVyPShtLGcseCxJKT0+Yy5yZWdpc3RlckJ1ZmZlcihtLGcseCxJKSxyLmpzZXBHZXRCdWZmZXI9bT0+Yy5nZXRCdWZmZXIobSksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0obSxnLHgpPT5jLmNyZWF0ZURvd25sb2FkZXIobSxnLHgpLHIuanNlcE9uQ3JlYXRlU2Vzc2lvbj1tPT57Yy5vbkNyZWF0ZVNlc3Npb24obSl9LHIuanNlcE9uUmVsZWFzZVNlc3Npb249bT0+e2Mub25SZWxlYXNlU2Vzc2lvbihtKX0sci5qc2VwT25SdW5TdGFydD1tPT5jLm9uUnVuU3RhcnQobSksci4kZD0obSxnKT0+e2MudXBsb2FkKG0sZyl9fWVsc2UgaWYoaT09PVwid2Vibm5cIil7W3IuRGQsci5ZZCxyLklkLHIuanNlcEVuc3VyZVRlbnNvcixyLkpkLHIuanNlcERvd25sb2FkVGVuc29yXT11LHIuanNlcFJlbGVhc2VUZW5zb3JJZD1yLklkLHIuanNlcFVwbG9hZFRlbnNvcj1yLkpkO2xldCBjPXIuRGQ7ci5qc2VwT25SdW5TdGFydD1tPT5jLm9uUnVuU3RhcnQobSksci5qc2VwT25SdW5FbmQ9Yy5vblJ1bkVuZC5iaW5kKGMpLHIuanNlcFJlZ2lzdGVyTUxDb250ZXh0PShtLGcpPT57Yy5yZWdpc3Rlck1MQ29udGV4dChtLGcpfSxyLmpzZXBPblJlbGVhc2VTZXNzaW9uPW09PntjLm9uUmVsZWFzZVNlc3Npb24obSl9LHIuanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlcj0obSxnKT0+Yy5jcmVhdGVNTFRlbnNvckRvd25sb2FkZXIobSxnKSxyLmpzZXBSZWdpc3Rlck1MVGVuc29yPShtLGcseCxJKT0+Yy5yZWdpc3Rlck1MVGVuc29yKG0sZyx4LEkpLHIuanNlcENyZWF0ZU1MQ29udGV4dD1tPT5jLmNyZWF0ZU1MQ29udGV4dChtKSxyLmpzZXBSZWdpc3Rlck1MQ29uc3RhbnQ9KG0sZyx4LEkseik9PmMucmVnaXN0ZXJNTENvbnN0YW50KG0sZyx4LEkseixyLkJkKSxyLmpzZXBSZWdpc3RlckdyYXBoSW5wdXQ9Yy5yZWdpc3RlckdyYXBoSW5wdXQuYmluZChjKSxyLmpzZXBJc0dyYXBoSW5wdXQ9Yy5pc0dyYXBoSW5wdXQuYmluZChjKSxyLmpzZXBDcmVhdGVUZW1wb3JhcnlUZW5zb3I9Yy5jcmVhdGVUZW1wb3JhcnlUZW5zb3IuYmluZChjKX19O3ZhciBmLGgseT1PYmplY3QuYXNzaWduKHt9LHIpLF89KGksdSk9Pnt0aHJvdyB1fSxiPVwiXCI7KGF8fHMpJiYocz9iPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihiPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxLbiYmKGI9S24pLGI9Yi5zdGFydHNXaXRoKFwiYmxvYjpcIik/XCJcIjpiLnNsaWNlKDAsYi5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKSxzJiYoaD1pPT57dmFyIHU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB1Lm9wZW4oXCJHRVRcIixpLCExKSx1LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHUucmVzcG9uc2UpfSksZj1hc3luYyBpPT57aWYobGUoaSkpcmV0dXJuIG5ldyBQcm9taXNlKChjLG0pPT57dmFyIGc9bmV3IFhNTEh0dHBSZXF1ZXN0O2cub3BlbihcIkdFVFwiLGksITApLGcucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixnLm9ubG9hZD0oKT0+e2cuc3RhdHVzPT0yMDB8fGcuc3RhdHVzPT0wJiZnLnJlc3BvbnNlP2MoZy5yZXNwb25zZSk6bShnLnN0YXR1cyl9LGcub25lcnJvcj1tLGcuc2VuZChudWxsKX0pO3ZhciB1PWF3YWl0IGZldGNoKGkse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pO2lmKHUub2spcmV0dXJuIHUuYXJyYXlCdWZmZXIoKTt0aHJvdyBFcnJvcih1LnN0YXR1cytcIiA6IFwiK3UudXJsKX0pO3ZhciB3PWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUz1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksJD13LHY9UztPYmplY3QuYXNzaWduKHIseSkseT1udWxsO3ZhciBULEMsQSxrLE8sTSxWLEYsaixuZSxXLEosdmUsUT1yLndhc21CaW5hcnksZWU9ITEsbGU9aT0+aS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKTtmdW5jdGlvbiBaKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxrfWZ1bmN0aW9uIHBlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxPfWZ1bmN0aW9uIGtlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxNfWZ1bmN0aW9uIFNlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxWfWZ1bmN0aW9uIEQoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLEZ9ZnVuY3Rpb24gUigpe3JldHVybiBULmJ1ZmZlciE9ay5idWZmZXImJmJlKCksan1mdW5jdGlvbiBZKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxuZX1mdW5jdGlvbiBmZSgpe3JldHVybiBULmJ1ZmZlciE9ay5idWZmZXImJmJlKCksdmV9aWYoZCl7bGV0IGk9ZnVuY3Rpb24odSl7dHJ5e3ZhciBjPXUuZGF0YSxtPWMueWQ7aWYobT09PVwibG9hZFwiKXtsZXQgZz1bXTtzZWxmLm9ubWVzc2FnZT14PT5nLnB1c2goeCksc2VsZi5zdGFydFdvcmtlcj0oKT0+e3Bvc3RNZXNzYWdlKHt5ZDpcImxvYWRlZFwifSk7Zm9yKGxldCB4IG9mIGcpaSh4KTtzZWxmLm9ubWVzc2FnZT1pfTtmb3IobGV0IHggb2YgYy5PZClyW3hdJiYhclt4XS5wcm94eXx8KHJbeF09KC4uLkkpPT57cG9zdE1lc3NhZ2Uoe3lkOlwiY2FsbEhhbmRsZXJcIixOZDp4LGFyZ3M6SX0pfSx4PT1cInByaW50XCImJigkPXJbeF0pLHg9PVwicHJpbnRFcnJcIiYmKHY9clt4XSkpO1Q9Yy5oZSxiZSgpLEZlKGMuaWUpfWVsc2UgaWYobT09PVwicnVuXCIpe2NwKGMueGQpLERuKGMueGQsMCwwLDEsMCwwKSxMbygpLEFuKGMueGQpLHhlfHwoTWkoKSx4ZT0hMCk7dHJ5e3BwKGMuZGUsYy5GZCl9Y2F0Y2goZyl7aWYoZyE9XCJ1bndpbmRcIil0aHJvdyBnfX1lbHNlIGMudGFyZ2V0IT09XCJzZXRpbW1lZGlhdGVcIiYmKG09PT1cImNoZWNrTWFpbGJveFwiP3hlJiZ1cigpOm0mJih2KGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke219YCksdihjKSkpfWNhdGNoKGcpe3Rocm93IFJpKCksZ319O3ZhciB1Yj1pLEZlLHhlPSExO3Y9ZnVuY3Rpb24oLi4udSl7dT11LmpvaW4oXCIgXCIpLGNvbnNvbGUuZXJyb3IodSl9LHNlbGYuYWxlcnQ9ZnVuY3Rpb24oLi4udSl7cG9zdE1lc3NhZ2Uoe3lkOlwiYWxlcnRcIix0ZXh0OnUuam9pbihcIiBcIiksZmU6Z3IoKX0pfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPXU9Pnt0aHJvdyB1LnJlYXNvbnx8dX0sc2VsZi5vbm1lc3NhZ2U9aX1mdW5jdGlvbiBiZSgpe3ZhciBpPVQuYnVmZmVyO3IuSEVBUDg9az1uZXcgSW50OEFycmF5KGkpLHIuSEVBUDE2PU09bmV3IEludDE2QXJyYXkoaSksci5IRUFQVTg9Tz1uZXcgVWludDhBcnJheShpKSxyLkhFQVBVMTY9Vj1uZXcgVWludDE2QXJyYXkoaSksci5IRUFQMzI9Rj1uZXcgSW50MzJBcnJheShpKSxyLkhFQVBVMzI9aj1uZXcgVWludDMyQXJyYXkoaSksci5IRUFQRjMyPW5lPW5ldyBGbG9hdDMyQXJyYXkoaSksci5IRUFQRjY0PXZlPW5ldyBGbG9hdDY0QXJyYXkoaSksci5IRUFQNjQ9Vz1uZXcgQmlnSW50NjRBcnJheShpKSxyLkhFQVBVNjQ9Sj1uZXcgQmlnVWludDY0QXJyYXkoaSl9ZnVuY3Rpb24gWWUoKXtkP3N0YXJ0V29ya2VyKHIpOlUuQmIoKX1kfHwoVD1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjI1NixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pLGJlKCkpO3ZhciBHdCx4dD0wLEh0PW51bGw7ZnVuY3Rpb24gQm8oKXtpZigtLXh0PT0wJiZIdCl7dmFyIGk9SHQ7SHQ9bnVsbCxpKCl9fWZ1bmN0aW9uIHV0KGkpe3Rocm93IHYoaT1cIkFib3J0ZWQoXCIraStcIilcIiksZWU9ITAsaT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGkrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG4oaSksaX1mdW5jdGlvbiBNbygpe3JldHVybnthOntUYTpscCxWYTpkcCxXOm1wLGxhOmZwLGI6Z3AsdTp5cCxSOmJwLFphOl9wLGQ6d3AscGI6cW8sZzpocCxUOlpvLEdhOlFvLGxiOlhvLG5iOkpvLEhhOmVpLEVhOnRpLHdiOnJpLERhOm5pLHBhOm9pLG1iOmlpLGpiOmFpLEZhOnNpLGtiOnVpLE1hOnZwLHphOnhwLGViOlNwLGNiOkNwLHlhOkFwLFY6a3AsTjpFcCxkYjpQcCxtYTpVcCxmYjpOcCx6YjpWcCxoYjpXcCxxYjpMcCxhYjpHcCxBYTpIcCx5YjpBbixKYTpGcCxTOnFwLFdhOktwLCQ6UXAsRzpZcCxFOkpwLG06VG4sSDplbSxCOm5tLFg6b20sSjppbSx2OmFtLE86c20sRDp1bSx0OmRtLEE6bG0sejpjbSx3OnBtLHI6bW0sdGI6Zm0sdWI6aG0sdmI6Z20scmI6JGksc2I6eGksYmI6U2ksT2E6Ym0sTGE6dm0seTokbSxqYTp4bSxCYTpTbSxLYTpfbSxxYTpUbSxJYTpDbSxpYjpJbSxVOnltLGZhOkFtLFNhOmttLGdiOkVtLFFhOlBtLFBhOnptLEFiOkFpLENhOmtpLG9iOl9uLGFhOkVpLG9hOlBpLHhiOnppLG5hOk9pLCRhOmFmLGlhOl9mLHNhOlNmLGdhOm5mLGRhOnBmLHVhOiRmLHA6dGYsZTpObSxjOlJtLGVhOmxmLGY6Vm0sbjpMbSxrOlltLFk6SG0sa2E6WG0sajpyZix3YTpkZixSYTpJZixjYTp5ZixVYTpDZixQOmNmLEs6cW0sXzpnZixROm9mLFo6d2YseDpGbSxsOlVtLHZhOmhmLGk6TW0saDpHbSxyYTpUZix0YTp4ZixvOldtLHE6S20sczpabSxJOlFtLEM6ZWYsTDpKbSx4YTp1ZixfYTpzZixGOmJmLFlhOm1mLGJhOnZmLE06am0sWGE6ZmYsaGE6RG0sYTpULE5hOmJufX19dmFyIGhuPXsxMzE5NDI2OigpPT50eXBlb2Ygd2FzbU9mZnNldENvbnZlcnRlcjxcInVcIiwxMzE5NDgzOihpLHUsYyxtLGcpPT57aWYocj09PXZvaWQgMHx8IXIuQmQpcmV0dXJuIDE7aWYoKGk9QWUoTnVtYmVyKGk+Pj4wKSkpLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGk9aS5zdWJzdHJpbmcoMikpLCEoaT1yLkJkLmdldChpKSkpcmV0dXJuIDI7aWYodT1OdW1iZXIodT4+PjApLGM9TnVtYmVyKGM+Pj4wKSxtPU51bWJlcihtPj4+MCksdStjPmkuYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7bGV0IHg9aS5zdWJhcnJheSh1LHUrYyk7c3dpdGNoKGcpe2Nhc2UgMDpwZSgpLnNldCh4LG0+Pj4wKTticmVhaztjYXNlIDE6ci4kZChtLHgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSwxMzIwMTk4OihpLHUsYyk9PntyLkpkKGkscGUoKS5zdWJhcnJheSh1Pj4+MCx1K2M+Pj4wKSl9LDEzMjAyNjE6KCk9PnIuWWQoKSwxMzIwMzAyOmk9PntyLklkKGkpfSwxMzIwMzM4OigpPT57ci5TZCgpfSwxMzIwMzY5OigpPT57ci5UZCgpfSwxMzIwMzk4OigpPT57ci5YZCgpfSwxMzIwNDIzOmk9PnIuUmQoaSksMTMyMDQ1NjppPT5yLlZkKGkpLDEzMjA0ODg6KGksdSxjKT0+e3IuSGQoTnVtYmVyKGkpLE51bWJlcih1KSxOdW1iZXIoYyksITApfSwxMzIwNTUxOihpLHUsYyk9PntyLkhkKE51bWJlcihpKSxOdW1iZXIodSksTnVtYmVyKGMpKX0sMTMyMDYwODppPT57ci5oYyhcIkFic1wiLGksdm9pZCAwKX0sMTMyMDY1OTppPT57ci5oYyhcIk5lZ1wiLGksdm9pZCAwKX0sMTMyMDcxMDppPT57ci5oYyhcIkZsb29yXCIsaSx2b2lkIDApfSwxMzIwNzYzOmk9PntyLmhjKFwiQ2VpbFwiLGksdm9pZCAwKX0sMTMyMDgxNTppPT57ci5oYyhcIlJlY2lwcm9jYWxcIixpLHZvaWQgMCl9LDEzMjA4NzM6aT0+e3IuaGMoXCJTcXJ0XCIsaSx2b2lkIDApfSwxMzIwOTI1Omk9PntyLmhjKFwiRXhwXCIsaSx2b2lkIDApfSwxMzIwOTc2Omk9PntyLmhjKFwiRXJmXCIsaSx2b2lkIDApfSwxMzIxMDI3Omk9PntyLmhjKFwiU2lnbW9pZFwiLGksdm9pZCAwKX0sMTMyMTA4MjooaSx1LGMpPT57ci5oYyhcIkhhcmRTaWdtb2lkXCIsaSx7YWxwaGE6dSxiZXRhOmN9KX0sMTMyMTE2MTppPT57ci5oYyhcIkxvZ1wiLGksdm9pZCAwKX0sMTMyMTIxMjppPT57ci5oYyhcIlNpblwiLGksdm9pZCAwKX0sMTMyMTI2MzppPT57ci5oYyhcIkNvc1wiLGksdm9pZCAwKX0sMTMyMTMxNDppPT57ci5oYyhcIlRhblwiLGksdm9pZCAwKX0sMTMyMTM2NTppPT57ci5oYyhcIkFzaW5cIixpLHZvaWQgMCl9LDEzMjE0MTc6aT0+e3IuaGMoXCJBY29zXCIsaSx2b2lkIDApfSwxMzIxNDY5Omk9PntyLmhjKFwiQXRhblwiLGksdm9pZCAwKX0sMTMyMTUyMTppPT57ci5oYyhcIlNpbmhcIixpLHZvaWQgMCl9LDEzMjE1NzM6aT0+e3IuaGMoXCJDb3NoXCIsaSx2b2lkIDApfSwxMzIxNjI1Omk9PntyLmhjKFwiQXNpbmhcIixpLHZvaWQgMCl9LDEzMjE2Nzg6aT0+e3IuaGMoXCJBY29zaFwiLGksdm9pZCAwKX0sMTMyMTczMTppPT57ci5oYyhcIkF0YW5oXCIsaSx2b2lkIDApfSwxMzIxNzg0Omk9PntyLmhjKFwiVGFuaFwiLGksdm9pZCAwKX0sMTMyMTgzNjppPT57ci5oYyhcIk5vdFwiLGksdm9pZCAwKX0sMTMyMTg4NzooaSx1LGMpPT57ci5oYyhcIkNsaXBcIixpLHttaW46dSxtYXg6Y30pfSwxMzIxOTU2Omk9PntyLmhjKFwiQ2xpcFwiLGksdm9pZCAwKX0sMTMyMjAwODooaSx1KT0+e3IuaGMoXCJFbHVcIixpLHthbHBoYTp1fSl9LDEzMjIwNjY6aT0+e3IuaGMoXCJHZWx1XCIsaSx2b2lkIDApfSwxMzIyMTE4Omk9PntyLmhjKFwiUmVsdVwiLGksdm9pZCAwKX0sMTMyMjE3MDooaSx1KT0+e3IuaGMoXCJMZWFreVJlbHVcIixpLHthbHBoYTp1fSl9LDEzMjIyMzQ6KGksdSk9PntyLmhjKFwiVGhyZXNob2xkZWRSZWx1XCIsaSx7YWxwaGE6dX0pfSwxMzIyMzA0OihpLHUpPT57ci5oYyhcIkNhc3RcIixpLHt0bzp1fSl9LDEzMjIzNjI6aT0+e3IuaGMoXCJBZGRcIixpLHZvaWQgMCl9LDEzMjI0MTM6aT0+e3IuaGMoXCJTdWJcIixpLHZvaWQgMCl9LDEzMjI0NjQ6aT0+e3IuaGMoXCJNdWxcIixpLHZvaWQgMCl9LDEzMjI1MTU6aT0+e3IuaGMoXCJEaXZcIixpLHZvaWQgMCl9LDEzMjI1NjY6aT0+e3IuaGMoXCJQb3dcIixpLHZvaWQgMCl9LDEzMjI2MTc6aT0+e3IuaGMoXCJFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjY3MDppPT57ci5oYyhcIkdyZWF0ZXJcIixpLHZvaWQgMCl9LDEzMjI3MjU6aT0+e3IuaGMoXCJHcmVhdGVyT3JFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjc4NzppPT57ci5oYyhcIkxlc3NcIixpLHZvaWQgMCl9LDEzMjI4Mzk6aT0+e3IuaGMoXCJMZXNzT3JFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjg5ODooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VNZWFuXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzA3MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VNYXhcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzIzMjQ3OihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZU1pblwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM0MjE6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlUHJvZFwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM1OTY6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlU3VtXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzc3MDooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VMMVwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM5NDM6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlTDJcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzI0MTE2OihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZUxvZ1N1bVwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjQyOTM6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlU3VtU3F1YXJlXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyNDQ3MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VMb2dTdW1FeHBcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzI0NjUzOmk9PntyLmhjKFwiV2hlcmVcIixpLHZvaWQgMCl9LDEzMjQ3MDY6KGksdSxjKT0+e3IuaGMoXCJUcmFuc3Bvc2VcIixpLHtwZXJtOnU/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHUpPj4+MCxOdW1iZXIoYyk+Pj4wKSk6W119KX0sMTMyNDgzMDooaSx1LGMsbSk9PntyLmhjKFwiRGVwdGhUb1NwYWNlXCIsaSx7YmxvY2tzaXplOnUsbW9kZTpBZShjKSxmb3JtYXQ6bT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI0OTYzOihpLHUsYyxtKT0+e3IuaGMoXCJEZXB0aFRvU3BhY2VcIixpLHtibG9ja3NpemU6dSxtb2RlOkFlKGMpLGZvcm1hdDptP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMjUwOTY6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlLExlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpbY10sZ3JvdXA6bSxrZXJuZWxTaGFwZTpbZ10scGFkczpbeCxJXSxzdHJpZGVzOlt6XSx3SXNDb25zdDooKT0+ISFaKClbTD4+PjBdLG91dHB1dFBhZGRpbmc6cT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIocSk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTp1ZT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodWUpPj4+MCxOdW1iZXIoJGUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoTGUpfSl9LDEzMjU1Mjk6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLDIrKE51bWJlcihjKT4+PjApPj4+MCkpLGdyb3VwOm0sa2VybmVsU2hhcGU6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGcpPj4+MCwyKyhOdW1iZXIoZyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsNCsoTnVtYmVyKHgpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDIrKE51bWJlcihJKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIVooKVtCPj4+MF0sb3V0cHV0UGFkZGluZzpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLG91dHB1dFNoYXBlOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoJGUpfSl9LDEzMjYxOTA6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlLExlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpbY10sZ3JvdXA6bSxrZXJuZWxTaGFwZTpbZ10scGFkczpbeCxJXSxzdHJpZGVzOlt6XSx3SXNDb25zdDooKT0+ISFaKClbTD4+PjBdLG91dHB1dFBhZGRpbmc6cT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIocSk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTp1ZT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodWUpPj4+MCxOdW1iZXIoJGUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoTGUpfSl9LDEzMjY2MjM6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLDIrKE51bWJlcihjKT4+PjApPj4+MCkpLGdyb3VwOm0sa2VybmVsU2hhcGU6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGcpPj4+MCwyKyhOdW1iZXIoZyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsNCsoTnVtYmVyKHgpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDIrKE51bWJlcihJKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIVooKVtCPj4+MF0sb3V0cHV0UGFkZGluZzpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLG91dHB1dFNoYXBlOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoJGUpfSl9LDEzMjcyODQ6KGksdSk9PntyLmhjKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI3Mzc1OihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6JGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDptLHN0b3JhZ2Vfb3JkZXI6ZyxkaWxhdGlvbnM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxwYWRzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sc3RyaWRlczpYP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKHVlKT4+PjApKTpbXX0pfSwxMzI3ODU0OihpLHUpPT57ci5oYyhcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnU/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMyNzk0NTooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OiRlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnUsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6bSxzdG9yYWdlX29yZGVyOmcsZGlsYXRpb25zOng/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHgpPj4+MCxOdW1iZXIoSSk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOno/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHopPj4+MCxOdW1iZXIoQik+Pj4wKSk6W10scGFkczpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLHN0cmlkZXM6WD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcih1ZSk+Pj4wKSk6W119KX0sMTMyODQyNDooaSx1KT0+e3IuaGMoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OnU/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMyODUxMTooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIk1heFBvb2xcIixpLHtmb3JtYXQ6JGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDptLHN0b3JhZ2Vfb3JkZXI6ZyxkaWxhdGlvbnM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxwYWRzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sc3RyaWRlczpYP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKHVlKT4+PjApKTpbXX0pfSwxMzI4OTg2OihpLHUpPT57ci5oYyhcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI5MDczOihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDokZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDp1LGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOm0sc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdLGtlcm5lbF9zaGFwZTp6P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih6KT4+PjAsTnVtYmVyKEIpPj4+MCkpOltdLHBhZHM6TD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoTCk+Pj4wLE51bWJlcihxKT4+PjApKTpbXSxzdHJpZGVzOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdfSl9LDEzMjk1NDg6KGksdSxjLG0sZyk9PntyLmhjKFwiR2VtbVwiLGkse2FscGhhOnUsYmV0YTpjLHRyYW5zQTptLHRyYW5zQjpnfSl9LDEzMjk2NTI6aT0+e3IuaGMoXCJNYXRNdWxcIixpLHZvaWQgMCl9LDEzMjk3MDY6KGksdSxjLG0pPT57ci5oYyhcIkFyZ01heFwiLGkse2tlZXBEaW1zOiEhdSxzZWxlY3RMYXN0SW5kZXg6ISFjLGF4aXM6bX0pfSwxMzI5ODE0OihpLHUsYyxtKT0+e3IuaGMoXCJBcmdNaW5cIixpLHtrZWVwRGltczohIXUsc2VsZWN0TGFzdEluZGV4OiEhYyxheGlzOm19KX0sMTMyOTkyMjooaSx1KT0+e3IuaGMoXCJTb2Z0bWF4XCIsaSx7YXhpczp1fSl9LDEzMjk5ODU6KGksdSk9PntyLmhjKFwiQ29uY2F0XCIsaSx7YXhpczp1fSl9LDEzMzAwNDU6KGksdSxjLG0sZyk9PntyLmhjKFwiU3BsaXRcIixpLHtheGlzOnUsbnVtT3V0cHV0czpjLHNwbGl0U2l6ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzMwMjAxOmk9PntyLmhjKFwiRXhwYW5kXCIsaSx2b2lkIDApfSwxMzMwMjU1OihpLHUpPT57ci5oYyhcIkdhdGhlclwiLGkse2F4aXM6TnVtYmVyKHUpfSl9LDEzMzAzMjY6KGksdSk9PntyLmhjKFwiR2F0aGVyRWxlbWVudHNcIixpLHtheGlzOk51bWJlcih1KX0pfSwxMzMwNDA1OihpLHUpPT57ci5oYyhcIkdhdGhlck5EXCIsaSx7YmF0Y2hfZGltczpOdW1iZXIodSl9KX0sMTMzMDQ4NDooaSx1LGMsbSxnLHgsSSx6LEIsTCxxKT0+e3IuaGMoXCJSZXNpemVcIixpLHthbnRpYWxpYXM6dSxheGVzOmM/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIobSk+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6QWUoZyksY3ViaWNDb2VmZkE6eCxleGNsdWRlT3V0c2lkZTpJLGV4dHJhcG9sYXRpb25WYWx1ZTp6LGtlZXBBc3BlY3RSYXRpb1BvbGljeTpBZShCKSxtb2RlOkFlKEwpLG5lYXJlc3RNb2RlOkFlKHEpfSl9LDEzMzA4NDY6KGksdSxjLG0sZyx4LEkpPT57ci5oYyhcIlNsaWNlXCIsaSx7c3RhcnRzOnU/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHUpPj4+MCxOdW1iZXIoYyk+Pj4wKSk6W10sZW5kczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdLGF4ZXM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXX0pfSwxMzMxMTEwOmk9PntyLmhjKFwiVGlsZVwiLGksdm9pZCAwKX0sMTMzMTE2MjooaSx1LGMpPT57ci5oYyhcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246dSxmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMxMjc2OihpLHUsYyk9PntyLmhjKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LGZvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzEzOTA6aT0+e3IuaGMoXCJSYW5nZVwiLGksdm9pZCAwKX0sMTMzMTQ0MzooaSx1KT0+e3IuaGMoXCJFaW5zdW1cIixpLHtlcXVhdGlvbjpBZSh1KX0pfSwxMzMxNTI0OihpLHUsYyxtLGcpPT57ci5oYyhcIlBhZFwiLGkse21vZGU6dSx2YWx1ZTpjLHBhZHM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzMxNjY3OihpLHUsYyxtLGcseCk9PntyLmhjKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LG1vbWVudHVtOmMsc3BhdGlhbDohIWcsdHJhaW5pbmdNb2RlOiEhbSxmb3JtYXQ6eD9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMxODM2OihpLHUsYyxtLGcseCk9PntyLmhjKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LG1vbWVudHVtOmMsc3BhdGlhbDohIWcsdHJhaW5pbmdNb2RlOiEhbSxmb3JtYXQ6eD9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMyMDA1OihpLHUsYyk9PntyLmhjKFwiQ3VtU3VtXCIsaSx7ZXhjbHVzaXZlOk51bWJlcih1KSxyZXZlcnNlOk51bWJlcihjKX0pfSwxMzMyMTAyOihpLHUsYyk9PntyLmhjKFwiRGVxdWFudGl6ZUxpbmVhclwiLGkse2F4aXM6dSxibG9ja1NpemU6Y30pfSwxMzMyMTkyOihpLHUsYyxtLGcpPT57ci5oYyhcIkdyaWRTYW1wbGVcIixpLHthbGlnbl9jb3JuZXJzOnUsbW9kZTpBZShjKSxwYWRkaW5nX21vZGU6QWUobSksZm9ybWF0Omc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMzMjM2MjooaSx1LGMsbSxnKT0+e3IuaGMoXCJHcmlkU2FtcGxlXCIsaSx7YWxpZ25fY29ybmVyczp1LG1vZGU6QWUoYykscGFkZGluZ19tb2RlOkFlKG0pLGZvcm1hdDpnP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzI1MzI6KGksdSk9PntyLmhjKFwiU2NhdHRlck5EXCIsaSx7cmVkdWN0aW9uOkFlKHUpfSl9LDEzMzI2MTc6KGksdSxjLG0sZyx4LEkseixCKT0+e3IuaGMoXCJBdHRlbnRpb25cIixpLHtudW1IZWFkczp1LGlzVW5pZGlyZWN0aW9uYWw6YyxtYXNrRmlsdGVyVmFsdWU6bSxzY2FsZTpnLGRvUm90YXJ5OngscWt2SGlkZGVuU2l6ZXM6ST9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcih6KStJPj4+MCkpOltdLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ISFCfSl9LDEzMzI4ODk6aT0+e3IuaGMoXCJCaWFzQWRkXCIsaSx2b2lkIDApfSwxMzMyOTQ0Omk9PntyLmhjKFwiQmlhc1NwbGl0R2VsdVwiLGksdm9pZCAwKX0sMTMzMzAwNTppPT57ci5oYyhcIkZhc3RHZWx1XCIsaSx2b2lkIDApfSwxMzMzMDYxOihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSxMZSxqdCk9PntyLmhjKFwiQ29udlwiLGkse2Zvcm1hdDpYP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnUsZGlsYXRpb25zOmM/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIobSk+Pj4wKSk6W10sZ3JvdXA6ZyxrZXJuZWxfc2hhcGU6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxwYWRzOno/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHopPj4+MCxOdW1iZXIoQik+Pj4wKSk6W10sc3RyaWRlczpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLHdfaXNfY29uc3Q6KCk9PiEhWigpW051bWJlcih1ZSk+Pj4wXSxhY3RpdmF0aW9uOkFlKCRlKSxhY3RpdmF0aW9uX3BhcmFtczpMZT9BcnJheS5mcm9tKFkoKS5zdWJhcnJheShOdW1iZXIoTGUpPj4+MCxOdW1iZXIoanQpPj4+MCkpOltdfSl9LDEzMzM2NDU6aT0+e3IuaGMoXCJHZWx1XCIsaSx2b2lkIDApfSwxMzMzNjk3OihpLHUsYyxtLGcseCxJLHosQik9PntyLmhjKFwiR3JvdXBRdWVyeUF0dGVudGlvblwiLGkse251bUhlYWRzOnUsa3ZOdW1IZWFkczpjLHNjYWxlOm0sc29mdGNhcDpnLGRvUm90YXJ5Ongscm90YXJ5SW50ZXJsZWF2ZWQ6SSxzbW9vdGhTb2Z0bWF4OnosbG9jYWxXaW5kb3dTaXplOkJ9KX0sMTMzMzkxNDooaSx1LGMsbSk9PntyLmhjKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7YXhpczp1LGVwc2lsb246YyxzaW1wbGlmaWVkOiEhbX0pfSwxMzM0MDI1OihpLHUsYyxtKT0+e3IuaGMoXCJMYXllck5vcm1hbGl6YXRpb25cIixpLHtheGlzOnUsZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFtfSl9LDEzMzQxMzY6KGksdSxjLG0sZyx4KT0+e3IuaGMoXCJNYXRNdWxOQml0c1wiLGkse2s6dSxuOmMsYWNjdXJhY3lMZXZlbDptLGJpdHM6ZyxibG9ja1NpemU6eH0pfSwxMzM0MjYzOihpLHUsYyxtLGcseCk9PntyLmhjKFwiTXVsdGlIZWFkQXR0ZW50aW9uXCIsaSx7bnVtSGVhZHM6dSxpc1VuaWRpcmVjdGlvbmFsOmMsbWFza0ZpbHRlclZhbHVlOm0sc2NhbGU6Zyxkb1JvdGFyeTp4fSl9LDEzMzQ0MjI6KGksdSk9PntyLmhjKFwiUXVpY2tHZWx1XCIsaSx7YWxwaGE6dX0pfSwxMzM0NDg2OihpLHUsYyxtLGcpPT57ci5oYyhcIlJvdGFyeUVtYmVkZGluZ1wiLGkse2ludGVybGVhdmVkOiEhdSxudW1IZWFkczpjLHJvdGFyeUVtYmVkZGluZ0RpbTptLHNjYWxlOmd9KX0sMTMzNDYyNTooaSx1LGMpPT57ci5oYyhcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsc2ltcGxpZmllZDohIWN9KX0sMTMzNDcyNzooaSx1LGMpPT57ci5oYyhcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsc2ltcGxpZmllZDohIWN9KX0sMTMzNDgyOTooaSx1LGMsbSk9PntyLmhjKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixpLHtnYXRoZXJBeGlzOnUscXVhbnRpemVBeGlzOmMsYmxvY2tTaXplOm19KX0sMTMzNDk1MDppPT57ci5XZChpKX0sMTMzNDk4NDooaSx1KT0+ci5aZChOdW1iZXIoaSksTnVtYmVyKHUpLHIuQ2QuYmUsci5DZC5lcnJvcnMpfTtmdW5jdGlvbiBkcChpLHUsYyl7cmV0dXJuIGdpKGFzeW5jKCk9Pnthd2FpdCByLlVkKE51bWJlcihpKSxOdW1iZXIodSksTnVtYmVyKGMpKX0pfWZ1bmN0aW9uIGxwKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWNsYXNzIGdue25hbWU9XCJFeGl0U3RhdHVzXCI7Y29uc3RydWN0b3IodSl7dGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7dX0pYCx0aGlzLnN0YXR1cz11fX12YXIgUm89aT0+e2kudGVybWluYXRlKCksaS5vbm1lc3NhZ2U9KCk9Pnt9fSx5bj1bXSxVbz1pPT57ZnQubGVuZ3RoPT0wJiYoSG8oKSxHbyhmdFswXSkpO3ZhciB1PWZ0LnBvcCgpO2lmKCF1KXJldHVybiA2O0Z0LnB1c2godSksU3RbaS54ZF09dSx1LnhkPWkueGQ7dmFyIGM9e3lkOlwicnVuXCIsZGU6aS5jZSxGZDppLkZkLHhkOmkueGR9O3JldHVybiB1LnBvc3RNZXNzYWdlKGMsaS5MZCksMH0sbXQ9MCxUZT0oaSx1LC4uLmMpPT57Zm9yKHZhciBtPTIqYy5sZW5ndGgsZz1pZSgpLHg9TW4oOCptKSxJPXg+Pj4zLHo9MDt6PGMubGVuZ3RoO3orKyl7dmFyIEI9Y1t6XTt0eXBlb2YgQj09XCJiaWdpbnRcIj8oV1tJKzIqel09MW4sV1tJKzIqeisxXT1CKTooV1tJKzIqel09MG4sZmUoKVtJKzIqeisxPj4+MF09Qil9cmV0dXJuIGk9VWkoaSwwLG0seCx1KSxvZShnKSxpfTtmdW5jdGlvbiBibihpKXtpZihkKXJldHVybiBUZSgwLDEsaSk7aWYoQT1pLCEoMDxtdCkpe2Zvcih2YXIgdSBvZiBGdClSbyh1KTtmb3IodSBvZiBmdClSbyh1KTtmdD1bXSxGdD1bXSxTdD17fSxlZT0hMH1fKDAsbmV3IGduKGkpKX1mdW5jdGlvbiBObyhpKXtpZihkKXJldHVybiBUZSgxLDAsaSk7X24oaSl9dmFyIF9uPWk9PntpZihBPWksZCl0aHJvdyBObyhpKSxcInVud2luZFwiO2JuKGkpfSxmdD1bXSxGdD1bXSxWbz1bXSxTdD17fSxXbz1pPT57dmFyIHU9aS54ZDtkZWxldGUgU3RbdV0sZnQucHVzaChpKSxGdC5zcGxpY2UoRnQuaW5kZXhPZihpKSwxKSxpLnhkPTAsTmkodSl9O2Z1bmN0aW9uIExvKCl7Vm8uZm9yRWFjaChpPT5pKCkpfXZhciBHbz1pPT5uZXcgUHJvbWlzZSh1PT57aS5vbm1lc3NhZ2U9Zz0+e3ZhciB4PShnPWcuZGF0YSkueWQ7aWYoZy5FZCYmZy5FZCE9Z3IoKSl7dmFyIEk9U3RbZy5FZF07ST9JLnBvc3RNZXNzYWdlKGcsZy5MZCk6dihgSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIiR7eH1cIiB0byB0YXJnZXQgcHRocmVhZCAke2cuRWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIHg9PT1cImNoZWNrTWFpbGJveFwiP3VyKCk6eD09PVwic3Bhd25UaHJlYWRcIj9VbyhnKTp4PT09XCJjbGVhbnVwVGhyZWFkXCI/V28oU3RbZy5lZV0pOng9PT1cImxvYWRlZFwiPyhpLmxvYWRlZD0hMCx1KGkpKTp4PT09XCJhbGVydFwiP2FsZXJ0KGBUaHJlYWQgJHtnLmZlfTogJHtnLnRleHR9YCk6Zy50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP2kucG9zdE1lc3NhZ2UoZyk6eD09PVwiY2FsbEhhbmRsZXJcIj9yW2cuTmRdKC4uLmcuYXJncyk6eCYmdihgd29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kICR7eH1gKX0saS5vbmVycm9yPWc9Pnt0aHJvdyB2KGB3b3JrZXIgc2VudCBhbiBlcnJvciEgJHtnLmZpbGVuYW1lfToke2cubGluZW5vfTogJHtnLm1lc3NhZ2V9YCksZ307dmFyIGMsbT1bXTtmb3IoYyBvZltdKXIucHJvcGVydHlJc0VudW1lcmFibGUoYykmJm0ucHVzaChjKTtpLnBvc3RNZXNzYWdlKHt5ZDpcImxvYWRcIixPZDptLGhlOlQsaWU6Q30pfSk7ZnVuY3Rpb24gSG8oKXt2YXIgaT1uZXcgV29ya2VyKGltcG9ydC5tZXRhLnVybC5zdGFydHNXaXRoKFwiZmlsZTpcIik/bmV3IFVSTChcIm9ydC5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCk6bmV3IFVSTChpbXBvcnQubWV0YS51cmwpLHt0eXBlOlwibW9kdWxlXCIsd29ya2VyRGF0YTpcImVtLXB0aHJlYWRcIixuYW1lOlwiZW0tcHRocmVhZFwifSk7ZnQucHVzaChpKX12YXIgY3A9aT0+e2JlKCk7dmFyIHU9UigpW2krNTI+Pj4yPj4+MF07aT1SKClbaSs1Nj4+PjI+Pj4wXSxMaSh1LHUtaSksb2UodSl9LHBwPShpLHUpPT57bXQ9MCxpPVJuKGksdSksMDxtdD9BPWk6Qm4oaSl9LHNyPVtdO2Z1bmN0aW9uIG1wKGkpe3ZhciB1PW5ldyB3bihpPj4+PTApO2lmKFooKVt1LndkKzEyPj4+MF09PTApe3ZhciBjPTE7WigpW3Uud2QrMTI+Pj4wXT1jfXJldHVybiBjPTAsWigpW3Uud2QrMTM+Pj4wXT1jLHNyLnB1c2godSksSGkoaSkscWkoaSl9dmFyIER0PTAsZnA9KCk9PntzZSgwLDApO3ZhciBpPXNyLnBvcCgpO0dpKGkuR2QpLER0PTB9O2NsYXNzIHdue2NvbnN0cnVjdG9yKHUpe3RoaXMuR2Q9dSx0aGlzLndkPXUtMjR9fWZ1bmN0aW9uIGhwKGkpe3Rocm93IER0fHw9aT4+PjAsRHR9dmFyIHZuPWk9Pnt2YXIgdT1EdDtpZighdSlyZXR1cm4gS3QoMCksMDt2YXIgYz1uZXcgd24odSk7UigpW2Mud2QrMTY+Pj4yPj4+MF09dTt2YXIgbT1SKClbYy53ZCs0Pj4+Mj4+PjBdO2lmKCFtKXJldHVybiBLdCgwKSx1O2Zvcih2YXIgZyBvZiBpKXtpZihnPT09MHx8Zz09PW0pYnJlYWs7aWYoRmkoZyxtLGMud2QrMTYpKXJldHVybiBLdChnKSx1fXJldHVybiBLdChtKSx1fTtmdW5jdGlvbiBncCgpe3JldHVybiB2bihbXSl9ZnVuY3Rpb24geXAoaSl7cmV0dXJuIHZuKFtpPj4+MF0pfWZ1bmN0aW9uIGJwKGksdSl7cmV0dXJuIHZuKFtpPj4+MCx1Pj4+MF0pfXZhciBfcD0oKT0+e3ZhciBpPXNyLnBvcCgpO2l8fHV0KFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciB1PWkuR2Q7aWYoWigpW2kud2QrMTM+Pj4wXT09MCl7c3IucHVzaChpKTt2YXIgYz0xO1ooKVtpLndkKzEzPj4+MF09YyxjPTAsWigpW2kud2QrMTI+Pj4wXT1jfXRocm93IER0PXV9O2Z1bmN0aW9uIHdwKGksdSxjKXt2YXIgbT1uZXcgd24oaT4+Pj0wKTt0aHJvdyB1Pj4+PTAsYz4+Pj0wLFIoKVttLndkKzE2Pj4+Mj4+PjBdPTAsUigpW20ud2QrND4+PjI+Pj4wXT11LFIoKVttLndkKzg+Pj4yPj4+MF09YyxEdD1pfWZ1bmN0aW9uIEZvKGksdSxjLG0pe3JldHVybiBkP1RlKDIsMSxpLHUsYyxtKTpxbyhpLHUsYyxtKX1mdW5jdGlvbiBxbyhpLHUsYyxtKXtpZihpPj4+PTAsYz4+Pj0wLG0+Pj49MCxsPT09dm9pZCAwKXJldHVybiA2O3ZhciBnPVtdO3JldHVybiBkJiZnLmxlbmd0aD09PTA/Rm8oaSx1Pj4+PTAsYyxtKTooaT17Y2U6Yyx4ZDppLEZkOm0sTGQ6Z30sZD8oaS55ZD1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoaSxnKSwwKTpVbyhpKSl9dmFyIEtvPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXI6dm9pZCAwLGpvPShpLHU9MCxjPU5hTik9Pnt2YXIgbT0odT4+Pj0wKStjO2ZvcihjPXU7aVtjXSYmIShjPj1tKTspKytjO2lmKDE2PGMtdSYmaS5idWZmZXImJktvKXJldHVybiBLby5kZWNvZGUoaS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9pLnN1YmFycmF5KHUsYyk6aS5zbGljZSh1LGMpKTtmb3IobT1cIlwiO3U8Yzspe3ZhciBnPWlbdSsrXTtpZigxMjgmZyl7dmFyIHg9NjMmaVt1KytdO2lmKCgyMjQmZyk9PTE5MiltKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZnKTw8Nnx4KTtlbHNle3ZhciBJPTYzJmlbdSsrXTs2NTUzNj4oZz0oMjQwJmcpPT0yMjQ/KDE1JmcpPDwxMnx4PDw2fEk6KDcmZyk8PDE4fHg8PDEyfEk8PDZ8NjMmaVt1KytdKT9tKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpOihnLT02NTUzNixtKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGc+PjEwLDU2MzIwfDEwMjMmZykpfX1lbHNlIG0rPVN0cmluZy5mcm9tQ2hhckNvZGUoZyl9cmV0dXJuIG19LEFlPShpLHUpPT4oaT4+Pj0wKT9qbyhwZSgpLGksdSk6XCJcIjtmdW5jdGlvbiBabyhpLHUsYyl7cmV0dXJuIGQ/VGUoMywxLGksdSxjKTowfWZ1bmN0aW9uIFFvKGksdSl7aWYoZClyZXR1cm4gVGUoNCwxLGksdSl9dmFyIFlvPWk9Pntmb3IodmFyIHU9MCxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBtPWkuY2hhckNvZGVBdChjKTsxMjc+PW0/dSsrOjIwNDc+PW0/dSs9Mjo1NTI5Njw9bSYmNTczNDM+PW0/KHUrPTQsKytjKTp1Kz0zfXJldHVybiB1fSxCdD0oaSx1LGMpPT57dmFyIG09cGUoKTtpZih1Pj4+PTAsMDxjKXt2YXIgZz11O2M9dStjLTE7Zm9yKHZhciB4PTA7eDxpLmxlbmd0aDsrK3gpe3ZhciBJPWkuY2hhckNvZGVBdCh4KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmaS5jaGFyQ29kZUF0KCsreCkpLDEyNz49SSl7aWYodT49YylicmVhazttW3UrKz4+PjBdPUl9ZWxzZXtpZigyMDQ3Pj1JKXtpZih1KzE+PWMpYnJlYWs7bVt1Kys+Pj4wXT0xOTJ8ST4+Nn1lbHNle2lmKDY1NTM1Pj1JKXtpZih1KzI+PWMpYnJlYWs7bVt1Kys+Pj4wXT0yMjR8ST4+MTJ9ZWxzZXtpZih1KzM+PWMpYnJlYWs7bVt1Kys+Pj4wXT0yNDB8ST4+MTgsbVt1Kys+Pj4wXT0xMjh8ST4+MTImNjN9bVt1Kys+Pj4wXT0xMjh8ST4+NiY2M31tW3UrKz4+PjBdPTEyOHw2MyZJfX1tW3U+Pj4wXT0wLGk9dS1nfWVsc2UgaT0wO3JldHVybiBpfTtmdW5jdGlvbiBYbyhpLHUpe2lmKGQpcmV0dXJuIFRlKDUsMSxpLHUpfWZ1bmN0aW9uIEpvKGksdSxjKXtpZihkKXJldHVybiBUZSg2LDEsaSx1LGMpfWZ1bmN0aW9uIGVpKGksdSxjKXtyZXR1cm4gZD9UZSg3LDEsaSx1LGMpOjB9ZnVuY3Rpb24gdGkoaSx1KXtpZihkKXJldHVybiBUZSg4LDEsaSx1KX1mdW5jdGlvbiByaShpLHUsYyl7aWYoZClyZXR1cm4gVGUoOSwxLGksdSxjKX1mdW5jdGlvbiBuaShpLHUsYyxtKXtpZihkKXJldHVybiBUZSgxMCwxLGksdSxjLG0pfWZ1bmN0aW9uIG9pKGksdSxjLG0pe2lmKGQpcmV0dXJuIFRlKDExLDEsaSx1LGMsbSl9ZnVuY3Rpb24gaWkoaSx1LGMsbSl7aWYoZClyZXR1cm4gVGUoMTIsMSxpLHUsYyxtKX1mdW5jdGlvbiBhaShpKXtpZihkKXJldHVybiBUZSgxMywxLGkpfWZ1bmN0aW9uIHNpKGksdSl7aWYoZClyZXR1cm4gVGUoMTQsMSxpLHUpfWZ1bmN0aW9uIHVpKGksdSxjKXtpZihkKXJldHVybiBUZSgxNSwxLGksdSxjKX12YXIgZGksaHQsdnA9KCk9PnV0KFwiXCIpLFhlPWk9Pntmb3IodmFyIHU9XCJcIjtwZSgpW2k+Pj4wXTspdSs9ZGlbcGUoKVtpKys+Pj4wXV07cmV0dXJuIHV9LCRuPXt9LHhuPXt9LCRwPXt9O2Z1bmN0aW9uIGR0KGksdSxjPXt9KXtyZXR1cm4gZnVuY3Rpb24obSxnLHg9e30pe3ZhciBJPWcubmFtZTtpZighbSl0aHJvdyBuZXcgaHQoYHR5cGUgXCIke0l9XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKHhuLmhhc093blByb3BlcnR5KG0pKXtpZih4LlBkKXJldHVybjt0aHJvdyBuZXcgaHQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke0l9JyB0d2ljZWApfXhuW21dPWcsZGVsZXRlICRwW21dLCRuLmhhc093blByb3BlcnR5KG0pJiYoZz0kblttXSxkZWxldGUgJG5bbV0sZy5mb3JFYWNoKHo9PnooKSkpfShpLHUsYyl9dmFyIGxpPShpLHUsYyk9Pntzd2l0Y2godSl7Y2FzZSAxOnJldHVybiBjP209PlooKVttPj4+MF06bT0+cGUoKVttPj4+MF07Y2FzZSAyOnJldHVybiBjP209PmtlKClbbT4+PjE+Pj4wXTptPT5TZSgpW20+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBjP209PkQoKVttPj4+Mj4+PjBdOm09PlIoKVttPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gYz9tPT5XW20+Pj4zXTptPT5KW20+Pj4zXTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHt1fSk6ICR7aX1gKX19O2Z1bmN0aW9uIHhwKGksdSxjKXtjPj4+PTAsZHQoaT4+Pj0wLHtuYW1lOnU9WGUodT4+PjApLGZyb21XaXJlVHlwZTptPT5tLHRvV2lyZVR5cGU6ZnVuY3Rpb24obSxnKXtpZih0eXBlb2YgZyE9XCJiaWdpbnRcIiYmdHlwZW9mIGchPVwibnVtYmVyXCIpdGhyb3cgZz1nPT09bnVsbD9cIm51bGxcIjoobT10eXBlb2YgZyk9PVwib2JqZWN0XCJ8fG09PT1cImFycmF5XCJ8fG09PT1cImZ1bmN0aW9uXCI/Zy50b1N0cmluZygpOlwiXCIrZyxuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29udmVydCBcIiR7Z31cIiB0byAke3RoaXMubmFtZX1gKTtyZXR1cm4gdHlwZW9mIGc9PVwibnVtYmVyXCImJihnPUJpZ0ludChnKSksZ30semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6bGkodSxjLHUuaW5kZXhPZihcInVcIik9PS0xKSxBZDpudWxsfSl9dmFyIGd0PTg7ZnVuY3Rpb24gU3AoaSx1LGMsbSl7ZHQoaT4+Pj0wLHtuYW1lOnU9WGUodT4+PjApLGZyb21XaXJlVHlwZTpmdW5jdGlvbihnKXtyZXR1cm4hIWd9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZyx4KXtyZXR1cm4geD9jOm19LHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKGcpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShwZSgpW2c+Pj4wXSl9LEFkOm51bGx9KX12YXIgU249W10sbHQ9W107ZnVuY3Rpb24gVG4oaSl7OTwoaT4+Pj0wKSYmLS1sdFtpKzFdPT0wJiYobHRbaV09dm9pZCAwLFNuLnB1c2goaSkpfXZhciBSZT1pPT57aWYoIWkpdGhyb3cgbmV3IGh0KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIraSk7cmV0dXJuIGx0W2ldfSxXZT1pPT57c3dpdGNoKGkpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IHU9U24ucG9wKCl8fGx0Lmxlbmd0aDtyZXR1cm4gbHRbdV09aSxsdFt1KzFdPTEsdX19O2Z1bmN0aW9uIENuKGkpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShSKClbaT4+PjI+Pj4wXSl9dmFyIFRwPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOmk9Pnt2YXIgdT1SZShpKTtyZXR1cm4gVG4oaSksdX0sdG9XaXJlVHlwZTooaSx1KT0+V2UodSksemQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sQWQ6bnVsbH07ZnVuY3Rpb24gQ3AoaSl7cmV0dXJuIGR0KGk+Pj4wLFRwKX12YXIgSXA9KGksdSk9Pntzd2l0Y2godSl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoWSgpW2M+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShmZSgpW2M+Pj4zPj4+MF0pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7dX0pOiAke2l9YCl9fTtmdW5jdGlvbiBBcChpLHUsYyl7Yz4+Pj0wLGR0KGk+Pj49MCx7bmFtZTp1PVhlKHU+Pj4wKSxmcm9tV2lyZVR5cGU6bT0+bSx0b1dpcmVUeXBlOihtLGcpPT5nLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOklwKHUsYyksQWQ6bnVsbH0pfWZ1bmN0aW9uIGtwKGksdSxjLG0sZyl7aWYoaT4+Pj0wLGM+Pj49MCx1PVhlKHU+Pj4wKSxnPT09LTEmJihnPTQyOTQ5NjcyOTUpLGc9ej0+eixtPT09MCl7dmFyIHg9MzItOCpjO2c9ej0+ejw8eD4+Pnh9dmFyIEk9dS5pbmNsdWRlcyhcInVuc2lnbmVkXCIpP2Z1bmN0aW9uKHosQil7cmV0dXJuIEI+Pj4wfTpmdW5jdGlvbih6LEIpe3JldHVybiBCfTtkdChpLHtuYW1lOnUsZnJvbVdpcmVUeXBlOmcsdG9XaXJlVHlwZTpJLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxpKHUsYyxtIT09MCksQWQ6bnVsbH0pfWZ1bmN0aW9uIEVwKGksdSxjKXtmdW5jdGlvbiBtKHgpe3ZhciBJPVIoKVt4Pj4+Mj4+PjBdO3JldHVybiB4PVIoKVt4KzQ+Pj4yPj4+MF0sbmV3IGcoWigpLmJ1ZmZlcix4LEkpfXZhciBnPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSxCaWdJbnQ2NEFycmF5LEJpZ1VpbnQ2NEFycmF5XVt1XTtkdChpPj4+PTAse25hbWU6Yz1YZShjPj4+MCksZnJvbVdpcmVUeXBlOm0semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6bX0se1BkOiEwfSl9ZnVuY3Rpb24gUHAoaSx1KXtkdChpPj4+PTAse25hbWU6dT1YZSh1Pj4+MCksZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGMpe2Zvcih2YXIgbSxnPVIoKVtjPj4+Mj4+PjBdLHg9Yys0LEk9eCx6PTA7ejw9ZzsrK3ope3ZhciBCPXgrejt6IT1nJiZwZSgpW0I+Pj4wXSE9MHx8KEk9QWUoSSxCLUkpLG09PT12b2lkIDA/bT1JOihtKz1cIlxcMFwiLG0rPUkpLEk9QisxKX1yZXR1cm4gZXQoYyksbX0sdG9XaXJlVHlwZTpmdW5jdGlvbihjLG0pe20gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKG09bmV3IFVpbnQ4QXJyYXkobSkpO3ZhciBnPXR5cGVvZiBtPT1cInN0cmluZ1wiO2lmKCEoZ3x8bSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fG0gaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8bSBpbnN0YW5jZW9mIEludDhBcnJheSkpdGhyb3cgbmV3IGh0KFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTt2YXIgeD1nP1lvKG0pOm0ubGVuZ3RoLEk9eXIoNCt4KzEpLHo9SSs0O2lmKFIoKVtJPj4+Mj4+PjBdPXgsZylCdChtLHoseCsxKTtlbHNlIGlmKGcpZm9yKGc9MDtnPHg7KytnKXt2YXIgQj1tLmNoYXJDb2RlQXQoZyk7aWYoMjU1PEIpdGhyb3cgZXQoSSksbmV3IGh0KFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpO3BlKClbeitnPj4+MF09Qn1lbHNlIGZvcihnPTA7Zzx4OysrZylwZSgpW3orZz4+PjBdPW1bZ107cmV0dXJuIGMhPT1udWxsJiZjLnB1c2goZXQsSSksSX0semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sQWQoYyl7ZXQoYyl9fSl9dmFyIGNpPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKTp2b2lkIDAsenA9KGksdSk9Pntmb3IodmFyIGM9aT4+MSxtPWMrdS8yOyEoYz49bSkmJlNlKClbYz4+PjBdOykrK2M7aWYoMzI8KGM8PD0xKS1pJiZjaSlyZXR1cm4gY2kuZGVjb2RlKHBlKCkuc2xpY2UoaSxjKSk7Zm9yKGM9XCJcIixtPTA7IShtPj11LzIpOysrbSl7dmFyIGc9a2UoKVtpKzIqbT4+PjE+Pj4wXTtpZihnPT0wKWJyZWFrO2MrPVN0cmluZy5mcm9tQ2hhckNvZGUoZyl9cmV0dXJuIGN9LE9wPShpLHUsYyk9PntpZihjPz89MjE0NzQ4MzY0NywyPmMpcmV0dXJuIDA7dmFyIG09dTtjPShjLT0yKTwyKmkubGVuZ3RoP2MvMjppLmxlbmd0aDtmb3IodmFyIGc9MDtnPGM7KytnKXt2YXIgeD1pLmNoYXJDb2RlQXQoZyk7a2UoKVt1Pj4+MT4+PjBdPXgsdSs9Mn1yZXR1cm4ga2UoKVt1Pj4+MT4+PjBdPTAsdS1tfSxEcD1pPT4yKmkubGVuZ3RoLEJwPShpLHUpPT57Zm9yKHZhciBjPTAsbT1cIlwiOyEoYz49dS80KTspe3ZhciBnPUQoKVtpKzQqYz4+PjI+Pj4wXTtpZihnPT0wKWJyZWFrOysrYyw2NTUzNjw9Zz8oZy09NjU1MzYsbSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxnPj4xMCw1NjMyMHwxMDIzJmcpKTptKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfXJldHVybiBtfSxNcD0oaSx1LGMpPT57aWYodT4+Pj0wLGM/Pz0yMTQ3NDgzNjQ3LDQ+YylyZXR1cm4gMDt2YXIgbT11O2M9bStjLTQ7Zm9yKHZhciBnPTA7ZzxpLmxlbmd0aDsrK2cpe3ZhciB4PWkuY2hhckNvZGVBdChnKTtpZig1NTI5Njw9eCYmNTczNDM+PXgmJih4PTY1NTM2KygoMTAyMyZ4KTw8MTApfDEwMjMmaS5jaGFyQ29kZUF0KCsrZykpLEQoKVt1Pj4+Mj4+PjBdPXgsKHUrPTQpKzQ+YylicmVha31yZXR1cm4gRCgpW3U+Pj4yPj4+MF09MCx1LW19LFJwPWk9Pntmb3IodmFyIHU9MCxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBtPWkuY2hhckNvZGVBdChjKTs1NTI5Njw9bSYmNTczNDM+PW0mJisrYyx1Kz00fXJldHVybiB1fTtmdW5jdGlvbiBVcChpLHUsYyl7aWYoaT4+Pj0wLHU+Pj49MCxjPVhlKGM+Pj49MCksdT09PTIpdmFyIG09enAsZz1PcCx4PURwLEk9ej0+U2UoKVt6Pj4+MT4+PjBdO2Vsc2UgdT09PTQmJihtPUJwLGc9TXAseD1ScCxJPXo9PlIoKVt6Pj4+Mj4+PjBdKTtkdChpLHtuYW1lOmMsZnJvbVdpcmVUeXBlOno9Pntmb3IodmFyIEIsTD1SKClbej4+PjI+Pj4wXSxxPXorNCxYPTA7WDw9TDsrK1gpe3ZhciB1ZT16KzQrWCp1O1ghPUwmJkkodWUpIT0wfHwocT1tKHEsdWUtcSksQj09PXZvaWQgMD9CPXE6KEIrPVwiXFwwXCIsQis9cSkscT11ZSt1KX1yZXR1cm4gZXQoeiksQn0sdG9XaXJlVHlwZTooeixCKT0+e2lmKHR5cGVvZiBCIT1cInN0cmluZ1wiKXRocm93IG5ldyBodChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtjfWApO3ZhciBMPXgoQikscT15cig0K0wrdSk7cmV0dXJuIFIoKVtxPj4+Mj4+PjBdPUwvdSxnKEIscSs0LEwrdSkseiE9PW51bGwmJnoucHVzaChldCxxKSxxfSx6ZDpndCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixBZCh6KXtldCh6KX19KX1mdW5jdGlvbiBOcChpLHUpe2R0KGk+Pj49MCx7UWQ6ITAsbmFtZTp1PVhlKHU+Pj4wKSx6ZDowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX1mdW5jdGlvbiBWcChpKXtEbihpPj4+MCwhcywxLCFhLDEzMTA3MiwhMSksTG8oKX12YXIgSW49aT0+e2lmKCFlZSl0cnl7aWYoaSgpLCEoMDxtdCkpdHJ5e2Q/Qm4oQSk6X24oQSl9Y2F0Y2godSl7dSBpbnN0YW5jZW9mIGdufHx1PT1cInVud2luZFwifHxfKDAsdSl9fWNhdGNoKHUpe3UgaW5zdGFuY2VvZiBnbnx8dT09XCJ1bndpbmRcInx8XygwLHUpfX07ZnVuY3Rpb24gQW4oaSl7aT4+Pj0wLHR5cGVvZiBBdG9taWNzLmdlPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLmdlKEQoKSxpPj4+MixpKS52YWx1ZS50aGVuKHVyKSxpKz0xMjgsQXRvbWljcy5zdG9yZShEKCksaT4+PjIsMSkpfXZhciB1cj0oKT0+e3ZhciBpPWdyKCk7aSYmKEFuKGkpLEluKFdpKSl9O2Z1bmN0aW9uIFdwKGksdSl7KGk+Pj49MCk9PXU+Pj4wP3NldFRpbWVvdXQodXIpOmQ/cG9zdE1lc3NhZ2Uoe0VkOmkseWQ6XCJjaGVja01haWxib3hcIn0pOihpPVN0W2ldKSYmaS5wb3N0TWVzc2FnZSh7eWQ6XCJjaGVja01haWxib3hcIn0pfXZhciBrbj1bXTtmdW5jdGlvbiBMcChpLHUsYyxtLGcpe2Zvcih1Pj4+PTAsbS89Mixrbi5sZW5ndGg9bSxjPWc+Pj4wPj4+MyxnPTA7ZzxtO2crKylrbltnXT1XW2MrMipnXT9XW2MrMipnKzFdOmZlKClbYysyKmcrMT4+PjBdO3JldHVybih1P2huW3VdOkJtW2ldKSguLi5rbil9dmFyIEdwPSgpPT57bXQ9MH07ZnVuY3Rpb24gSHAoaSl7aT4+Pj0wLGQ/cG9zdE1lc3NhZ2Uoe3lkOlwiY2xlYW51cFRocmVhZFwiLGVlOml9KTpXbyhTdFtpXSl9ZnVuY3Rpb24gRnAoaSl7fXZhciBkcj0oaSx1KT0+e3ZhciBjPXhuW2ldO2lmKGM9PT12b2lkIDApdGhyb3cgaT1CaShpKSxjPVhlKGkpLGV0KGkpLG5ldyBodChgJHt1fSBoYXMgdW5rbm93biB0eXBlICR7Y31gKTtyZXR1cm4gY30scGk9KGksdSxjKT0+e3ZhciBtPVtdO3JldHVybiBpPWkudG9XaXJlVHlwZShtLGMpLG0ubGVuZ3RoJiYoUigpW3U+Pj4yPj4+MF09V2UobSkpLGl9O2Z1bmN0aW9uIHFwKGksdSxjKXtyZXR1cm4gdT4+Pj0wLGM+Pj49MCxpPVJlKGk+Pj4wKSx1PWRyKHUsXCJlbXZhbDo6YXNcIikscGkodSxjLGkpfWZ1bmN0aW9uIEtwKGksdSl7cmV0dXJuIHU+Pj49MCxpPVJlKGk+Pj4wKSwodT1kcih1LFwiZW12YWw6OmFzXCIpKS50b1dpcmVUeXBlKG51bGwsaSl9dmFyIGxyPWk9Pnt0cnl7aSgpfWNhdGNoKHUpe3V0KHUpfX0seXQ9MCxKZT1udWxsLG1pPTAsY3I9W10sZmk9e30saGk9e30sanA9MCxFbj1udWxsLFpwPVtdO2Z1bmN0aW9uIGdpKGkpe3JldHVybiBmdW5jdGlvbih1KXtpZighZWUpe2lmKHl0PT09MCl7dmFyIGM9ITEsbT0hMTt1KChnPTApPT57aWYoIWVlJiYobWk9ZyxjPSEwLG0pKXt5dD0yLGxyKCgpPT5OYShKZSkpLHR5cGVvZiBNYWluTG9vcDxcInVcIiYmTWFpbkxvb3AuTWQmJk1haW5Mb29wLnJlc3VtZSgpLGc9ITE7dHJ5e3ZhciB4PWZ1bmN0aW9uKCl7dmFyIEI9RCgpW0plKzg+Pj4yPj4+MF07cmV0dXJuIEI9VVtoaVtCXV0sLS1tdCxCKCl9KCl9Y2F0Y2goQil7eD1CLGc9ITB9dmFyIEk9ITE7aWYoIUplKXt2YXIgej1Fbjt6JiYoRW49bnVsbCwoZz96LnJlamVjdDp6LnJlc29sdmUpKHgpLEk9ITApfWlmKGcmJiFJKXRocm93IHh9fSksbT0hMCxjfHwoeXQ9MSxKZT1mdW5jdGlvbigpe3ZhciBnPXlyKDY1NTQ4KSx4PWcrMTI7UigpW2c+Pj4yPj4+MF09eCxSKClbZys0Pj4+Mj4+PjBdPXgrNjU1MzYseD1jclswXTt2YXIgST1maVt4XTtyZXR1cm4gST09PXZvaWQgMCYmKEk9anArKyxmaVt4XT1JLGhpW0ldPXgpLHg9SSxEKClbZys4Pj4+Mj4+PjBdPXgsZ30oKSx0eXBlb2YgTWFpbkxvb3A8XCJ1XCImJk1haW5Mb29wLk1kJiZNYWluTG9vcC5wYXVzZSgpLGxyKCgpPT5SYShKZSkpKX1lbHNlIHl0PT09Mj8oeXQ9MCxscihWYSksZXQoSmUpLEplPW51bGwsWnAuZm9yRWFjaChJbikpOnV0KGBpbnZhbGlkIHN0YXRlOiAke3l0fWApO3JldHVybiBtaX19KHU9PntpKCkudGhlbih1KX0pfWZ1bmN0aW9uIFFwKGkpe3JldHVybiBpPj4+PTAsZ2koYXN5bmMoKT0+e3ZhciB1PWF3YWl0IFJlKGkpO3JldHVybiBXZSh1KX0pfXZhciBwcj1bXTtmdW5jdGlvbiBZcChpLHUsYyxtKXtyZXR1cm4gYz4+Pj0wLG0+Pj49MCwoaT1wcltpPj4+MF0pKG51bGwsdT1SZSh1Pj4+MCksYyxtKX12YXIgWHA9e30sbXI9aT0+e3ZhciB1PVhwW2ldO3JldHVybiB1PT09dm9pZCAwP1hlKGkpOnV9O2Z1bmN0aW9uIEpwKGksdSxjLG0sZyl7cmV0dXJuIGM+Pj49MCxtPj4+PTAsZz4+Pj0wLChpPXByW2k+Pj4wXSkodT1SZSh1Pj4+MCksdVtjPW1yKGMpXSxtLGcpfXZhciB5aT0oKT0+dHlwZW9mIGdsb2JhbFRoaXM9PVwib2JqZWN0XCI/Z2xvYmFsVGhpczpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7ZnVuY3Rpb24gZW0oaSl7cmV0dXJuKGk+Pj49MCk9PTA/V2UoeWkoKSk6KGk9bXIoaSksV2UoeWkoKVtpXSkpfXZhciB0bT1pPT57dmFyIHU9cHIubGVuZ3RoO3JldHVybiBwci5wdXNoKGkpLHV9LHJtPShpLHUpPT57Zm9yKHZhciBjPUFycmF5KGkpLG09MDttPGk7KyttKWNbbV09ZHIoUigpW3UrNCptPj4+Mj4+PjBdLFwicGFyYW1ldGVyIFwiK20pO3JldHVybiBjfSxiaT0oaSx1KT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsXCJuYW1lXCIse3ZhbHVlOml9KTtmdW5jdGlvbiBubShpLHUsYyl7dmFyIG09KHU9cm0oaSx1Pj4+MCkpLnNoaWZ0KCk7aS0tO3ZhciBnPWByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZnVuYywgZGVzdHJ1Y3RvcnNSZWYsIGFyZ3MpIHtcbmAseD0wLEk9W107Yz09PTAmJkkucHVzaChcIm9ialwiKTtmb3IodmFyIHo9W1wicmV0VHlwZVwiXSxCPVttXSxMPTA7TDxpOysrTClJLnB1c2goXCJhcmdcIitMKSx6LnB1c2goXCJhcmdUeXBlXCIrTCksQi5wdXNoKHVbTF0pLGcrPWAgIHZhciBhcmcke0x9ID0gYXJnVHlwZSR7TH0ucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJncyR7eD9cIitcIit4OlwiXCJ9KTtcbmAseCs9dVtMXS56ZDtyZXR1cm4gZys9YCAgdmFyIHJ2ID0gJHtjPT09MT9cIm5ldyBmdW5jXCI6XCJmdW5jLmNhbGxcIn0oJHtJLmpvaW4oXCIsIFwiKX0pO1xuYCxtLlFkfHwoei5wdXNoKFwiZW12YWxfcmV0dXJuVmFsdWVcIiksQi5wdXNoKHBpKSxnKz1gICByZXR1cm4gZW12YWxfcmV0dXJuVmFsdWUocmV0VHlwZSwgZGVzdHJ1Y3RvcnNSZWYsIHJ2KTtcbmApLHoucHVzaChnK2B9O1xuYCksaT1mdW5jdGlvbihxKXt2YXIgWD1GdW5jdGlvbjtpZighKFggaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIFh9IHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uYCk7dmFyIHVlPWJpKFgubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtyZXR1cm4gdWUucHJvdG90eXBlPVgucHJvdG90eXBlLHVlPW5ldyB1ZSwocT1YLmFwcGx5KHVlLHEpKWluc3RhbmNlb2YgT2JqZWN0P3E6dWV9KHopKC4uLkIpLGM9YG1ldGhvZENhbGxlcjwoJHt1Lm1hcChxPT5xLm5hbWUpLmpvaW4oXCIsIFwiKX0pID0+ICR7bS5uYW1lfT5gLHRtKGJpKGMsaSkpfWZ1bmN0aW9uIG9tKGkpe3JldHVybiBpPW1yKGk+Pj4wKSxXZShyW2ldKX1mdW5jdGlvbiBpbShpLHUpe3JldHVybiB1Pj4+PTAsaT1SZShpPj4+MCksdT1SZSh1KSxXZShpW3VdKX1mdW5jdGlvbiBhbShpKXs5PChpPj4+PTApJiYobHRbaSsxXSs9MSl9ZnVuY3Rpb24gc20oKXtyZXR1cm4gV2UoW10pfWZ1bmN0aW9uIHVtKGkpe2k9UmUoaT4+PjApO2Zvcih2YXIgdT1BcnJheShpLmxlbmd0aCksYz0wO2M8aS5sZW5ndGg7YysrKXVbY109aVtjXTtyZXR1cm4gV2UodSl9ZnVuY3Rpb24gZG0oaSl7cmV0dXJuIFdlKG1yKGk+Pj4wKSl9ZnVuY3Rpb24gbG0oKXtyZXR1cm4gV2Uoe30pfWZ1bmN0aW9uIGNtKGkpe2Zvcih2YXIgdT1SZShpPj4+PTApO3UubGVuZ3RoOyl7dmFyIGM9dS5wb3AoKTt1LnBvcCgpKGMpfVRuKGkpfWZ1bmN0aW9uIHBtKGksdSxjKXt1Pj4+PTAsYz4+Pj0wLGk9UmUoaT4+PjApLHU9UmUodSksYz1SZShjKSxpW3VdPWN9ZnVuY3Rpb24gbW0oaSx1KXtyZXR1cm4gdT4+Pj0wLGk9KGk9ZHIoaT4+PjAsXCJfZW12YWxfdGFrZV92YWx1ZVwiKSkucmVhZFZhbHVlRnJvbVBvaW50ZXIodSksV2UoaSl9ZnVuY3Rpb24gZm0oaSx1KXtpPS05MDA3MTk5MjU0NzQwOTkyPml8fDkwMDcxOTkyNTQ3NDA5OTI8aT9OYU46TnVtYmVyKGkpLHU+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxEKClbdT4+PjI+Pj4wXT1pLmdldFVUQ1NlY29uZHMoKSxEKClbdSs0Pj4+Mj4+PjBdPWkuZ2V0VVRDTWludXRlcygpLEQoKVt1Kzg+Pj4yPj4+MF09aS5nZXRVVENIb3VycygpLEQoKVt1KzEyPj4+Mj4+PjBdPWkuZ2V0VVRDRGF0ZSgpLEQoKVt1KzE2Pj4+Mj4+PjBdPWkuZ2V0VVRDTW9udGgoKSxEKClbdSsyMD4+PjI+Pj4wXT1pLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxEKClbdSsyND4+PjI+Pj4wXT1pLmdldFVUQ0RheSgpLGk9KGkuZ2V0VGltZSgpLURhdGUuVVRDKGkuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsRCgpW3UrMjg+Pj4yPj4+MF09aX12YXIgX2k9aT0+aSU0PT0wJiYoaSUxMDAhPTB8fGklNDAwPT0wKSx3aT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSx2aT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBobShpLHUpe2k9LTkwMDcxOTkyNTQ3NDA5OTI+aXx8OTAwNzE5OTI1NDc0MDk5MjxpP05hTjpOdW1iZXIoaSksdT4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLEQoKVt1Pj4+Mj4+PjBdPWkuZ2V0U2Vjb25kcygpLEQoKVt1KzQ+Pj4yPj4+MF09aS5nZXRNaW51dGVzKCksRCgpW3UrOD4+PjI+Pj4wXT1pLmdldEhvdXJzKCksRCgpW3UrMTI+Pj4yPj4+MF09aS5nZXREYXRlKCksRCgpW3UrMTY+Pj4yPj4+MF09aS5nZXRNb250aCgpLEQoKVt1KzIwPj4+Mj4+PjBdPWkuZ2V0RnVsbFllYXIoKS0xOTAwLEQoKVt1KzI0Pj4+Mj4+PjBdPWkuZ2V0RGF5KCk7dmFyIGM9KF9pKGkuZ2V0RnVsbFllYXIoKSk/d2k6dmkpW2kuZ2V0TW9udGgoKV0raS5nZXREYXRlKCktMXwwO0QoKVt1KzI4Pj4+Mj4+PjBdPWMsRCgpW3UrMzY+Pj4yPj4+MF09LTYwKmkuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIG09bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtpPTB8KGMhPW0mJmkuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obSxjKSksRCgpW3UrMzI+Pj4yPj4+MF09aX1mdW5jdGlvbiBnbShpKXtpPj4+PTA7dmFyIHU9bmV3IERhdGUoRCgpW2krMjA+Pj4yPj4+MF0rMTkwMCxEKClbaSsxNj4+PjI+Pj4wXSxEKClbaSsxMj4+PjI+Pj4wXSxEKClbaSs4Pj4+Mj4+PjBdLEQoKVtpKzQ+Pj4yPj4+MF0sRCgpW2k+Pj4yPj4+MF0sMCksYz1EKClbaSszMj4+PjI+Pj4wXSxtPXUuZ2V0VGltZXpvbmVPZmZzZXQoKSxnPW5ldyBEYXRlKHUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCkseD1uZXcgRGF0ZSh1LmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9TWF0aC5taW4oeCxnKTtyZXR1cm4gMD5jP0QoKVtpKzMyPj4+Mj4+PjBdPSsoZyE9eCYmST09bSk6MDxjIT0oST09bSkmJihnPU1hdGgubWF4KHgsZyksdS5zZXRUaW1lKHUuZ2V0VGltZSgpKzZlNCooKDA8Yz9JOmcpLW0pKSksRCgpW2krMjQ+Pj4yPj4+MF09dS5nZXREYXkoKSxjPShfaSh1LmdldEZ1bGxZZWFyKCkpP3dpOnZpKVt1LmdldE1vbnRoKCldK3UuZ2V0RGF0ZSgpLTF8MCxEKClbaSsyOD4+PjI+Pj4wXT1jLEQoKVtpPj4+Mj4+PjBdPXUuZ2V0U2Vjb25kcygpLEQoKVtpKzQ+Pj4yPj4+MF09dS5nZXRNaW51dGVzKCksRCgpW2krOD4+PjI+Pj4wXT11LmdldEhvdXJzKCksRCgpW2krMTI+Pj4yPj4+MF09dS5nZXREYXRlKCksRCgpW2krMTY+Pj4yPj4+MF09dS5nZXRNb250aCgpLEQoKVtpKzIwPj4+Mj4+PjBdPXUuZ2V0WWVhcigpLGk9dS5nZXRUaW1lKCksQmlnSW50KGlzTmFOKGkpPy0xOmkvMWUzKX1mdW5jdGlvbiAkaShpLHUsYyxtLGcseCxJKXtyZXR1cm4gZD9UZSgxNiwxLGksdSxjLG0sZyx4LEkpOi01Mn1mdW5jdGlvbiB4aShpLHUsYyxtLGcseCl7aWYoZClyZXR1cm4gVGUoMTcsMSxpLHUsYyxtLGcseCl9dmFyIHF0PXt9LHltPSgpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpO2Z1bmN0aW9uIFNpKGksdSl7aWYoZClyZXR1cm4gVGUoMTgsMSxpLHUpO2lmKHF0W2ldJiYoY2xlYXJUaW1lb3V0KHF0W2ldLmlkKSxkZWxldGUgcXRbaV0pLCF1KXJldHVybiAwO3ZhciBjPXNldFRpbWVvdXQoKCk9PntkZWxldGUgcXRbaV0sSW4oKCk9PlZpKGkscGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSkpfSx1KTtyZXR1cm4gcXRbaV09e2lkOmMsa2U6dX0sMH1mdW5jdGlvbiBibShpLHUsYyxtKXtpPj4+PTAsdT4+Pj0wLGM+Pj49MCxtPj4+PTA7dmFyIGc9bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLHg9bmV3IERhdGUoZywwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7Zz1uZXcgRGF0ZShnLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgST1NYXRoLm1heCh4LGcpO1IoKVtpPj4+Mj4+PjBdPTYwKkksRCgpW3U+Pj4yPj4+MF09Kyh4IT1nKSxpPSh1PXo9Pnt2YXIgQj1NYXRoLmFicyh6KTtyZXR1cm5gVVRDJHswPD16P1wiLVwiOlwiK1wifSR7U3RyaW5nKE1hdGguZmxvb3IoQi82MCkpLnBhZFN0YXJ0KDIsXCIwXCIpfSR7U3RyaW5nKEIlNjApLnBhZFN0YXJ0KDIsXCIwXCIpfWB9KSh4KSx1PXUoZyksZzx4PyhCdChpLGMsMTcpLEJ0KHUsbSwxNykpOihCdChpLG0sMTcpLEJ0KHUsYywxNykpfXZhciBfbT0oKT0+RGF0ZS5ub3coKSx3bT0xO2Z1bmN0aW9uIHZtKGksdSxjKXtpZighKDA8PWkmJjM+PWkpKXJldHVybiAyODtpZihpPT09MClpPURhdGUubm93KCk7ZWxzZXtpZighd20pcmV0dXJuIDUyO2k9cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKX1yZXR1cm4gV1tjPj4+MD4+PjNdPUJpZ0ludChNYXRoLnJvdW5kKDFlNippKSksMH12YXIgUG49W10sVGk9KGksdSk9PntQbi5sZW5ndGg9MDtmb3IodmFyIGM7Yz1wZSgpW2krKz4+PjBdOyl7dmFyIG09YyE9MTA1O3UrPShtJj1jIT0xMTIpJiZ1JTg/NDowLFBuLnB1c2goYz09MTEyP1IoKVt1Pj4+Mj4+PjBdOmM9PTEwNj9XW3U+Pj4zXTpjPT0xMDU/RCgpW3U+Pj4yPj4+MF06ZmUoKVt1Pj4+Mz4+PjBdKSx1Kz1tPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uICRtKGksdSxjKXtyZXR1cm4gaT4+Pj0wLHU9VGkodT4+PjAsYz4+PjApLGhuW2ldKC4uLnUpfWZ1bmN0aW9uIHhtKGksdSxjKXtyZXR1cm4gaT4+Pj0wLHU9VGkodT4+PjAsYz4+PjApLGhuW2ldKC4uLnUpfXZhciBTbT0oKT0+e307ZnVuY3Rpb24gVG0oaSx1KXtyZXR1cm4gdihBZShpPj4+MCx1Pj4+MCkpfXZhciBDbT0oKT0+e3Rocm93IG10Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEltKCl7cmV0dXJuIDQyOTQ5MDE3NjB9dmFyIEFtPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiBrbSgpe3JldHVybiB1dChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gRW0oaSl7aT4+Pj0wO3ZhciB1PXBlKCkubGVuZ3RoO2lmKGk8PXV8fDQyOTQ5MDE3NjA8aSlyZXR1cm4hMTtmb3IodmFyIGM9MTs0Pj1jO2MqPTIpe3ZhciBtPXUqKDErLjIvYyk7bT1NYXRoLm1pbihtLGkrMTAwNjYzMjk2KTtlOnttPShNYXRoLm1pbig0Mjk0OTAxNzYwLDY1NTM2Kk1hdGguY2VpbChNYXRoLm1heChpLG0pLzY1NTM2KSktVC5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzZ8MDt0cnl7VC5ncm93KG0pLGJlKCk7dmFyIGc9MTticmVhayBlfWNhdGNoe31nPXZvaWQgMH1pZihnKXJldHVybiEwfXJldHVybiExfXZhciBmcj0oKT0+KHV0KFwiQ2Fubm90IHVzZSBjb252ZXJ0RnJhbWVUb1BDIChuZWVkZWQgYnkgX19idWlsdGluX3JldHVybl9hZGRyZXNzKSB3aXRob3V0IC1zVVNFX09GRlNFVF9DT05WRVJURVJcIiksMCksTXQ9e30sQ2k9aT0+e2kuZm9yRWFjaCh1PT57dmFyIGM9ZnIoKTtjJiYoTXRbY109dSl9KX07ZnVuY3Rpb24gUG0oKXt2YXIgaT1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCk7cmV0dXJuIGlbMF09PVwiRXJyb3JcIiYmaS5zaGlmdCgpLENpKGkpLE10LktkPWZyKCksTXQuYWU9aSxNdC5LZH1mdW5jdGlvbiB6bShpLHUsYyl7aWYoaT4+Pj0wLHU+Pj49MCxNdC5LZD09aSl2YXIgbT1NdC5hZTtlbHNlKG09RXJyb3IoKS5zdGFjay50b1N0cmluZygpLnNwbGl0KGBcbmApKVswXT09XCJFcnJvclwiJiZtLnNoaWZ0KCksQ2kobSk7Zm9yKHZhciBnPTM7bVtnXSYmZnIoKSE9aTspKytnO2ZvcihpPTA7aTxjJiZtW2krZ107KytpKUQoKVt1KzQqaT4+PjI+Pj4wXT1mcigpO3JldHVybiBpfXZhciB6bixPbj17fSxJaT0oKT0+e2lmKCF6bil7dmFyIGksdT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihpIGluIE9uKU9uW2ldPT09dm9pZCAwP2RlbGV0ZSB1W2ldOnVbaV09T25baV07dmFyIGM9W107Zm9yKGkgaW4gdSljLnB1c2goYCR7aX09JHt1W2ldfWApO3puPWN9cmV0dXJuIHpufTtmdW5jdGlvbiBBaShpLHUpe2lmKGQpcmV0dXJuIFRlKDE5LDEsaSx1KTtpPj4+PTAsdT4+Pj0wO3ZhciBjPTA7cmV0dXJuIElpKCkuZm9yRWFjaCgobSxnKT0+e3ZhciB4PXUrYztmb3IoZz1SKClbaSs0Kmc+Pj4yPj4+MF09eCx4PTA7eDxtLmxlbmd0aDsrK3gpWigpW2crKz4+PjBdPW0uY2hhckNvZGVBdCh4KTtaKClbZz4+PjBdPTAsYys9bS5sZW5ndGgrMX0pLDB9ZnVuY3Rpb24ga2koaSx1KXtpZihkKXJldHVybiBUZSgyMCwxLGksdSk7aT4+Pj0wLHU+Pj49MDt2YXIgYz1JaSgpO1IoKVtpPj4+Mj4+PjBdPWMubGVuZ3RoO3ZhciBtPTA7cmV0dXJuIGMuZm9yRWFjaChnPT5tKz1nLmxlbmd0aCsxKSxSKClbdT4+PjI+Pj4wXT1tLDB9ZnVuY3Rpb24gRWkoaSl7cmV0dXJuIGQ/VGUoMjEsMSxpKTo1Mn1mdW5jdGlvbiBQaShpLHUsYyxtKXtyZXR1cm4gZD9UZSgyMiwxLGksdSxjLG0pOjUyfWZ1bmN0aW9uIHppKGksdSxjLG0pe3JldHVybiBkP1RlKDIzLDEsaSx1LGMsbSk6NzB9dmFyIE9tPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBPaShpLHUsYyxtKXtpZihkKXJldHVybiBUZSgyNCwxLGksdSxjLG0pO3U+Pj49MCxjPj4+PTAsbT4+Pj0wO2Zvcih2YXIgZz0wLHg9MDt4PGM7eCsrKXt2YXIgST1SKClbdT4+PjI+Pj4wXSx6PVIoKVt1KzQ+Pj4yPj4+MF07dSs9ODtmb3IodmFyIEI9MDtCPHo7QisrKXt2YXIgTD1wZSgpW0krQj4+PjBdLHE9T21baV07TD09PTB8fEw9PT0xMD8oKGk9PT0xPyQ6dikoam8ocSkpLHEubGVuZ3RoPTApOnEucHVzaChMKX1nKz16fXJldHVybiBSKClbbT4+PjI+Pj4wXT1nLDB9ZnVuY3Rpb24gRG0oaSl7cmV0dXJuIGk+Pj4wfWR8fGZ1bmN0aW9uKCl7Zm9yKHZhciBpPXIubnVtVGhyZWFkcy0xO2ktLTspSG8oKTt5bi51bnNoaWZ0KCgpPT57eHQrKyxmdW5jdGlvbih1KXtkP3UoKTpQcm9taXNlLmFsbChmdC5tYXAoR28pKS50aGVuKHUpfSgoKT0+Qm8oKSl9KX0oKTtmb3IodmFyIERpPUFycmF5KDI1NiksaHI9MDsyNTY+aHI7KytocilEaVtocl09U3RyaW5nLmZyb21DaGFyQ29kZShocik7ZGk9RGksaHQ9ci5CaW5kaW5nRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihpKXtzdXBlcihpKSx0aGlzLm5hbWU9XCJCaW5kaW5nRXJyb3JcIn19LHIuSW50ZXJuYWxFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGkpe3N1cGVyKGkpLHRoaXMubmFtZT1cIkludGVybmFsRXJyb3JcIn19LGx0LnB1c2goMCwxLHZvaWQgMCwxLG51bGwsMSwhMCwxLCExLDEpLHIuY291bnRfZW12YWxfaGFuZGxlcz0oKT0+bHQubGVuZ3RoLzItNS1Tbi5sZW5ndGg7dmFyIFUsQm09W2JuLE5vLEZvLFpvLFFvLFhvLEpvLGVpLHRpLHJpLG5pLG9pLGlpLGFpLHNpLHVpLCRpLHhpLFNpLEFpLGtpLEVpLFBpLHppLE9pXTsoYXN5bmMgZnVuY3Rpb24oKXtmdW5jdGlvbiBpKG0sZyl7cmV0dXJuIFU9bS5leHBvcnRzLFU9ZnVuY3Rpb24oKXt2YXIgeD1VLEk9e307Zm9yKGxldFt6LEJdb2YgT2JqZWN0LmVudHJpZXMoeCkpSVt6XT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e2NyLnB1c2goeik7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7ZWV8fChjci5wb3AoKSxKZSYmeXQ9PT0xJiZjci5sZW5ndGg9PT0wJiYoeXQ9MCxtdCs9MSxscihVYSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLmxlKCkpKX19OkI7cmV0dXJuIEl9KCksVT1mdW5jdGlvbigpe3ZhciB4PVUsST1CPT5MPT5CKEwpPj4+MCx6PUI9PigpPT5CKCk+Pj4wO3JldHVybih4PU9iamVjdC5hc3NpZ24oe30seCkpLkNiPUkoeC5DYikseC5mYz16KHguZmMpLHguaWM9SSh4LmljKSx4LnZjPUkoeC52YykseC53Yz16KHgud2MpLHguQWM9SSh4LkFjKSx4fSgpLFZvLnB1c2goVS5qYyksQz1nLEJvKCksVX14dCsrO3ZhciB1PU1vKCk7aWYoci5pbnN0YW50aWF0ZVdhc20pcmV0dXJuIG5ldyBQcm9taXNlKG09PntyLmluc3RhbnRpYXRlV2FzbSh1LChnLHgpPT57aShnLHgpLG0oZy5leHBvcnRzKX0pfSk7aWYoZClyZXR1cm4gbmV3IFByb21pc2UobT0+e0ZlPWc9Pnt2YXIgeD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZyxNbygpKTttKGkoeCxnKSl9fSk7R3Q/Pz1yLmxvY2F0ZUZpbGU/ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsYik6YitcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmO3RyeXt2YXIgYz1hd2FpdCBhc3luYyBmdW5jdGlvbihtKXt2YXIgZz1HdDtpZighUSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT1cImZ1bmN0aW9uXCImJiFsZShnKSl0cnl7dmFyIHg9ZmV0Y2goZyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHgsbSl9Y2F0Y2goSSl7dihgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7SX1gKSx2KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIil9cmV0dXJuIGFzeW5jIGZ1bmN0aW9uKEkseil7dHJ5e3ZhciBCPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKEwpe2lmKCFRKXRyeXt2YXIgcT1hd2FpdCBmKEwpO3JldHVybiBuZXcgVWludDhBcnJheShxKX1jYXRjaHt9aWYoTD09R3QmJlEpTD1uZXcgVWludDhBcnJheShRKTtlbHNle2lmKCFoKXRocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO0w9aChMKX1yZXR1cm4gTH0oSSk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEIseil9Y2F0Y2goTCl7dihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtMfWApLHV0KEwpfX0oZyxtKX0odSk7cmV0dXJuIGkoYy5pbnN0YW5jZSxjLm1vZHVsZSl9Y2F0Y2gobSl7cmV0dXJuIG4obSksUHJvbWlzZS5yZWplY3QobSl9fSkoKTt2YXIgQmk9aT0+KEJpPVUuQ2IpKGkpLE1pPSgpPT4oTWk9VS5EYikoKTtyLl9PcnRJbml0PShpLHUpPT4oci5fT3J0SW5pdD1VLkViKShpLHUpLHIuX09ydEdldExhc3RFcnJvcj0oaSx1KT0+KHIuX09ydEdldExhc3RFcnJvcj1VLkZiKShpLHUpLHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShpLHUsYyxtLGcseCxJLHosQixMKT0+KHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPVUuR2IpKGksdSxjLG0sZyx4LEkseixCLEwpLHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShpLHUpPT4oci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9VS5IYikoaSx1KSxyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGksdSxjKT0+KHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1VLkliKShpLHUsYyksci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShpLHUsYyk9PihyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9VS5KYikoaSx1LGMpLHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1pPT4oci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPVUuS2IpKGkpLHIuX09ydENyZWF0ZVNlc3Npb249KGksdSxjKT0+KHIuX09ydENyZWF0ZVNlc3Npb249VS5MYikoaSx1LGMpLHIuX09ydFJlbGVhc2VTZXNzaW9uPWk9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbj1VLk1iKShpKSxyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShpLHUsYyk9PihyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PVUuTmIpKGksdSxjKSxyLl9PcnRHZXRJbnB1dE5hbWU9KGksdSk9PihyLl9PcnRHZXRJbnB1dE5hbWU9VS5PYikoaSx1KSxyLl9PcnRHZXRPdXRwdXROYW1lPShpLHUpPT4oci5fT3J0R2V0T3V0cHV0TmFtZT1VLlBiKShpLHUpLHIuX09ydEZyZWU9aT0+KHIuX09ydEZyZWU9VS5RYikoaSksci5fT3J0Q3JlYXRlVGVuc29yPShpLHUsYyxtLGcseCk9PihyLl9PcnRDcmVhdGVUZW5zb3I9VS5SYikoaSx1LGMsbSxnLHgpLHIuX09ydEdldFRlbnNvckRhdGE9KGksdSxjLG0sZyk9PihyLl9PcnRHZXRUZW5zb3JEYXRhPVUuU2IpKGksdSxjLG0sZyksci5fT3J0UmVsZWFzZVRlbnNvcj1pPT4oci5fT3J0UmVsZWFzZVRlbnNvcj1VLlRiKShpKSxyLl9PcnRDcmVhdGVSdW5PcHRpb25zPShpLHUsYyxtKT0+KHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9VS5VYikoaSx1LGMsbSksci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGksdSxjKT0+KHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PVUuVmIpKGksdSxjKSxyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1pPT4oci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9VS5XYikoaSksci5fT3J0Q3JlYXRlQmluZGluZz1pPT4oci5fT3J0Q3JlYXRlQmluZGluZz1VLlhiKShpKSxyLl9PcnRCaW5kSW5wdXQ9KGksdSxjKT0+KHIuX09ydEJpbmRJbnB1dD1VLlliKShpLHUsYyksci5fT3J0QmluZE91dHB1dD0oaSx1LGMsbSk9PihyLl9PcnRCaW5kT3V0cHV0PVUuWmIpKGksdSxjLG0pLHIuX09ydENsZWFyQm91bmRPdXRwdXRzPWk9PihyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1VLl9iKShpKSxyLl9PcnRSZWxlYXNlQmluZGluZz1pPT4oci5fT3J0UmVsZWFzZUJpbmRpbmc9VS4kYikoaSksci5fT3J0UnVuV2l0aEJpbmRpbmc9KGksdSxjLG0sZyk9PihyLl9PcnRSdW5XaXRoQmluZGluZz1VLmFjKShpLHUsYyxtLGcpLHIuX09ydFJ1bj0oaSx1LGMsbSxnLHgsSSx6KT0+KHIuX09ydFJ1bj1VLmJjKShpLHUsYyxtLGcseCxJLHopLHIuX09ydEVuZFByb2ZpbGluZz1pPT4oci5fT3J0RW5kUHJvZmlsaW5nPVUuY2MpKGkpLHIuX0pzZXBPdXRwdXQ9KGksdSxjKT0+KHIuX0pzZXBPdXRwdXQ9VS5kYykoaSx1LGMpLHIuX0pzZXBHZXROb2RlTmFtZT1pPT4oci5fSnNlcEdldE5vZGVOYW1lPVUuZWMpKGkpO3ZhciBncj0oKT0+KGdyPVUuZmMpKCksZXQ9ci5fZnJlZT1pPT4oZXQ9ci5fZnJlZT1VLmdjKShpKSx5cj1yLl9tYWxsb2M9aT0+KHlyPXIuX21hbGxvYz1VLmljKShpKSxEbj0oaSx1LGMsbSxnLHgpPT4oRG49VS5rYykoaSx1LGMsbSxnLHgpLFJpPSgpPT4oUmk9VS5sYykoKSxVaT0oaSx1LGMsbSxnKT0+KFVpPVUubWMpKGksdSxjLG0sZyksTmk9aT0+KE5pPVUubmMpKGkpLEJuPWk9PihCbj1VLm9jKShpKSxWaT0oaSx1KT0+KFZpPVUucGMpKGksdSksV2k9KCk9PihXaT1VLnFjKSgpLHNlPShpLHUpPT4oc2U9VS5yYykoaSx1KSxLdD1pPT4oS3Q9VS5zYykoaSksTGk9KGksdSk9PihMaT1VLnRjKShpLHUpLG9lPWk9PihvZT1VLnVjKShpKSxNbj1pPT4oTW49VS52YykoaSksaWU9KCk9PihpZT1VLndjKSgpLEdpPWk9PihHaT1VLnhjKShpKSxIaT1pPT4oSGk9VS55YykoaSksRmk9KGksdSxjKT0+KEZpPVUuemMpKGksdSxjKSxxaT1pPT4ocWk9VS5BYykoaSksS2k9ci5keW5DYWxsX2lpaT0oaSx1LGMpPT4oS2k9ci5keW5DYWxsX2lpaT1VLkJjKShpLHUsYyksamk9ci5keW5DYWxsX3ZpPShpLHUpPT4oamk9ci5keW5DYWxsX3ZpPVUuQ2MpKGksdSksUm49ci5keW5DYWxsX2lpPShpLHUpPT4oUm49ci5keW5DYWxsX2lpPVUuRGMpKGksdSksWmk9ci5keW5DYWxsX3ZpaT0oaSx1LGMpPT4oWmk9ci5keW5DYWxsX3ZpaT1VLkVjKShpLHUsYyksUWk9ci5keW5DYWxsX2lpaWk9KGksdSxjLG0pPT4oUWk9ci5keW5DYWxsX2lpaWk9VS5GYykoaSx1LGMsbSksWWk9ci5keW5DYWxsX3ZpaWk9KGksdSxjLG0pPT4oWWk9ci5keW5DYWxsX3ZpaWk9VS5HYykoaSx1LGMsbSksWGk9ci5keW5DYWxsX2lpaWlpPShpLHUsYyxtLGcpPT4oWGk9ci5keW5DYWxsX2lpaWlpPVUuSGMpKGksdSxjLG0sZyksSmk9ci5keW5DYWxsX3ZpaWlpPShpLHUsYyxtLGcpPT4oSmk9ci5keW5DYWxsX3ZpaWlpPVUuSWMpKGksdSxjLG0sZyksZWE9ci5keW5DYWxsX3ZpaWlpaWk9KGksdSxjLG0sZyx4LEkpPT4oZWE9ci5keW5DYWxsX3ZpaWlpaWk9VS5KYykoaSx1LGMsbSxnLHgsSSksdGE9ci5keW5DYWxsX3ZpaWlpaWlpPShpLHUsYyxtLGcseCxJLHopPT4odGE9ci5keW5DYWxsX3ZpaWlpaWlpPVUuS2MpKGksdSxjLG0sZyx4LEkseikscmE9ci5keW5DYWxsX2ppPShpLHUpPT4ocmE9ci5keW5DYWxsX2ppPVUuTGMpKGksdSksbmE9ci5keW5DYWxsX3Y9aT0+KG5hPXIuZHluQ2FsbF92PVUuTWMpKGkpLG9hPXIuZHluQ2FsbF92aWlpaWk9KGksdSxjLG0sZyx4KT0+KG9hPXIuZHluQ2FsbF92aWlpaWk9VS5OYykoaSx1LGMsbSxnLHgpLGlhPXIuZHluQ2FsbF9pPWk9PihpYT1yLmR5bkNhbGxfaT1VLk9jKShpKSxhYT1yLmR5bkNhbGxfZmlpPShpLHUsYyk9PihhYT1yLmR5bkNhbGxfZmlpPVUuUGMpKGksdSxjKSxzYT1yLmR5bkNhbGxfdmlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQik9PihzYT1yLmR5bkNhbGxfdmlpaWlpaWlpPVUuUWMpKGksdSxjLG0sZyx4LEkseixCKSx1YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSk9Pih1YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWk9VS5SYykoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKSxkYT1yLmR5bkNhbGxfamlpaT0oaSx1LGMsbSk9PihkYT1yLmR5bkNhbGxfamlpaT1VLlNjKShpLHUsYyxtKSxsYT1yLmR5bkNhbGxfZGlpPShpLHUsYyk9PihsYT1yLmR5bkNhbGxfZGlpPVUuVGMpKGksdSxjKSxjYT1yLmR5bkNhbGxfdmlpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIsTCk9PihjYT1yLmR5bkNhbGxfdmlpaWlpaWlpaT1VLlVjKShpLHUsYyxtLGcseCxJLHosQixMKSxwYT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEsWCk9PihwYT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpPVUuVmMpKGksdSxjLG0sZyx4LEkseixCLEwscSxYKSxtYT1yLmR5bkNhbGxfaWlpaWlpPShpLHUsYyxtLGcseCk9PihtYT1yLmR5bkNhbGxfaWlpaWlpPVUuV2MpKGksdSxjLG0sZyx4KSxmYT1yLmR5bkNhbGxfaWlqPShpLHUsYyk9PihmYT1yLmR5bkNhbGxfaWlqPVUuWGMpKGksdSxjKSxoYT1yLmR5bkNhbGxfaWlpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIsTCk9PihoYT1yLmR5bkNhbGxfaWlpaWlpaWlpaT1VLlljKShpLHUsYyxtLGcseCxJLHosQixMKSxnYT1yLmR5bkNhbGxfaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSk9PihnYT1yLmR5bkNhbGxfaWlpaWlpaWlpaWk9VS5aYykoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKSx5YT1yLmR5bkNhbGxfdmlqPShpLHUsYyk9Pih5YT1yLmR5bkNhbGxfdmlqPVUuX2MpKGksdSxjKSxiYT1yLmR5bkNhbGxfaWlpZj0oaSx1LGMsbSk9PihiYT1yLmR5bkNhbGxfaWlpZj1VLiRjKShpLHUsYyxtKSxfYT1yLmR5bkNhbGxfaWlpaj0oaSx1LGMsbSk9PihfYT1yLmR5bkNhbGxfaWlpaj1VLmFkKShpLHUsYyxtKSx3YT1yLmR5bkNhbGxfZmlpaT0oaSx1LGMsbSk9Pih3YT1yLmR5bkNhbGxfZmlpaT1VLmJkKShpLHUsYyxtKSx2YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+KHZhPXIuZHluQ2FsbF92aWlpaWlpaWlpaWlpaT1VLmNkKShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSksJGE9ci5keW5DYWxsX3ZqaWlpPShpLHUsYyxtLGcpPT4oJGE9ci5keW5DYWxsX3ZqaWlpPVUuZGQpKGksdSxjLG0sZykseGE9ci5keW5DYWxsX3ZpZj0oaSx1LGMpPT4oeGE9ci5keW5DYWxsX3ZpZj1VLmVkKShpLHUsYyksU2E9ci5keW5DYWxsX2lpaWlpaWk9KGksdSxjLG0sZyx4LEkpPT4oU2E9ci5keW5DYWxsX2lpaWlpaWk9VS5mZCkoaSx1LGMsbSxnLHgsSSksVGE9ci5keW5DYWxsX2lpaWlqPShpLHUsYyxtLGcpPT4oVGE9ci5keW5DYWxsX2lpaWlqPVUuZ2QpKGksdSxjLG0sZyksQ2E9ci5keW5DYWxsX2lpaWlpaWlpPShpLHUsYyxtLGcseCxJLHopPT4oQ2E9ci5keW5DYWxsX2lpaWlpaWlpPVUuaGQpKGksdSxjLG0sZyx4LEkseiksSWE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlKT0+KElhPXIuZHluQ2FsbF92aWlpaWlpaWlpaWlpPVUuaWQpKGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlKSxBYT1yLmR5bkNhbGxfZGlpaT0oaSx1LGMsbSk9PihBYT1yLmR5bkNhbGxfZGlpaT1VLmpkKShpLHUsYyxtKSxrYT1yLmR5bkNhbGxfamlpaWk9KGksdSxjLG0sZyk9PihrYT1yLmR5bkNhbGxfamlpaWk9VS5rZCkoaSx1LGMsbSxnKSxFYT1yLmR5bkNhbGxfdmlpaWo9KGksdSxjLG0sZyk9PihFYT1yLmR5bkNhbGxfdmlpaWo9VS5sZCkoaSx1LGMsbSxnKSxQYT1yLmR5bkNhbGxfZmlpaWk9KGksdSxjLG0sZyk9PihQYT1yLmR5bkNhbGxfZmlpaWk9VS5tZCkoaSx1LGMsbSxnKSx6YT1yLmR5bkNhbGxfdmlpaWY9KGksdSxjLG0sZyk9Pih6YT1yLmR5bkNhbGxfdmlpaWY9VS5uZCkoaSx1LGMsbSxnKSxPYT1yLmR5bkNhbGxfZGlpaWk9KGksdSxjLG0sZyk9PihPYT1yLmR5bkNhbGxfZGlpaWk9VS5vZCkoaSx1LGMsbSxnKSxEYT1yLmR5bkNhbGxfdmlpaWQ9KGksdSxjLG0sZyk9PihEYT1yLmR5bkNhbGxfdmlpaWQ9VS5wZCkoaSx1LGMsbSxnKSxCYT1yLmR5bkNhbGxfaWlpaWppaT0oaSx1LGMsbSxnLHgsSSk9PihCYT1yLmR5bkNhbGxfaWlpaWppaT1VLnFkKShpLHUsYyxtLGcseCxJKSxNYT1yLmR5bkNhbGxfaWlpaWlpaj0oaSx1LGMsbSxnLHgsSSk9PihNYT1yLmR5bkNhbGxfaWlpaWlpaj1VLnJkKShpLHUsYyxtLGcseCxJKSxSYT1pPT4oUmE9VS5zZCkoaSksVWE9KCk9PihVYT1VLnRkKSgpLE5hPWk9PihOYT1VLnVkKShpKSxWYT0oKT0+KFZhPVUudmQpKCk7ZnVuY3Rpb24gTW0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e1ppKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gUm0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3JldHVybiBLaShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIFVtKGksdSl7dmFyIGM9aWUoKTt0cnl7amkoaSx1KX1jYXRjaChtKXtpZihvZShjKSxtIT09bSswKXRocm93IG07c2UoMSwwKX19ZnVuY3Rpb24gTm0oaSx1KXt2YXIgYz1pZSgpO3RyeXtyZXR1cm4gUm4oaSx1KX1jYXRjaChtKXtpZihvZShjKSxtIT09bSswKXRocm93IG07c2UoMSwwKX19ZnVuY3Rpb24gVm0oaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIFFpKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBXbShpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e0ppKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIExtKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7cmV0dXJuIFhpKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIEdtKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e1lpKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBIbShpLHUsYyxtLGcseCxJKXt2YXIgej1pZSgpO3RyeXtyZXR1cm4gU2EoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fWZ1bmN0aW9uIEZtKGkpe3ZhciB1PWllKCk7dHJ5e25hKGkpfWNhdGNoKGMpe2lmKG9lKHUpLGMhPT1jKzApdGhyb3cgYztzZSgxLDApfX1mdW5jdGlvbiBxbShpLHUsYyl7dmFyIG09aWUoKTt0cnl7cmV0dXJuIGZhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gS20oaSx1LGMsbSxnLHgpe3ZhciBJPWllKCk7dHJ5e29hKGksdSxjLG0sZyx4KX1jYXRjaCh6KXtpZihvZShJKSx6IT09eiswKXRocm93IHo7c2UoMSwwKX19ZnVuY3Rpb24gam0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3lhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gWm0oaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7ZWEoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fWZ1bmN0aW9uIFFtKGksdSxjLG0sZyx4LEkseil7dmFyIEI9aWUoKTt0cnl7dGEoaSx1LGMsbSxnLHgsSSx6KX1jYXRjaChMKXtpZihvZShCKSxMIT09TCswKXRocm93IEw7c2UoMSwwKX19ZnVuY3Rpb24gWW0oaSx1LGMsbSxnLHgpe3ZhciBJPWllKCk7dHJ5e3JldHVybiBtYShpLHUsYyxtLGcseCl9Y2F0Y2goeil7aWYob2UoSSkseiE9PXorMCl0aHJvdyB6O3NlKDEsMCl9fWZ1bmN0aW9uIFhtKGksdSxjLG0sZyx4LEkseil7dmFyIEI9aWUoKTt0cnl7cmV0dXJuIENhKGksdSxjLG0sZyx4LEkseil9Y2F0Y2goTCl7aWYob2UoQiksTCE9PUwrMCl0aHJvdyBMO3NlKDEsMCl9fWZ1bmN0aW9uIEptKGksdSxjLG0sZyx4LEkseixCLEwpe3ZhciBxPWllKCk7dHJ5e2NhKGksdSxjLG0sZyx4LEkseixCLEwpfWNhdGNoKFgpe2lmKG9lKHEpLFghPT1YKzApdGhyb3cgWDtzZSgxLDApfX1mdW5jdGlvbiBlZihpLHUsYyxtLGcseCxJLHosQil7dmFyIEw9aWUoKTt0cnl7c2EoaSx1LGMsbSxnLHgsSSx6LEIpfWNhdGNoKHEpe2lmKG9lKEwpLHEhPT1xKzApdGhyb3cgcTtzZSgxLDApfX1mdW5jdGlvbiB0ZihpKXt2YXIgdT1pZSgpO3RyeXtyZXR1cm4gaWEoaSl9Y2F0Y2goYyl7aWYob2UodSksYyE9PWMrMCl0aHJvdyBjO3NlKDEsMCl9fWZ1bmN0aW9uIHJmKGksdSxjLG0sZyx4LEkseixCLEwpe3ZhciBxPWllKCk7dHJ5e3JldHVybiBoYShpLHUsYyxtLGcseCxJLHosQixMKX1jYXRjaChYKXtpZihvZShxKSxYIT09WCswKXRocm93IFg7c2UoMSwwKX19ZnVuY3Rpb24gbmYoaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3JldHVybiBhYShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIG9mKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiBkYShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7cmV0dXJuIHNlKDEsMCksMG59fWZ1bmN0aW9uIGFmKGksdSxjKXt2YXIgbT1pZSgpO3RyeXtyZXR1cm4gbGEoaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBzZihpLHUsYyxtLGcseCxJLHosQixMLHEsWCl7dmFyIHVlPWllKCk7dHJ5e3BhKGksdSxjLG0sZyx4LEkseixCLEwscSxYKX1jYXRjaCgkZSl7aWYob2UodWUpLCRlIT09JGUrMCl0aHJvdyAkZTtzZSgxLDApfX1mdW5jdGlvbiB1ZihpLHUsYyxtLGcseCxJLHosQixMLHEpe3ZhciBYPWllKCk7dHJ5e3VhKGksdSxjLG0sZyx4LEkseixCLEwscSl9Y2F0Y2godWUpe2lmKG9lKFgpLHVlIT09dWUrMCl0aHJvdyB1ZTtzZSgxLDApfX1mdW5jdGlvbiBkZihpLHUsYyxtLGcseCxJLHosQixMLHEpe3ZhciBYPWllKCk7dHJ5e3JldHVybiBnYShpLHUsYyxtLGcseCxJLHosQixMLHEpfWNhdGNoKHVlKXtpZihvZShYKSx1ZSE9PXVlKzApdGhyb3cgdWU7c2UoMSwwKX19ZnVuY3Rpb24gbGYoaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIGJhKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBjZihpLHUsYyxtKXt2YXIgZz1pZSgpO3RyeXtyZXR1cm4gX2EoaSx1LGMsbSl9Y2F0Y2goeCl7aWYob2UoZykseCE9PXgrMCl0aHJvdyB4O3NlKDEsMCl9fWZ1bmN0aW9uIHBmKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiB3YShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gbWYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpe3ZhciBMZT1pZSgpO3RyeXt2YShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSl9Y2F0Y2goanQpe2lmKG9lKExlKSxqdCE9PWp0KzApdGhyb3cganQ7c2UoMSwwKX19ZnVuY3Rpb24gZmYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXskYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBoZihpLHUsYyl7dmFyIG09aWUoKTt0cnl7eGEoaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBnZihpLHUpe3ZhciBjPWllKCk7dHJ5e3JldHVybiByYShpLHUpfWNhdGNoKG0pe2lmKG9lKGMpLG0hPT1tKzApdGhyb3cgbTtyZXR1cm4gc2UoMSwwKSwwbn19ZnVuY3Rpb24geWYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtyZXR1cm4gVGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gYmYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUpe3ZhciAkZT1pZSgpO3RyeXtJYShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSl9Y2F0Y2goTGUpe2lmKG9lKCRlKSxMZSE9PUxlKzApdGhyb3cgTGU7c2UoMSwwKX19ZnVuY3Rpb24gX2YoaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIEFhKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiB3ZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBrYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtyZXR1cm4gc2UoMSwwKSwwbn19ZnVuY3Rpb24gdmYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtFYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiAkZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBQYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiB4ZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3phKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIFNmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7cmV0dXJuIE9hKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIFRmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7RGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gQ2YoaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7cmV0dXJuIEJhKGksdSxjLG0sZyx4LEkpfWNhdGNoKEIpe2lmKG9lKHopLEIhPT1CKzApdGhyb3cgQjtzZSgxLDApfX1mdW5jdGlvbiBJZihpLHUsYyxtLGcseCxJKXt2YXIgej1pZSgpO3RyeXtyZXR1cm4gTWEoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fXJldHVybiByLnN0YWNrU2F2ZT0oKT0+aWUoKSxyLnN0YWNrUmVzdG9yZT1pPT5vZShpKSxyLnN0YWNrQWxsb2M9aT0+TW4oaSksci5zZXRWYWx1ZT1mdW5jdGlvbihpLHUsYz1cImk4XCIpe3N3aXRjaChjLmVuZHNXaXRoKFwiKlwiKSYmKGM9XCIqXCIpLGMpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpaKClbaT4+PjBdPXU7YnJlYWs7Y2FzZVwiaTE2XCI6a2UoKVtpPj4+MT4+PjBdPXU7YnJlYWs7Y2FzZVwiaTMyXCI6RCgpW2k+Pj4yPj4+MF09dTticmVhaztjYXNlXCJpNjRcIjpXW2k+Pj4zXT1CaWdJbnQodSk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpZKClbaT4+PjI+Pj4wXT11O2JyZWFrO2Nhc2VcImRvdWJsZVwiOmZlKClbaT4+PjM+Pj4wXT11O2JyZWFrO2Nhc2VcIipcIjpSKClbaT4+PjI+Pj4wXT11O2JyZWFrO2RlZmF1bHQ6dXQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7Y31gKX19LHIuZ2V0VmFsdWU9ZnVuY3Rpb24oaSx1PVwiaThcIil7c3dpdGNoKHUuZW5kc1dpdGgoXCIqXCIpJiYodT1cIipcIiksdSl7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnJldHVybiBaKClbaT4+PjBdO2Nhc2VcImkxNlwiOnJldHVybiBrZSgpW2k+Pj4xPj4+MF07Y2FzZVwiaTMyXCI6cmV0dXJuIEQoKVtpPj4+Mj4+PjBdO2Nhc2VcImk2NFwiOnJldHVybiBXW2k+Pj4zXTtjYXNlXCJmbG9hdFwiOnJldHVybiBZKClbaT4+PjI+Pj4wXTtjYXNlXCJkb3VibGVcIjpyZXR1cm4gZmUoKVtpPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gUigpW2k+Pj4yPj4+MF07ZGVmYXVsdDp1dChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHt1fWApfX0sci5VVEY4VG9TdHJpbmc9QWUsci5zdHJpbmdUb1VURjg9QnQsci5sZW5ndGhCeXRlc1VURjg9WW8sZnVuY3Rpb24gaSgpe2lmKDA8eHQpSHQ9aTtlbHNlIGlmKGQpdChyKSxZZSgpO2Vsc2V7Zm9yKDswPHluLmxlbmd0aDspeW4uc2hpZnQoKShyKTswPHh0P0h0PWk6KHIuY2FsbGVkUnVuPSEwLGVlfHwoWWUoKSx0KHIpKSl9fSgpLHIuUFRSX1NJWkU9NCxvfSksQmY9d3MsTWY9Z2xvYmFsVGhpcy5zZWxmPy5uYW1lPy5zdGFydHNXaXRoKFwiZW0tcHRocmVhZFwiKTtNZiYmd3MoKX0pO3ZhciBUcyxSZixWZSxDcyxqbixVZixOZixJcyxWZix4cyxBcyxTcyxrcyxTcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHIoKTtUcz10eXBlb2YgbG9jYXRpb24+XCJ1XCI/dm9pZCAwOmxvY2F0aW9uLm9yaWdpbixSZj0oKT0+e2lmKCEhMSlyZXR1cm4gaW1wb3J0Lm1ldGEudXJsPy5zdGFydHNXaXRoKFwiZmlsZTpcIik/bmV3IFVSTChuZXcgVVJMKFwib3J0LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLFRzKS5ocmVmOmltcG9ydC5tZXRhLnVybH0sVmU9UmYoKSxDcz0oKT0+e2lmKFZlJiYhVmUuc3RhcnRzV2l0aChcImJsb2I6XCIpKXJldHVybiBWZS5zdWJzdHJpbmcoMCxWZS5sYXN0SW5kZXhPZihcIi9cIikrMSl9LGpuPShlLHQpPT57dHJ5e2xldCBuPXQ/P1ZlO3JldHVybihuP25ldyBVUkwoZSxuKTpuZXcgVVJMKGUpKS5vcmlnaW49PT1Uc31jYXRjaHtyZXR1cm4hMX19LFVmPShlLHQpPT57bGV0IG49dD8/VmU7dHJ5e3JldHVybihuP25ldyBVUkwoZSxuKTpuZXcgVVJMKGUpKS5ocmVmfWNhdGNoe3JldHVybn19LE5mPShlLHQpPT5gJHt0Pz9cIi4vXCJ9JHtlfWAsSXM9YXN5bmMgZT0+e2xldCBuPWF3YWl0KGF3YWl0IGZldGNoKGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pKS5ibG9iKCk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobil9LFZmPWFzeW5jIGU9Pihhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOnRydWUqL2UpKS5kZWZhdWx0LHhzPShfcygpLGJyKGJzKSkuZGVmYXVsdCxBcz1hc3luYygpPT57aWYoIVZlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuXCIpO2lmKGpuKFZlKSlyZXR1cm5bdm9pZCAwLHhzKCldO2xldCBlPWF3YWl0IElzKFZlKTtyZXR1cm5bZSx4cyhlKV19LFNzPSgkcygpLGJyKHZzKSkuZGVmYXVsdCxrcz1hc3luYyhlLHQsbik9PntpZighZSYmIXQmJlNzJiZWZSYmam4oVmUpKXJldHVyblt2b2lkIDAsU3NdO3tsZXQgcj1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNcIixvPWU/P1VmKHIsdCksYT0hITEmJm4mJm8mJiFqbihvLHQpLHM9YT9hd2FpdCBJcyhvKTpvPz9OZihyLHQpO3JldHVyblthP3M6dm9pZCAwLGF3YWl0IFZmKHMpXX19fSk7dmFyIFpuLFFuLE9yLEVzLFdmLExmLFRyLEllLGJ0PUcoKCk9PntcInVzZSBzdHJpY3RcIjtTcigpO1FuPSExLE9yPSExLEVzPSExLFdmPSgpPT57aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiExO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxMZj0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxUcj1hc3luYyBlPT57aWYoUW4pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKE9yKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKEVzKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO09yPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQsbj1lLm51bVRocmVhZHM7aWYoIUxmKCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKTtsZXQgcj1XZigpO24+MSYmIXImJih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrbitcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksY29uc29sZS53YXJuKFwiV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLlwiKSxlLm51bVRocmVhZHM9bj0xKTtsZXQgbz1lLndhc21QYXRocyxhPXR5cGVvZiBvPT1cInN0cmluZ1wiP286dm9pZCAwLHM9bz8ubWpzLGQ9cz8uaHJlZj8/cyxsPW8/Lndhc20scD1sPy5ocmVmPz9sLGY9ZS53YXNtQmluYXJ5LFtoLHldPWF3YWl0IGtzKGQsYSxuPjEpLF89ITEsYj1bXTtpZih0PjAmJmIucHVzaChuZXcgUHJvbWlzZSh3PT57c2V0VGltZW91dCgoKT0+e189ITAsdygpfSx0KX0pKSxiLnB1c2gobmV3IFByb21pc2UoKHcsUyk9PntsZXQgJD17bnVtVGhyZWFkczpufTtpZihmKSQud2FzbUJpbmFyeT1mO2Vsc2UgaWYocHx8YSkkLmxvY2F0ZUZpbGU9dj0+cD8/YSt2O2Vsc2UgaWYoZCYmZC5pbmRleE9mKFwiYmxvYjpcIikhPT0wKSQubG9jYXRlRmlsZT12PT5uZXcgVVJMKHYsZCkuaHJlZjtlbHNlIGlmKGgpe2xldCB2PUNzKCk7diYmKCQubG9jYXRlRmlsZT1UPT52K1QpfXkoJCkudGhlbih2PT57T3I9ITEsUW49ITAsWm49dix3KCksaCYmVVJMLnJldm9rZU9iamVjdFVSTChoKX0sdj0+e09yPSExLEVzPSEwLFModil9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoYiksXyl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LEllPSgpPT57aWYoUW4mJlpuKXJldHVybiBabjt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgUGUsWHQsaGUsRHI9RygoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7UGU9KGUsdCk9PntsZXQgbj1JZSgpLHI9bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxvPW4uX21hbGxvYyhyKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxvLHIpLHQucHVzaChvKSxvfSxYdD0oZSx0LG4scik9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKG4uaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO24uYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLGFdKT0+e2xldCBzPXQ/dCtvOm87aWYodHlwZW9mIGE9PVwib2JqZWN0XCIpWHQoYSxzK1wiLlwiLG4scik7ZWxzZSBpZih0eXBlb2YgYT09XCJzdHJpbmdcInx8dHlwZW9mIGE9PVwibnVtYmVyXCIpcihzLGEudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2YgYT09XCJib29sZWFuXCIpcihzLGE/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIGF9YCl9KX0saGU9ZT0+e2xldCB0PUllKCksbj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgcj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqcik7dC5fT3J0R2V0TGFzdEVycm9yKG8sbytyKTtsZXQgYT1OdW1iZXIodC5nZXRWYWx1ZShvLHI9PT00P1wiaTMyXCI6XCJpNjRcIikpLHM9dC5nZXRWYWx1ZShvK3IsXCIqXCIpLGQ9cz90LlVURjhUb1N0cmluZyhzKTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHtlfSBFUlJPUl9DT0RFOiAke2F9LCBFUlJPUl9NRVNTQUdFOiAke2R9YCl9ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19fSk7dmFyIFBzLHpzPUcoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO0RyKCk7UHM9ZT0+e2xldCB0PUllKCksbj0wLHI9W10sbz1lfHx7fTt0cnl7aWYoZT8ubG9nU2V2ZXJpdHlMZXZlbD09PXZvaWQgMClvLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKHR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMClvLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKG8udGVybWluYXRlPSExKTtsZXQgYT0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihhPVBlKGUudGFnLHIpKSxuPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMoby5sb2dTZXZlcml0eUxldmVsLG8ubG9nVmVyYm9zaXR5TGV2ZWwsISFvLnRlcm1pbmF0ZSxhKSxuPT09MCYmaGUoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZYdChlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHMsZCk9PntsZXQgbD1QZShzLHIpLHA9UGUoZCxyKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShuLGwscCkhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtzfSAtICR7ZH0uYCl9KSxbbixyXX1jYXRjaChhKXt0aHJvdyBuIT09MCYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMobiksci5mb3JFYWNoKHM9PnQuX2ZyZWUocykpLGF9fX0pO3ZhciBHZixIZixGZixxZixPcyxEcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnQoKTtEcigpO0dmPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7ZX1gKX19LEhmPWU9Pntzd2l0Y2goZSl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V9YCl9fSxGZj1lPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7bGV0IHQ9ZS5leHRyYS5zZXNzaW9uO3QudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseXx8KHQudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseT1cIjFcIiksZS5leGVjdXRpb25Qcm92aWRlcnMmJmUuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUobj0+KHR5cGVvZiBuPT1cInN0cmluZ1wiP246bi5uYW1lKT09PVwid2ViZ3B1XCIpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0scWY9KGUsdCxuKT0+e2ZvcihsZXQgciBvZiB0KXtsZXQgbz10eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZTtzd2l0Y2gobyl7Y2FzZVwid2Vibm5cIjppZihvPVwiV0VCTk5cIix0eXBlb2YgciE9XCJzdHJpbmdcIil7bGV0IGQ9cj8uZGV2aWNlVHlwZTtpZihkKXtsZXQgbD1QZShcImRldmljZVR5cGVcIixuKSxwPVBlKGQsbik7SWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbCxwKSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtkfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYobz1cIkpTXCIsdHlwZW9mIHIhPVwic3RyaW5nXCIpe2xldCBzPXI7aWYocz8ucHJlZmVycmVkTGF5b3V0KXtpZihzLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZzLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7cy5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGQ9UGUoXCJwcmVmZXJyZWRMYXlvdXRcIixuKSxsPVBlKHMucHJlZmVycmVkTGF5b3V0LG4pO0llKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGQsbCkhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHtzLnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b31gKX1sZXQgYT1QZShvLG4pO0llKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUsYSkhPT0wJiZoZShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfS5gKX19LE9zPWU9PntsZXQgdD1JZSgpLG49MCxyPVtdLG89ZXx8e307RmYobyk7dHJ5e2xldCBhPUdmKG8uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIikscz1IZihvLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxkPXR5cGVvZiBvLmxvZ0lkPT1cInN0cmluZ1wiP1BlKG8ubG9nSWQscik6MCxsPW8ubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihsKXx8bDwwfHxsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsfWApO2xldCBwPW8ubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIocCl8fHA8MHx8cD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7cH1gKTtsZXQgZj10eXBlb2Ygby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP1BlKG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxyKTowO2lmKG49dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoYSwhIW8uZW5hYmxlQ3B1TWVtQXJlbmEsISFvLmVuYWJsZU1lbVBhdHRlcm4scywhIW8uZW5hYmxlUHJvZmlsaW5nLDAsZCxsLHAsZiksbj09PTAmJmhlKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksby5leGVjdXRpb25Qcm92aWRlcnMmJnFmKG4sby5leGVjdXRpb25Qcm92aWRlcnMsciksby5lbmFibGVHcmFwaENhcHR1cmUhPT12b2lkIDApe2lmKHR5cGVvZiBvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7by5lbmFibGVHcmFwaENhcHR1cmV9YCk7bGV0IGg9UGUoXCJlbmFibGVHcmFwaENhcHR1cmVcIixyKSx5PVBlKG8uZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCkscik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG4saCx5KSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2VuYWJsZUdyYXBoQ2FwdHVyZScgLSAke28uZW5hYmxlR3JhcGhDYXB0dXJlfS5gKX1pZihvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpZm9yKGxldFtoLHldb2YgT2JqZWN0LmVudHJpZXMoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSl7aWYodHlwZW9mIGghPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7aH1gKTtpZih0eXBlb2YgeSE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoeSl8fHk8MCl0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHt5fWApO2xldCBfPVBlKGgscik7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKG4sXyx5KSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtofSAtICR7eX0uYCl9cmV0dXJuIG8uZXh0cmEhPT12b2lkIDAmJlh0KG8uZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoaCx5KT0+e2xldCBfPVBlKGgsciksYj1QZSh5LHIpO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLF8sYikhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7aH0gLSAke3l9LmApfSksW24scl19Y2F0Y2goYSl7dGhyb3cgbiE9PTAmJnQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHIuZm9yRWFjaChzPT50Ll9mcmVlKHMpKSxhfX19KTt2YXIgUnQsX3Qsd3QsQnIsSnQsTXIsUnIsWW4sdGU9RygoKT0+e1widXNlIHN0cmljdFwiO1J0PWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztjYXNlXCJpbnQ0XCI6cmV0dXJuIDIyO2Nhc2VcInVpbnQ0XCI6cmV0dXJuIDIxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LF90PWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtjYXNlIDIyOnJldHVyblwiaW50NFwiO2Nhc2UgMjE6cmV0dXJuXCJ1aW50NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHd0PShlLHQpPT57bGV0IG49Wy0xLDQsMSwxLDIsMiw0LDgsLTEsMSwyLDgsNCw4LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC41LC41XVtlXSxyPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC5yZWR1Y2UoKG8sYSk9Pm8qYSwxKTtyZXR1cm4gbj4wP01hdGguY2VpbChyKm4pOnZvaWQgMH0sQnI9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tP0Zsb2F0MTZBcnJheTpVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sSnQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19LE1yPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsUnI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50NjRcInx8ZT09PVwiaW50OFwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixZbj1lPT57c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm4gMDtjYXNlXCJjcHVcIjpyZXR1cm4gMTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIDI7Y2FzZVwidGV4dHVyZVwiOnJldHVybiAzO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gNDtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gNTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtlfWApfX19KTt2YXIgZXIsWG49RygoKT0+e1widXNlIHN0cmljdFwiO3hyKCk7ZXI9YXN5bmMgZT0+e2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKWlmKCExKXRyeXtsZXR7cmVhZEZpbGU6dH09Tm4oXCJub2RlOmZzL3Byb21pc2VzXCIpO3JldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0KGUpKX1jYXRjaCh0KXtpZih0LmNvZGU9PT1cIkVSUl9GU19GSUxFX1RPT19MQVJHRVwiKXtsZXR7Y3JlYXRlUmVhZFN0cmVhbTpufT1ObihcIm5vZGU6ZnNcIikscj1uKGUpLG89W107Zm9yIGF3YWl0KGxldCBhIG9mIHIpby5wdXNoKGEpO3JldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KG8pKX10aHJvdyB0fWVsc2V7bGV0IHQ9YXdhaXQgZmV0Y2goZSk7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX1gKTtsZXQgbj10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikscj1uP3BhcnNlSW50KG4sMTApOjA7aWYocjwxMDczNzQxODI0KXJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0LmFycmF5QnVmZmVyKCkpO3tpZighdC5ib2R5KXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9LCBubyByZXNwb25zZSBib2R5LmApO2xldCBvPXQuYm9keS5nZXRSZWFkZXIoKSxhO3RyeXthPW5ldyBBcnJheUJ1ZmZlcihyKX1jYXRjaChkKXtpZihkIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil7bGV0IGw9TWF0aC5jZWlsKHIvNjU1MzYpO2E9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpsLG1heGltdW06bH0pLmJ1ZmZlcn1lbHNlIHRocm93IGR9bGV0IHM9MDtmb3IoOzspe2xldHtkb25lOmQsdmFsdWU6bH09YXdhaXQgby5yZWFkKCk7aWYoZClicmVhaztsZXQgcD1sLmJ5dGVMZW5ndGg7bmV3IFVpbnQ4QXJyYXkoYSxzLHApLnNldChsKSxzKz1wfXJldHVybiBuZXcgVWludDhBcnJheShhLDAscil9fWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBCbG9iP25ldyBVaW50OEFycmF5KGF3YWl0IGUuYXJyYXlCdWZmZXIoKSk6ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/ZTpuZXcgVWludDhBcnJheShlKX19KTt2YXIgS2YsamYsQnMsTXMsVXIsWmYsbWUsdHQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7S2Y9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXSxqZj0oZSx0KT0+e2NvbnNvbGUubG9nKGBbJHtLZltlXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7dH1gKX0sVXI9KGUsdCk9PntCcz1lLE1zPXR9LFpmPShlLHQpPT57bGV0IG49SnQoZSkscj1KdChCcyk7bj49ciYmamYobix0eXBlb2YgdD09XCJmdW5jdGlvblwiP3QoKTp0KX0sbWU9KC4uLmUpPT57TXMmJlpmKC4uLmUpfX0pO3ZhciBOcixKbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtOcj0oZSx0KT0+bmV3KEJyKHQpKShlKX0pO3ZhciBWcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgUnMsZW8sdG8sUWYsWWYsVXMsbm8scm8sVnMsV3M9RygoKT0+e1widXNlIHN0cmljdFwiO3R0KCk7VnIoKTtScz1uZXcgTWFwKFtbNjQsMjUwXSxbMTI4LDIwMF0sWzI1NiwyMDBdLFs1MTIsMjAwXSxbMjA0OCwyMzBdLFs0MDk2LDIwMF0sWzgxOTIsNTBdLFsxNjM4NCw1MF0sWzMyNzY4LDUwXSxbNjU1MzYsNTBdLFsxMzEwNzIsNTBdLFsyNjIxNDQsNTBdLFs1MjQyODgsNTBdLFsxMDQ4NTc2LDUwXSxbMjA5NzE1MiwzMF0sWzQxOTQzMDQsMjBdLFs4Mzg4NjA4LDEwXSxbMTI1ODI5MTIsMTBdLFsxNjc3NzIxNiwxMF0sWzI2MjE0NDAwLDE1XSxbMzM1NTQ0MzIsMjJdLFs0NDIzNjgwMCwyXSxbNTg5ODI0MDAsNl0sWzY3MTA4ODY0LDZdLFsxMzQyMTc3MjgsNl0sWzE2Nzc3MjE2MCw2XV0pLGVvPVtdLHRvPWU9Pk1hdGguY2VpbChOdW1iZXIoZSkvMTYpKjE2LFFmPWU9Pntmb3IobGV0IHQ9MDt0PGVvLmxlbmd0aDt0Kyspe2xldCBuPWVvW3RdO2lmKGU8PW4pcmV0dXJuIG59cmV0dXJuIE1hdGguY2VpbChlLzE2KSoxNn0sWWY9MSxVcz0oKT0+WWYrKyxubz1hc3luYyhlLHQsbixyKT0+e2xldCBvPXRvKG4pLGE9ZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm8sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTt0cnl7bGV0IHM9ZS5nZXRDb21tYW5kRW5jb2RlcigpO2UuZW5kQ29tcHV0ZVBhc3MoKSxzLmNvcHlCdWZmZXJUb0J1ZmZlcih0LDAsYSwwLG8pLGUuZmx1c2goKSxhd2FpdCBhLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7bGV0IGQ9YS5nZXRNYXBwZWRSYW5nZSgpO2lmKHIpe2xldCBsPXIoKTtyZXR1cm4gbC5zZXQobmV3IFVpbnQ4QXJyYXkoZCwwLG4pKSxsfWVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KGQuc2xpY2UoMCxuKSl9ZmluYWxseXthLmRlc3Ryb3koKX19LHJvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5idWZmZXJzUGVuZGluZz1bXSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM9bmV3IE1hcDtmb3IobGV0W25db2YgUnMpZW8ucHVzaChuKSx0aGlzLmZyZWVCdWZmZXJzLnNldChuLFtdKSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5zZXQobixbXSk7dGhpcy5zZXNzaW9uQ291bnQ9MH11cGxvYWQodCxuKXtsZXQgcj1uLmJ1ZmZlcixvPW4uYnl0ZU9mZnNldCxhPW4uYnl0ZUxlbmd0aCxzPXRvKGEpLGQ9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImdwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3RcIik7aWYoTnVtYmVyKGQub3JpZ2luYWxTaXplKSE9PWEpdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7ZC5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHthfWApO2xldCBsPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6cyx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxwPWwuZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShwKS5zZXQobmV3IFVpbnQ4QXJyYXkocixvLGEpKSxsLnVubWFwKCk7bGV0IGY9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO2YuY29weUJ1ZmZlclRvQnVmZmVyKGwsMCxkLmdwdURhdGEuYnVmZmVyLDAscyksdGhpcy5iYWNrZW5kLmRldmljZS5xdWV1ZS5zdWJtaXQoW2YuZmluaXNoKCldKSxsLmRlc3Ryb3koKSxtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApfW1lbWNweSh0LG4pe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQobik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihyLm9yaWdpbmFsU2l6ZSE9PW8ub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IGE9dG8oci5vcmlnaW5hbFNpemUpLHM9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCkscy5jb3B5QnVmZmVyVG9CdWZmZXIoci5ncHVEYXRhLmJ1ZmZlciwwLG8uZ3B1RGF0YS5idWZmZXIsMCxhKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQsbixyKXtsZXQgbztpZihyKXtpZihvPXJbMF0sdD09PXJbMV0pcmV0dXJuIG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7bn0pID0+IGlkPSR7b30sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxvO2lmKHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCkpdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKX1lbHNlIG89VXMoKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KG8se2dwdURhdGE6e2lkOm8sdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6bn0pLG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7bn0pID0+IGlkPSR7b30sIHJlZ2lzdGVyZWQuYCksb311bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCl7dCE9PXZvaWQgMCYmKHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZSh0KSxtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7dH1gKSl9Y3JlYXRlKHQsbj1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtsZXQgcj1RZih0KSxvLGE9KG4mR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFLHM9KG4mR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNO2lmKGF8fHMpe2xldCBwPShhP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMpLmdldChyKTtwP3AubGVuZ3RoPjA/bz1wLnBvcCgpOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLHVzYWdlOm59KX1lbHNlIG89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSk7bGV0IGQ9e2lkOlVzKCksdHlwZTowLGJ1ZmZlcjpvfTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGQuaWQse2dwdURhdGE6ZCxvcmlnaW5hbFNpemU6TnVtYmVyKHQpfSksbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2QuaWR9YCksZH1nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCBuPXR5cGVvZiB0PT1cImJpZ2ludFwiP051bWJlcih0KTp0LHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KG4pO2lmKCFyKXtpZih0aGlzLnN0b3JhZ2VDYWNoZS5zaXplPT09MClyZXR1cm4gMDt0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKX1yZXR1cm4gbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7bn0pLCBncHVEYXRhSWQ9JHtyLmdwdURhdGEuaWR9YCksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKG4pLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChyLmdwdURhdGEuYnVmZmVyKSxyLm9yaWdpbmFsU2l6ZX1hc3luYyBkb3dubG9hZCh0LG4pe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldChOdW1iZXIodCkpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImRhdGEgZG9lcyBub3QgZXhpc3RcIik7YXdhaXQgbm8odGhpcy5iYWNrZW5kLHIuZ3B1RGF0YS5idWZmZXIsci5vcmlnaW5hbFNpemUsbil9cmVmcmVzaFBlbmRpbmdCdWZmZXJzKCl7aWYodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGghPT0wKWlmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJkZWZhdWx0XCIpe2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXtsZXQgbj1Scy5nZXQodC5zaXplKTtpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0Upe2xldCByPXRoaXMuZnJlZUJ1ZmZlcnMuZ2V0KHQuc2l6ZSl8fFtdO249PT12b2lkIDB8fHIubGVuZ3RoPj1uP3QuZGVzdHJveSgpOnIucHVzaCh0KX1lbHNlIGlmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSl7bGV0IHI9dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KHQuc2l6ZSl8fFtdO249PT12b2lkIDB8fHIubGVuZ3RoPj1uP3QuZGVzdHJveSgpOnIucHVzaCh0KX1lbHNlIHQuZGVzdHJveSgpfXRoaXMuYnVmZmVyc1BlbmRpbmc9W119ZWxzZXtsZXQgdD10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKTt0fHwodD1bXSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLHQpKTtmb3IobGV0IG4gb2YgdGhpcy5idWZmZXJzUGVuZGluZyl0LnB1c2gobik7dGhpcy5idWZmZXJzUGVuZGluZz1bXX19ZGlzcG9zZSgpe3RoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pfSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCh0PT57dC5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCh0PT57dC5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM9bmV3IE1hcH1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLnNlc3Npb25Db3VudCs9MX1vblJlbGVhc2VTZXNzaW9uKHQpe2xldCBuPXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodCk7biYmKG4uZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZGVsZXRlKHQpKSx0aGlzLnNlc3Npb25Db3VudC09MSx0aGlzLnNlc3Npb25Db3VudD09PTAmJihtZShcIndhcm5pbmdcIiwoKT0+XCJbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlXCIpLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2gocj0+e3IuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCl9fSxWcz0oLi4uZSk9Pm5ldyBybyguLi5lKX0pO3ZhciBvbyxyZSxDZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7b289Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLmtleXx8KHRoaXMua2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5rZXl9fSxyZT1lPT5uZXcgb28oZSl9KTt2YXIgaW8scnQsRSxrdCxXcixMcyxHcyxhZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aW89Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LG4pe3JldHVybiB0WzFdIT09blswXT92b2lkIDA6W3RbMF0sblsxXV19fSxydD1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQsbixyPSExKXtsZXQgbz10Lmxlbmd0aCxhPW4ubGVuZ3RoO2lmKG89PT0wKXJldHVybiBuO2lmKGE9PT0wKXJldHVybiB0O2xldCBzPU1hdGgubWF4KHQubGVuZ3RoLG4ubGVuZ3RoKSxkPW5ldyBBcnJheShzKTtpZihyKXtpZihvPDJ8fGE8MilyZXR1cm47bGV0IGw9aW8uY2FsY01hdE11bFNoYXBlKFt0W28tMl0sdFtvLTFdXSxbblthLTJdLG5bYS0xXV0pO2lmKGw9PT12b2lkIDApcmV0dXJuO1tkW3MtMl0sZFtzLTFdXT1sfWZvcihsZXQgbD1yPzM6MTtsPD1zO2wrKyl7bGV0IHA9by1sPDA/MTp0W28tbF0sZj1hLWw8MD8xOm5bYS1sXTtpZihwIT09ZiYmcD4xJiZmPjEpcmV0dXJuO2xldCBoPU1hdGgubWF4KHAsZik7aWYocCYmZilkW3MtbF09TWF0aC5tYXgocCxmKTtlbHNle2lmKGg+MSlyZXR1cm47ZFtzLWxdPTB9fXJldHVybiBkfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQsbil7bGV0IHI9dC5sZW5ndGgsbz1uLmxlbmd0aDtpZihyPm8pcmV0dXJuITE7Zm9yKGxldCBhPTE7YTw9cjthKyspaWYodFtyLWFdIT09MSYmdFtyLWFdIT09bltvLWFdKXJldHVybiExO3JldHVybiEwfX0sRT1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgY29udmVydFNoYXBlKHQsbj00KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtsZXQgbz1uZXcgQXJyYXkociksYT1yLTE7Zm9yKDthPj0wOyl7aWYodFthXSVuPT09MCl7b1thXT10W2FdL247YnJlYWt9aWYobiV0W2FdIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29udmVydCBzaGFwZVwiKTtvW2FdPTEsbi89dFthXSxhLS19Zm9yKGEtLTthPj0wO2EtLSlvW2FdPXRbYV07cmV0dXJuIG99c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKHQsbil7aWYobjwwfHxuPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtufSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxuLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKHQsbil7aWYobjwwfHxuPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtufSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCxuKX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LG4scil7bGV0IG89MTtmb3IobGV0IGE9bjthPHI7YSsrKXtpZih0W2FdPDApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtvKj1OdW1iZXIodFthXSl9cmV0dXJuIG99c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybltdO2lmKG49PT0xKXJldHVyblsxXTtsZXQgcj1uZXcgQXJyYXkobik7cltuLTFdPTEscltuLTJdPXRbbi0xXTtmb3IobGV0IG89bi0zO28+PTA7LS1vKXJbb109cltvKzFdKnRbbysxXTtyZXR1cm4gcn1zdGF0aWMgbm9ybWFsaXplQXhpcyh0LG4pe2lmKHQ8LW4mJnQ+PW4pdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtuOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxuKXtyZXR1cm4gdC5tYXAocj0+dGhpcy5ub3JtYWxpemVBeGlzKHIsbj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQsbil7cmV0dXJuIG4/bi5tYXAocj0+dFtyXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxuKXtsZXQgcj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKG8sYSk9Pm8rblthXStuW2Ercl0pfXN0YXRpYyBhcmVFcXVhbCh0LG4pe3JldHVybiB0Lmxlbmd0aCE9PW4ubGVuZ3RoPyExOnQuZXZlcnkoKHIsbyk9PnI9PT1uW29dKX19LGt0PWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsbixyLG8sYSxzKXtpZighdCYmci5sZW5ndGghPT1uLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoLTI7ZCsrKWQ+PXIubGVuZ3RoP3IucHVzaChuW2QrMl0pOnJbZF09bltkKzJdO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGg7ZCsrKWlmKGQ8by5sZW5ndGgpe2lmKG9bZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG8ucHVzaCgxKTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrKylpZihkPGEubGVuZ3RoKXtpZihhW2RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGEucHVzaCgxKTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoKjI7ZCsrKWlmKGQ8cy5sZW5ndGgpe2lmKHNbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugcy5wdXNoKDApO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGg7ZCsrKXtpZihyW2RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihzW2RdPj1yW2RdfHxzW2Qrci5sZW5ndGhdPj1yW2RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxuLHIsbyxhLHMsZCl7aWYoZCl7aWYoYS5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYobi5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihvLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgbD0wO2w8dC5sZW5ndGgtMjtsKyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W2wrKHM/MToyKV0sbltsXSxyW2xdLG9bbF0sYSxsLGwrdC5sZW5ndGgtMixkKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxuLHIsbyxhLHMsZCl7aWYobi5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCBsPVtuWzBdLG5bMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LG4sbCxyLG8sYSxzLGQpLGx9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxuLHIsbyxhLHMsZCl7aWYodC5sZW5ndGg8PTB8fG4ubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IGw9W3RbMF0sblswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsbCxyLG8sYSxzLGQpLGx9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LG4scixvLGEscyxkLGwpe2lmKHQpZm9yKGxldCBwPTA7cDxuLmxlbmd0aC0yO3ArKylyLnB1c2goMSk7ZWxzZSBmb3IobGV0IHA9MDtwPG4ubGVuZ3RoLTI7cCsrKXIucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKG5bcCsyXSxvW3BdLGFbcF0sc1twXSxkLHAscCtuLmxlbmd0aC0yLGwpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxuLHIsbyxhLHMsZCxsKXtsZXQgcD1yKihvLTEpKzE7aWYobCYmbCE9PVwiTk9UU0VUXCIpc3dpdGNoKGwpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIGFbc109MCxhW2RdPTAsTWF0aC5mbG9vcigodC1wKS9uKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYociE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgaD0oKHQrbi0xKS9uLTEpKm4rby10O3JldHVybiBhW3NdPU1hdGguZmxvb3IobD09PVwiU0FNRV9MT1dFUlwiPyhoKzEpLzI6aC8yKSxhW2RdPWgtYVtzXSxNYXRoLmZsb29yKCh0K2gtbykvbisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K2Fbc10rYVtkXS1wKS9uKzEpfX0sV3I9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsbixyLG8sYSl7aWYodC5sZW5ndGghPT0yfHxyLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IHMsZCxsO24/KHM9dFsxXSxkPXRbMF0pOihzPXRbMF0sZD10WzFdKTtsZXQgcD0tMTtpZihvPyhsPXJbMF0scD0xKToobD1yWzFdLHA9MCkscltwXSE9PWQpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKHM8PTB8fGw8PTB8fGQ8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoYSYmIXJ0LmlzVmFsaWRCcm9hZGNhc3QoYSxbcyxsXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW3MsbCxkXX19LExzPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixHcz0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciBFdCxzbyxfZSx6ZSxILGdlLHVvLFB0LEtlLEssTHIsUCxOLEhzLEdyLGFvLEZzLGNlPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7RXQ9NjQsc289KGUsdCk9PntpZih0PT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkXCIpO3N3aXRjaChOdW1iZXIoZSkpe2Nhc2UgMTA6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMTY+YDpcImYxNlwiO2Nhc2UgMTpyZXR1cm4gdD4xP2B2ZWMke3R9PGYzMj5gOlwiZjMyXCI7Y2FzZSA2OnJldHVybiB0PjE/YHZlYyR7dH08aTMyPmA6XCJpMzJcIjtjYXNlIDEyOnJldHVybiB0PjE/YHZlYyR7dH08dTMyPmA6XCJ1MzJcIjtjYXNlIDc6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcImkzMlwiXTtjYXNlIDEzOmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJ1MzJcIl07Y2FzZSA5OmlmKHQhPT00KXRocm93IG5ldyBFcnJvcihcImJvb2wgbXVzdCBiZSB2ZWM0XCIpO3JldHVybltcInUzMlwiLFwidmVjNDxib29sPlwiXTtjYXNlIDIyOnJldHVyblwiaTMyXCI7Y2FzZSAyMTpyZXR1cm5cInUzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHtlfWApfX0sX2U9KGUsdD0xKT0+e2xldCBuPXNvKGUsdCk7cmV0dXJuIHR5cGVvZiBuPT1cInN0cmluZ1wiP246blswXX0semU9KGUsdD0xKT0+e2xldCBuPXNvKGUsdCk7cmV0dXJuIHR5cGVvZiBuPT1cInN0cmluZ1wiP246blsxXX0sSD0oLi4uZSk9PntsZXQgdD1bXTtyZXR1cm4gZS5mb3JFYWNoKG49PntuLmxlbmd0aCE9PTAmJnQucHVzaCh7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6RS5jb21wdXRlU3RyaWRlcyhuKX0pfSksdH0sZ2U9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLHVvPShlPVwiZjMyXCIsdCxuPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7bn0pYDpgdmVjJHt0fTwke2V9Pigke259KWAsUHQ9KGUsdCxuKT0+ZT09PVwiZjMyXCI/bjp0PT09MT9gZjMyKCR7bn0pYDpgdmVjJHt0fTxmMzI+KCR7bn0pYCxLZT0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxLPShlLHQsbixyKT0+ZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZuPjQ/dHlwZW9mIHQ9PVwic3RyaW5nXCI/cj09PVwiZjE2XCI/YCR7ZX1bKCR7dH0pIC8gOF1bKCR7dH0pICUgOCAvIDRdWygke3R9KSAlIDggJSA0XWA6YCR7ZX1bKCR7dH0pIC8gNF1bKCR7dH0pICUgNF1gOnI9PT1cImYxNlwiP2Ake2V9WyR7TWF0aC5mbG9vcih0LzgpfV1bJHtNYXRoLmZsb29yKHQlOC80KX1dWyR7dCU4JTR9XWA6YCR7ZX1bJHtNYXRoLmZsb29yKHQvNCl9XVske3QlNH1dYDpuPjE/YCR7ZX1bJHt0fV1gOmUsTHI9KGUsdCxuLHIsbyk9PntsZXQgYT10eXBlb2Ygbj09XCJudW1iZXJcIixzPWE/bjpuLmxlbmd0aCxkPVsuLi5uZXcgQXJyYXkocykua2V5cygpXSxsPXM8Mj9cInUzMlwiOnM8PTQ/YHZlYyR7c308dTMyPmA6YGFycmF5PHUzMiwgJHtzfT5gLHA9c28odCxvKSxmPXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFsxXSxoPXR5cGVvZiBwPT1cInN0cmluZ1wiP3A6cFswXSx5PXtpbmRpY2VzOmwsdmFsdWU6ZixzdG9yYWdlOmgsdGVuc29yOnR9LF89Uj0+dHlwZW9mIFI9PVwic3RyaW5nXCI/UjpgJHtSfXVgLGI9e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSx3PWE/XCJ1bmlmb3Jtcy5cIjpcIlwiLFM9YCR7d30ke2V9X3NoYXBlYCwkPWAke3d9JHtlfV9zdHJpZGVzYCx2PVwiXCI7Zm9yKGxldCBSPTA7UjxzLTE7UisrKXYrPWBcbiAgICBsZXQgZGltJHtSfSA9IGN1cnJlbnQgLyAke0soJCxSLHMpfTtcbiAgICBsZXQgcmVzdCR7Un0gPSBjdXJyZW50ICUgJHtLKCQsUixzKX07XG4gICAgaW5kaWNlc1ske1J9XSA9IGRpbSR7Un07XG4gICAgY3VycmVudCA9IHJlc3Qke1J9O1xuICAgIGA7dis9YGluZGljZXNbJHtzLTF9XSA9IGN1cnJlbnQ7YDtsZXQgVD1zPDI/XCJcIjpgXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke3kuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke3kuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHt2fVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YCxDPVI9PihiLm9mZnNldFRvSW5kaWNlcz0hMCxzPDI/UjpgbzJpXyR7ZX0oJHtSfSlgKSxBPVtdO2lmKHM+PTIpZm9yKGxldCBSPXMtMTtSPj0wO1ItLSlBLnB1c2goYCR7SygkLFIscyl9ICogKGluZGljZXNbJHtSfV0pYCk7bGV0IGs9czwyP1wiXCI6YFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke3kuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7QS5qb2luKFwiK1wiKX07XG4gIH1gLE89Uj0+KGIuaW5kaWNlc1RvT2Zmc2V0PSEwLHM8Mj9SOmBpMm9fJHtlfSgke1J9KWApLE09KC4uLlIpPT5zPT09MD9cIjB1XCI6YCR7eS5pbmRpY2VzfSgke1IubWFwKF8pLmpvaW4oXCIsXCIpfSlgLFY9KFIsWSk9PnM8Mj9gJHtSfWA6YCR7SyhSLFkscyl9YCxGPShSLFksZmUpPT5zPDI/YCR7Un09JHtmZX07YDpgJHtLKFIsWSxzKX09JHtmZX07YCxqPXt9LG5lPShSLFkpPT57Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgZmU9YCR7WS5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYoZmUgaW4gailyZXR1cm5gJHtmZX0oJHtSfSlgO2xldCBGZT1bXTtmb3IobGV0IHhlPXMtMTt4ZT49MDt4ZS0tKXtsZXQgYmU9WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHhlK1kucmFuay1zKTtGZS5wdXNoKGAke1YoJCx4ZSl9ICogKCR7YmV9ICUgJHtWKFMseGUpfSlgKX1yZXR1cm4galtmZV09YGZuICR7ZmV9KG91dHB1dEluZGljZXM6ICR7WS50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke0ZlLmxlbmd0aD4wP0ZlLmpvaW4oXCIrXCIpOlwiMHVcIn07XG4gICAgICAgICAgIH1gLGAke2ZlfSgke1J9KWB9LFc9KFIsWSk9PigoKT0+e2lmKHkuc3RvcmFnZT09PXkudmFsdWUpcmV0dXJuYCR7ZX1bJHtSfV09JHtZfTtgO2lmKHkuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnkudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7Un1dPXZlYzI8dTMyPih1MzIoJHtZfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7WX0gPCAwKSk7YDtpZih5LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ5LnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske1J9XT12ZWMyPHUzMj4odTMyKCR7WX0pLCAwdSk7YDtpZih5LnN0b3JhZ2U9PT1cInUzMlwiJiZ5LnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtSfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtZfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3kuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt5LnZhbHVlfSB5ZXRgKX0pKCksSj1SPT4oKCk9PntpZih5LnN0b3JhZ2U9PT15LnZhbHVlKXJldHVybmAke2V9WyR7Un1dYDtpZih5LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ5LnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtSfV0ueClgO2lmKHkuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnkudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske1J9XS54KWA7aWYoeS5zdG9yYWdlPT09XCJ1MzJcIiYmeS52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske1J9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7Un1dICYgMHhGRjAwdSksIGJvb2woJHtlfVske1J9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske1J9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt5LnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7eS52YWx1ZX0geWV0YCl9KSgpLHZlPXM8Mj9cIlwiOmBcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHt5LmluZGljZXN9KSAtPiAke2Z9IHtcbiAgICByZXR1cm4gJHtKKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcbiAgfWAsUT1zPDI/XCJcIjooKCk9PntsZXQgUj1kLm1hcChmZT0+YGQke2ZlfTogdTMyYCkuam9pbihcIiwgXCIpLFk9ZC5tYXAoZmU9PmBkJHtmZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBnZXRfJHtlfSgke1J9KSAtPiAke2Z9IHtcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtNKFkpfSk7XG4gIH1gfSkoKSxlZT0oLi4uUik9PntpZihSLmxlbmd0aCE9PXMpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7c31gKTtsZXQgWT1SLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gcz09PTA/SihcIjB1XCIpOnM9PT0xP0ooWVswXSk6KGIuZ2V0PSEwLGIuZ2V0QnlJbmRpY2VzPSEwLGIuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfSgke1l9KWApfSxsZT1SPT5zPDI/SihSKTooYi5nZXRCeUluZGljZXM9ITAsYi5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7Un0pYCksWj1zPDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7eS5pbmRpY2VzfSwgdmFsdWU6ICR7Zn0pIHtcbiAgICAke1coYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxuICB9YCxwZT1zPDI/XCJcIjooKCk9PntsZXQgUj1kLm1hcChmZT0+YGQke2ZlfTogdTMyYCkuam9pbihcIiwgXCIpLFk9ZC5tYXAoZmU9PmBkJHtmZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBzZXRfJHtlfSgke1J9LCB2YWx1ZTogJHtmfSkge1xuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7TShZKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IFI9W10sWT0hMTtyZXR1cm4gYi5vZmZzZXRUb0luZGljZXMmJihSLnB1c2goVCksWT0hMCksYi5pbmRpY2VzVG9PZmZzZXQmJihSLnB1c2goayksWT0hMCksYi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmKE9iamVjdC52YWx1ZXMoaikuZm9yRWFjaChmZT0+Ui5wdXNoKGZlKSksWT0hMCksYi5zZXQmJihSLnB1c2gocGUpLFk9ITApLGIuc2V0QnlJbmRpY2VzJiYoUi5wdXNoKFopLFk9ITApLGIuZ2V0JiYoUi5wdXNoKFEpLFk9ITApLGIuZ2V0QnlJbmRpY2VzJiYoUi5wdXNoKHZlKSxZPSEwKSwhYSYmWSYmUi51bnNoaWZ0KGBjb25zdCAke1N9ID0gJHt5LmluZGljZXN9KCR7bi5qb2luKFwiLFwiKX0pO2AsYGNvbnN0ICR7JH0gPSAke3kuaW5kaWNlc30oJHtFLmNvbXB1dGVTdHJpZGVzKG4pLmpvaW4oXCIsXCIpfSk7YCksUi5qb2luKGBcbmApfSx0eXBlOnksb2Zmc2V0VG9JbmRpY2VzOkMsaW5kaWNlc1RvT2Zmc2V0Ok8sYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6bmUsaW5kaWNlczpNLGluZGljZXNHZXQ6VixpbmRpY2VzU2V0OkYsc2V0OiguLi5SKT0+e2lmKFIubGVuZ3RoIT09cysxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3N9YCk7bGV0IFk9UltzXTtpZih0eXBlb2YgWSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgZmU9Ui5zbGljZSgwLHMpLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gcz09PTA/VyhcIjB1XCIsWSk6cz09PTE/VyhmZVswXSxZKTooYi5zZXQ9ITAsYi5zZXRCeUluZGljZXM9ITAsYi5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7ZmV9LCAke1l9KWApfSxzZXRCeU9mZnNldDpXLHNldEJ5SW5kaWNlczooUixZKT0+czwyP1coUixZKTooYi5zZXRCeUluZGljZXM9ITAsYi5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7Un0sICR7WX0pO2ApLGdldDplZSxnZXRCeU9mZnNldDpKLGdldEJ5SW5kaWNlczpsZSx1c2FnZTpyLG5hbWU6ZSxzdHJpZGVzOiQsc2hhcGU6UyxyYW5rOnN9fSxQPShlLHQsbixyPTEpPT5McihlLHQsbixcImlucHV0XCIsciksTj0oZSx0LG4scj0xKT0+THIoZSx0LG4sXCJvdXRwdXRcIixyKSxIcz0oZSx0LG4pPT5McihlLHQsbixcImF0b21pY091dHB1dFwiLDEpLEdyPShlLHQsbixyPTEpPT5McihlLHQsbixcImludGVybmFsXCIsciksYW89Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5saW1pdHM9bjt0aGlzLmludGVybmFsVmFyaWFibGVzPVtdO3RoaXMudmFyaWFibGVzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9RXQpe2xldCBuPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxyPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXTtpZihuPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWHx8cj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl8fG8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7bn0sICR7cn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO2lmKG4qcipvPnRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCl0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske259LCAke3J9LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCk7bGV0IGE9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLHM9YT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAsZD1hP2BsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2A6YGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHtuKnIqb311ICsgbG9jYWxfaWR4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke259LCAke3J9LCAke299KVxuICBmbiBtYWluKCR7c30pIHtcbiAgICAke2R9XG4gIGB9YXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KXt0LnJhbmshPT0wJiYodC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSl9ZGVjbGFyZVZhcmlhYmxlKHQsbil7aWYodC51c2FnZT09PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy52YXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCk7bGV0IHI9dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixvPXQudXNhZ2U9PT1cImF0b21pY091dHB1dFwiP1wiYXRvbWljPGkzMj5cIjp0LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7bn0pIHZhcjxzdG9yYWdlLCAke3J9PiAke3QubmFtZX06IGFycmF5PCR7b30+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAobj0+dGhpcy5kZWNsYXJlVmFyaWFibGUobix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHQpe2lmKHQudXNhZ2UhPT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQuZm9yRWFjaChuPT50aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZShuKSksdGhpc31yZWdpc3RlclVuaWZvcm0odCxuLHI9MSl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6bixsZW5ndGg6cn0pLHRoaXN9cmVnaXN0ZXJVbmlmb3Jtcyh0KXtyZXR1cm4gdGhpcy51bmlmb3Jtcz10aGlzLnVuaWZvcm1zLmNvbmNhdCh0KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpuLHR5cGU6cixsZW5ndGg6b31vZiB0aGlzLnVuaWZvcm1zKWlmKG8mJm8+NClyPT09XCJmMTZcIj90LnB1c2goYEBhbGlnbigxNikgJHtufTphcnJheTxtYXQyeDQ8JHtyfT4sICR7TWF0aC5jZWlsKG8vOCl9PmApOnQucHVzaChgJHtufTphcnJheTx2ZWM0PCR7cn0+LCAke01hdGguY2VpbChvLzQpfT5gKTtlbHNle2xldCBhPW89PW51bGx8fG89PT0xP3I6YHZlYyR7b308JHtyfT5gO3QucHVzaChgJHtufToke2F9YCl9cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMudmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKSt0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX1nZXQgdmFyaWFibGVzSW5mbygpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm47bGV0IHQ9bj0+WzEyLDEwLDEsNl1bW1widTMyXCIsXCJmMTZcIixcImYzMlwiLFwiaTMyXCJdLmluZGV4T2YobildO3JldHVybiB0aGlzLnVuaWZvcm1zLm1hcChuPT5bdChuLnR5cGUpLG4ubGVuZ3RoPz8xXSl9fSxGcz0oZSx0KT0+bmV3IGFvKGUsdCl9KTt2YXIgWGYscXMsSmYsZWgsdGgscmgsT2UsS3MsanMsY3Q9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7WGY9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZih0Lmxlbmd0aCE9PTAmJnQubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYHBlcm0gc2l6ZSAke3QubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCBpbnB1dCByYW5rICR7ZVswXS5kaW1zLmxlbmd0aH1gKX0scXM9KGUsdCk9PnQubGVuZ3RoIT09MD90OlsuLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCksSmY9KGUsdCk9PkUuc29ydEJhc2VkT25QZXJtKGUscXMoZS5sZW5ndGgsdCkpLGVoPShlLHQsbixyKT0+e2xldCBvPWBmbiBwZXJtKGk6ICR7ci50eXBlLmluZGljZXN9KSAtPiAke24udHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7bi50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBhPTA7YTx0OysrYSlvKz1gYVske2VbYV19XT1pWyR7YX1dO2A7cmV0dXJuIG8rPVwicmV0dXJuIGE7fVwifSx0aD0oZSx0KT0+e2xldCBuPVtdLHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pZVtvXSE9PTEmJm4ucHVzaChlW29dKSxlW3Rbb11dIT09MSYmci5wdXNoKHRbb10pO3JldHVybntuZXdTaGFwZTpuLG5ld1Blcm06cn19LHJoPShlLHQpPT57bGV0IG49MDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZih0W2Vbcl1dIT09MSl7aWYoZVtyXTxuKXJldHVybiExO249ZVtyXX1yZXR1cm4hMH0sT2U9KGUsdCk9PntsZXQgbj1lLmRhdGFUeXBlLHI9ZS5kaW1zLmxlbmd0aCxvPXFzKHIsdCksYT1KZihlLmRpbXMsbykscz1lLmRpbXMsZD1hLGw9cjwyfHxyaChvLGUuZGltcykscDtpZihsKXJldHVybiBwPXc9PntsZXQgUz1QKFwiaW5wdXRcIixuLHMsNCksJD1OKFwib3V0cHV0XCIsbixkLDQpO3JldHVybmBcbiAgJHt3LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhTLCQpfVxuICAke3cubWFpblN0YXJ0KCl9XG4gICAgJHt3Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlQ29weVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IHc9RS5zaXplKGEpO3JldHVybntvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh3LzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHcvNCl9XX19LGdldFNoYWRlclNvdXJjZTpwfTtsZXR7bmV3U2hhcGU6ZixuZXdQZXJtOmh9PXRoKGUuZGltcyxvKSx5PUUuYXJlRXF1YWwoaCxbMiwzLDFdKSxfPUUuYXJlRXF1YWwoaCxbMywxLDJdKTtpZihmLmxlbmd0aD09PTJ8fHl8fF8pe3M9eT9bZlswXSxmWzFdKmZbMl1dOl8/W2ZbMF0qZlsxXSxmWzJdXTpmLGQ9W3NbMV0sc1swXV07bGV0IHc9MTY7cmV0dXJuIHA9Uz0+e2xldCAkPVAoXCJhXCIsbixzLmxlbmd0aCksdj1OKFwib3V0cHV0XCIsbixkLmxlbmd0aCk7cmV0dXJuYFxuICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke3YudHlwZS52YWx1ZX0sICR7dysxfT4sICR7d30+O1xuICAke1MubWFpblN0YXJ0KFt3LHcsMV0pfVxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke3d9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7d311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgaW5wdXRfcm93ID0gd29ya2dyb3VwX2lkX3ggKiAke3d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKGlucHV0X3JvdyA8IHVuaWZvcm1zLmFfc2hhcGVbMF0gJiYgaW5wdXRfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsxXSkge1xuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7JC5nZXRCeUluZGljZXMoYCR7JC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IG91dHB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeCAqICR7d311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgb3V0cHV0X3JvdyA9IHdvcmtncm91cF9pZF95ICogJHt3fXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7di5zZXRCeUluZGljZXMoYCR7di50eXBlLmluZGljZXN9KG91dHB1dF9yb3csIG91dHB1dF9jb2wpYCxcInRpbGVbbG9jYWxfaWQueF1bbG9jYWxfaWQueV1cIil9XG4gICAgfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VTaGFyZWRcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBTPUUuc2l6ZShhKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZFsxXS93KSx5Ok1hdGguY2VpbChkWzBdL3cpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6U30sLi4uSChzLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX1yZXR1cm4gcD13PT57bGV0IFM9UChcImFcIixuLHMubGVuZ3RoKSwkPU4oXCJvdXRwdXRcIixuLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7dy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoUywkKX1cblxuICAke2VoKG8scixTLCQpfVxuXG4gICR7dy5tYWluU3RhcnQoKX1cbiAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixTLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgdz1FLnNpemUoYSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6d30sLi4uSChzLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX0sS3M9KGUsdCk9PntYZihlLmlucHV0cyx0LnBlcm0pLGUuY29tcHV0ZShPZShlLmlucHV0c1swXSx0LnBlcm0pKX0sanM9ZT0+cmUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgbmgsb2gsaWgsYWgsc2gsdWgsZGgsbGgsY2gscGgsbnQsWnMsUXMsWXMsWHMsSnMsZXUsdHUscnUsbnUsb3UsaXU9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO0hyKCk7Y3QoKTtuaD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxvaD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGloPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LGFoPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0sc2g9KGUsdCk9PntsZXQgbj1bXTtmb3IobGV0IHI9dC1lO3I8dDsrK3Ipbi5wdXNoKHIpO3JldHVybiBufSx1aD0oZSx0KT0+e2xldCBuPVtdLHI9ZS5sZW5ndGg7Zm9yKGxldCBhPTA7YTxyO2ErKyl0LmluZGV4T2YoYSk9PT0tMSYmbi5wdXNoKGVbYV0pO2xldCBvPXQubWFwKGE9PmVbYV0pO3JldHVybltuLG9dfSxkaD0oZSx0KT0+e2xldCBuPWUubGVuZ3RoK3QubGVuZ3RoLHI9W10sbz0wO2ZvcihsZXQgYT0wO2E8bjthKyspdC5pbmRleE9mKGEpPT09LTE/ci5wdXNoKGVbbysrXSk6ci5wdXNoKDEpO3JldHVybiByfSxsaD0oZSx0KT0+e2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWlmKGVbZS5sZW5ndGgtbi0xXSE9PXQtMS1uKXJldHVybiExO3JldHVybiEwfSxjaD0oZSx0KT0+e2xldCBuPVtdO2lmKCFsaChlLHQpKXtmb3IobGV0IHI9MDtyPHQ7KytyKWUuaW5kZXhPZihyKT09PS0xJiZuLnB1c2gocik7ZS5mb3JFYWNoKHI9Pm4ucHVzaChyKSl9cmV0dXJuIG59LHBoPShlLHQsbixyLG8sYSxzKT0+e2xldCBkPW5bMF0uZGltcyxsPUUuc2l6ZShhKSxwPUUuc2l6ZShzKSxmPVAoXCJfQVwiLG5bMF0uZGF0YVR5cGUsZCksaD1OKFwib3V0cHV0XCIsbyxhKSx5PTY0O2w9PT0xJiYoeT0yNTYpO2xldCBfPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHt5fT47XG4gICAgICAgYCxiPXc9PmBcbiAgICAgICAgJHt3LnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGYsaCl9XG4gICAgICAgICR7X31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7dy5tYWluU3RhcnQoeSl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHt5fTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2loW3JdfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke3l9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHtmLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke25oW3JdfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHt5fXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7b2hbcl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7aC5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7cj09PVwibWVhblwiP2Ake2gudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHtoLnR5cGUuc3RvcmFnZX0oJHthaFtyXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Omx9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfV19KX19LG50PShlLHQsbixyKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/bjpsbyhlLmlucHV0cyxuKSxhPW8uYXhlczthLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoYT1lLmlucHV0c1swXS5kaW1zLm1hcCgoXyxiKT0+YikpO2xldCBzPUUubm9ybWFsaXplQXhlcyhhLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPXMsbD1lLmlucHV0c1swXSxwPWNoKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihsPWUuY29tcHV0ZShPZShlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPXNoKGQubGVuZ3RoLGwuZGltcy5sZW5ndGgpKTtsZXRbZixoXT11aChsLmRpbXMsZCkseT1mO28ua2VlcERpbXMmJih5PWRoKGYscykpLGUuY29tcHV0ZShwaCh0LG8uY2FjaGVLZXksW2xdLHIsZS5pbnB1dHNbMF0uZGF0YVR5cGUseSxoKSx7aW5wdXRzOltsXX0pfSxacz0oZSx0KT0+e250KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LFFzPShlLHQpPT57bnQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxZcz0oZSx0KT0+e250KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sWHM9KGUsdCk9PntudChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sSnM9KGUsdCk9PntudChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0sZXU9KGUsdCk9PntudChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sdHU9KGUsdCk9PntudChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxydT0oZSx0KT0+e250KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxudT0oZSx0KT0+e250KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxvdT0oZSx0KT0+e250KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBvdCxtaCxGcixsbyxpdCxmaCxoaCxnaCx5aCxiaCxfaCx3aCx2aCwkaCx4aCxhdCxhdSxzdSx1dSxkdSxsdSxjdSxwdSxtdSxmdSxodSxIcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtpdSgpO290PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sbWg9ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sRnI9KGUsdCxuLHIsbyxhLHM9ITEsZD0hMSk9PntsZXQgbD1bXSxwPW5bMF0uZGltcyxmPXAubGVuZ3RoLGg9RS5ub3JtYWxpemVBeGVzKG8sZikseT0hZCYmaC5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoUywkKT0+e3l8fGguaW5kZXhPZigkKT49MD9zJiZsLnB1c2goMSk6bC5wdXNoKFMpfSk7bGV0IF89bC5sZW5ndGgsYj1FLnNpemUobCk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTpTPT57bGV0ICQ9W10sdj1QKFwiX0FcIixuWzBdLmRhdGFUeXBlLGYpLFQ9TihcIm91dHB1dFwiLGEsXyksQz1yKHYsVCxoKSxBPUNbMl07Zm9yKGxldCBrPTAsTz0wO2s8ZjtrKyspeXx8aC5pbmRleE9mKGspPj0wPyhzJiZPKyssQT1gZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke3Bba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke0NbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke2t9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke0F9XG4gICAgICAgICAgICAgICAgfWApOigkLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssVC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixPKSl9O2ApLE8rKyk7cmV0dXJuYFxuXG4gICAgICAgICR7Uy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModixUKX1cblxuICAgICAgICAke1MubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtULm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHskLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtDWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke0NbMV19XG4gICAgICAgICAgJHtBfVxuICAgICAgICAgICR7Q1szXX1cbiAgICAgICAgICAke0MubGVuZ3RoPT09ND9ULnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6Qy5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmF9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChiLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmJ9LC4uLkgocCxsKV19KX19LGxvPShlLHQpPT57bGV0IG49W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHI9Pm4ucHVzaChOdW1iZXIocikpKSxyZSh7YXhlczpuLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxpdD0oZSx0LG4scik9PntsZXQgbz1lLmlucHV0cyxhPW8ubGVuZ3RoPT09MT9uOmxvKG8sbik7ZS5jb21wdXRlKEZyKHQse2hpbnQ6YS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0sYS5ub29wV2l0aEVtcHR5QXhlcyYmYS5heGVzLmxlbmd0aD09PTA/bWg6cixhLmF4ZXMsb1swXS5kYXRhVHlwZSxhLmtlZXBEaW1zLGEubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LGZoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0saGg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUwxXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxnaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTDJcIix0LChyLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LHloPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxiaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWF4XCIsdCwocixvLGEpPT57bGV0IHM9W107Zm9yKGxldCBkPTA7ZDxyLnJhbms7ZCsrKShhLmluZGV4T2YoZCk+PTB8fGEubGVuZ3RoPT09MCkmJnMucHVzaChyLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxfaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWVhblwiLHQsKHIsbyxhKT0+e2xldCBzPTE7Zm9yKGxldCBkPTA7ZDxyLnJhbms7ZCsrKShhLmluZGV4T2YoZCk+PTB8fGEubGVuZ3RoPT09MCkmJihzKj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHtzfSk7YF19KX0sd2g9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1pblwiLHQsKHIsbyxhKT0+e2xldCBzPVtdO2ZvcihsZXQgZD0wO2Q8ci5yYW5rO2QrKykoYS5pbmRleE9mKGQpPj0wfHxhLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sdmg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVByb2RcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSwkaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlU3VtXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0seGg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKHIsbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxhdD0oZSx0LG4pPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiBuO2xldCByPTEsbz0xO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXQuaW5kZXhPZihhKT09PS0xP3IqPWVbYV06byo9ZVthXTtyZXR1cm4gbzwzMiYmcj4xMDI0fSxhdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP19oKGUsdCk6WnMoZSx0KX0sc3U9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9oaChlLHQpOlFzKGUsdCl9LHV1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Z2goZSx0KTpZcyhlLHQpfSxkdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3loKGUsdCk6WHMoZSx0KX0sbHU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9iaChlLHQpOkpzKGUsdCl9LGN1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/d2goZSx0KTpldShlLHQpfSxwdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ZoKGUsdCk6dHUoZSx0KX0sbXU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT8kaChlLHQpOnJ1KGUsdCl9LGZ1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/eGgoZSx0KTpudShlLHQpfSxodT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2ZoKGUsdCk6b3UoZSx0KX19KTt2YXIgZ3UseXUsYnUsY28sX3U9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7Q2UoKTtIcigpO2d1PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHl1PShlLHQpPT57Z3UoZS5pbnB1dHMpO2xldCBuPShyLG8sYSk9PntsZXQgcz1bXTtmb3IobGV0IGQ9MDtkPHIucmFuaztkKyspKGEuaW5kZXhPZihkKT49MHx8YS5sZW5ndGg9PT0wKSYmcy5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShGcihcIkFyZ01pblwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxuLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sYnU9KGUsdCk9PntndShlLmlucHV0cyk7bGV0IG49KHIsbyxhKT0+e2xldCBzPVtdO2ZvcihsZXQgZD0wO2Q8ci5yYW5rO2QrKykoYS5pbmRleE9mKGQpPj0wfHxhLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEZyKFwiYXJnTWF4XCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLG4sW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxjbz1lPT5yZShlKX0pO3ZhciBTaCxwbyxUaCxDaCxJaCxVdCxBaCx3dSxxcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO1ZyKCk7Y2UoKTtTaD0oZSx0KT0+e2xldCBuPWVbMF0scj1lWzFdLG89ZVsyXSxhPWVbM10scz1lWzRdLGQ9ZVs1XTtpZihzJiZkKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgbD1uLmRpbXNbMF0scD1uLmRpbXNbMV0sZj1uLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKHIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1mKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1yLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCBoPW8uZGltc1swXS8zLHk9aCxfPXk7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBUIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoVCV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO2g9dC5xa3ZIaWRkZW5TaXplc1swXSx5PXQucWt2SGlkZGVuU2l6ZXNbMV0sXz10LnFrdkhpZGRlblNpemVzWzJdfWxldCBiPXA7aWYoaCE9PXkpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09aCt5K18pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IHc9MDtpZihzKXtpZih5IT09Xyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihzLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihzLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKHMuZGltc1sxXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKHMuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihzLmRpbXNbNF0hPT15L3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwodz1zLmRpbXNbM10pfWxldCBTPWIrdywkPS0xLHY9MDtpZihhKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihzKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bHx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09cHx8ZC5kaW1zWzNdIT09Uyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOncsa3ZTZXF1ZW5jZUxlbmd0aDpiLHRvdGFsU2VxdWVuY2VMZW5ndGg6UyxtYXhTZXF1ZW5jZUxlbmd0aDokLGlucHV0SGlkZGVuU2l6ZTpmLGhpZGRlblNpemU6aCx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IoaC90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTp2LHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxwbz0oZSx0LG4pPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke24/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLFRoPShlLHQsbixyLG8sYSxzLGQpPT57bGV0IGw9Z2Uocz8xOmEpLHA9NjQsZj1hL2w7ZjxwJiYocD0zMik7bGV0IGg9TWF0aC5jZWlsKGEvbC9wKSx5PVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6Zn0se3R5cGU6MTIsZGF0YTpofV0sXz1fZShlLmRhdGFUeXBlLGwpLGI9emUoMSxsKSx3PVtcInR5cGVcIl07cyYmdy5wdXNoKFwidHlwZVwiKSxkJiZ3LnB1c2goXCJ0eXBlXCIpO2xldCBTPSQ9PntsZXQgdj1OKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLGwpLFQ9W3ZdLEM9cz9QKFwic2VxX2xlbnNcIixzLmRhdGFUeXBlLHMuZGltcyk6dm9pZCAwO0MmJlQucHVzaChDKTtsZXQgQT1kP1AoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO0EmJlQucHVzaChBKTtsZXQgaz16ZShlLmRhdGFUeXBlKSxPPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke3B9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoTykuZGVjbGFyZVZhcmlhYmxlcyguLi5UKX1cbiAgJHskLm1haW5TdGFydChbcCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke3BvKEMsQSwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtwfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHtzP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7Yn0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke2J9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke2J9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke2J9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDEuMCkgLyAke2t9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7Yn0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHtzP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7X307JHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0U2hhZGVyU291cmNlOlMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvcCkseTpvLHo6dCpufSxwcm9ncmFtVW5pZm9ybXM6eX0pfX0sQ2g9KGUsdCxuLHIsbyxhLHMsZCxsKT0+e2xldCBwPXMrYS5rdlNlcXVlbmNlTGVuZ3RoLGY9W2EuYmF0Y2hTaXplLGEubnVtSGVhZHMsYS5zZXF1ZW5jZUxlbmd0aCxwXSxoPWU+MSYmcix5PWEua3ZOdW1IZWFkcz9hLmt2TnVtSGVhZHM6YS5udW1IZWFkcyxfPWg/W2EuYmF0Y2hTaXplLHkscCxhLmhlYWRTaXplXTp2b2lkIDAsYj1hLm5SZXBzP2EublJlcHM6MSx3PWEuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGEuaGVhZFNpemUpOmEuc2NhbGUsUz1nZShhLmhlYWRTaXplKSwkPWEuaGVhZFNpemUvUyx2PTEyLFQ9e3g6TWF0aC5jZWlsKHAvdikseTpNYXRoLmNlaWwoYS5zZXF1ZW5jZUxlbmd0aC92KSx6OmEuYmF0Y2hTaXplKmEubnVtSGVhZHN9LEM9W3t0eXBlOjEyLGRhdGE6YS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6YS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTphLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6d30se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmEua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpifV0sQT1oJiZyJiZFLnNpemUoci5kaW1zKT4wLGs9W1widHlwZVwiLFwidHlwZVwiXTtBJiZrLnB1c2goXCJ0eXBlXCIpLG8mJmsucHVzaChcInR5cGVcIiksZCYmay5wdXNoKFwidHlwZVwiKSxsJiZrLnB1c2goXCJ0eXBlXCIpO2xldCBPPVt7ZGltczpmLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO2gmJk8ucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBNPVY9PntsZXQgRj1QKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLFMpLGo9UChcImtleVwiLG4uZGF0YVR5cGUsbi5kaW1zLFMpLG5lPVtGLGpdO2lmKEEpe2xldCBaPVAoXCJwYXN0X2tleVwiLHIuZGF0YVR5cGUsci5kaW1zLFMpO25lLnB1c2goWil9byYmbmUucHVzaChQKFwiYXR0ZW50aW9uX2JpYXNcIixvLmRhdGFUeXBlLG8uZGltcykpO2xldCBXPWQ/UChcInNlcV9sZW5zXCIsZC5kYXRhVHlwZSxkLmRpbXMpOnZvaWQgMDtXJiZuZS5wdXNoKFcpO2xldCBKPWw/UChcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGwuZGF0YVR5cGUsbC5kaW1zKTp2b2lkIDA7SiYmbmUucHVzaChKKTtsZXQgdmU9TihcIm91dHB1dFwiLHQuZGF0YVR5cGUsZiksUT1bdmVdO2gmJlEucHVzaChOKFwicHJlc2VudF9rZXlcIix0LmRhdGFUeXBlLF8sUykpO2xldCBlZT16ZSgxLFMpLGxlPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia3Zfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5fcmVwc1wiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgY29uc3QgVElMRV9TSVpFID0gJHt2fXU7XG5cbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7Ri50eXBlLnN0b3JhZ2V9LCAke3Yqdn0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtGLnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gICR7Vi5yZWdpc3RlclVuaWZvcm1zKGxlKS5kZWNsYXJlVmFyaWFibGVzKC4uLm5lLC4uLlEpfVxuICAke1YubWFpblN0YXJ0KFt2LHYsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke2I9PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHtiPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke3BvKFcsSiwhMCl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7QSYmaD9cImxldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke2g/XCJsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9XG4gICAgdmFyIHZhbHVlID0gJHtlZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAke0EmJmg/YFxuICAgICAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBwYXN0X2tleVtwYXN0S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gOmBcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgIH1gfVxuICAgICAgJHtoP2BpZiAobiArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICBwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdO1xuICAgICAgfWA6XCJcIn1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJHtlZX0odGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueCArIGtdKTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgZ2xvYmFsX2lkLnggPCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgIGxldCBoZWFkT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgZ2xvYmFsX2lkLnkgKiB1bmlmb3Jtcy5OICsgZ2xvYmFsX2lkLng7XG4gICAgICB2YXIgc3VtOiBmMzIgPSAkeygoKT0+e3N3aXRjaChTKXtjYXNlIDE6cmV0dXJuXCJ2YWx1ZVwiO2Nhc2UgMjpyZXR1cm5cInZhbHVlLnggKyB2YWx1ZS55XCI7Y2FzZSA0OnJldHVyblwidmFsdWUueCArIHZhbHVlLnkgKyB2YWx1ZS56ICsgdmFsdWUud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke1N9YCl9fSkoKX07XG4gICAgICAgIG91dHB1dFtvdXRwdXRJZHhdID0gJHt2ZS50eXBlLnZhbHVlfSAoc3VtICogdW5pZm9ybXMuYWxwaGEpICsgJHtvP1wiYXR0ZW50aW9uX2JpYXNbb3V0cHV0SWR4XVwiOlwiMC4wXCJ9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uUHJvYnNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtTfTske28hPT12b2lkIDB9OyR7ciE9PXZvaWQgMH07JHtlfWAsaW5wdXREZXBlbmRlbmNpZXM6a30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOk8sZGlzcGF0Y2hHcm91cDpULHByb2dyYW1Vbmlmb3JtczpDfSksZ2V0U2hhZGVyU291cmNlOk19fSxJaD0oZSx0LG4scixvLGEscz12b2lkIDAsZD12b2lkIDApPT57bGV0IGw9YStvLmt2U2VxdWVuY2VMZW5ndGgscD1vLm5SZXBzP28ublJlcHM6MSxmPW8udkhpZGRlblNpemUqcCxoPWU+MSYmcix5PW8ua3ZOdW1IZWFkcz9vLmt2TnVtSGVhZHM6by5udW1IZWFkcyxfPWg/W28uYmF0Y2hTaXplLHksbCxvLmhlYWRTaXplXTp2b2lkIDAsYj1bby5iYXRjaFNpemUsby5zZXF1ZW5jZUxlbmd0aCxmXSx3PTEyLFM9e3g6TWF0aC5jZWlsKG8udkhlYWRTaXplL3cpLHk6TWF0aC5jZWlsKG8uc2VxdWVuY2VMZW5ndGgvdyksejpvLmJhdGNoU2l6ZSpvLm51bUhlYWRzfSwkPVt7dHlwZToxMixkYXRhOm8uc2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpvLnZIZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTpvLm51bUhlYWRzfSx7dHlwZToxMixkYXRhOm8uaGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6Zn0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOm8ua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpwfV0sdj1oJiZyJiZFLnNpemUoci5kaW1zKT4wLFQ9W1widHlwZVwiLFwidHlwZVwiXTt2JiZULnB1c2goXCJ0eXBlXCIpLHMmJlQucHVzaChcInR5cGVcIiksZCYmVC5wdXNoKFwidHlwZVwiKTtsZXQgQz1be2RpbXM6YixkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XTtoJiZDLnB1c2goe2RpbXM6XyxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9KTtsZXQgQT1rPT57bGV0IE89UChcInByb2JzXCIsdC5kYXRhVHlwZSx0LmRpbXMpLE09UChcInZcIixuLmRhdGFUeXBlLG4uZGltcyksVj1bTyxNXTt2JiZWLnB1c2goUChcInBhc3RfdmFsdWVcIixyLmRhdGFUeXBlLHIuZGltcykpO2xldCBGPXM/UChcInNlcV9sZW5zXCIscy5kYXRhVHlwZSxzLmRpbXMpOnZvaWQgMDtzJiZWLnB1c2goRik7bGV0IGo9ZD9QKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsZC5kYXRhVHlwZSxkLmRpbXMpOnZvaWQgMDtkJiZWLnB1c2goaik7bGV0IFc9W04oXCJvdXRwdXRcIix0LmRhdGFUeXBlLGIpXTtoJiZXLnB1c2goTihcInByZXNlbnRfdmFsdWVcIix0LmRhdGFUeXBlLF8pKTtsZXQgSj1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInZfaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia3Zfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5fcmVwc1wiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgY29uc3QgVElMRV9TSVpFID0gJHt3fXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke08udHlwZS52YWx1ZX0sICR7dyp3fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVWOiBhcnJheTwke08udHlwZS52YWx1ZX0sICR7dyp3fT47XG4gICR7ay5yZWdpc3RlclVuaWZvcm1zKEopLmRlY2xhcmVWYXJpYWJsZXMoLi4uViwuLi5XKX1cbiAgJHtrLm1haW5TdGFydChbdyx3LDFdKX1cbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBrdkhlYWRJZHggPSAke3A9PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBrdl9udW1faGVhZHMgPSAke3A9PT0xP1widW5pZm9ybXMubnVtX2hlYWRzXCI6XCJ1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcbiAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLks7XG4gICAke3BvKEYsaiwhMCl9XG4gICBsZXQgb2Zmc2V0QSA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcbiAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDsgLy8ga3ZIZWFkSWR4IGlzIHJlbGF0aXZlIHRvIHRoZSBiYXRjaFxuICAgJHt2JiZoP1wibGV0IHBhc3RWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCArIG47XCI6XCJcIn07XG4gICBsZXQgdk9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKyBuO1xuICAgJHtoP1wibGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjtcIjpcIlwifVxuICAgdmFyIHZhbHVlID0gJHtPLnR5cGUuc3RvcmFnZX0oMCk7XG4gICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHByb2JzW29mZnNldEEgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICAgJHt2JiZoP2BcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDpgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgICAgIH1gfVxuICAgICAgICAke2g/YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICBwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVWW2lkeF07XG4gICAgICAgIH1gOlwiXCJ9XG4gICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoOyBrKyspIHtcbiAgICAgICB2YWx1ZSArPSB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlVltUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueF07XG4gICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgfVxuXG4gICAvLyB3ZSBuZWVkIHRvIHRyYW5zcG9zZSBvdXRwdXQgZnJvbSBCTlNIX3YgdG8gQlNORF92XG4gICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgbGV0IG91dHB1dElkeCA9IGJhdGNoSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxuICAgICAgICsgaGVhZElkeCAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xuICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25TY29yZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3IhPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOlR9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpDLGRpc3BhdGNoR3JvdXA6Uyxwcm9ncmFtVW5pZm9ybXM6JH0pLGdldFNoYWRlclNvdXJjZTpBfX0sVXQ9KGUsdCxuLHIsbyxhLHMsZCxsLHAsZj12b2lkIDAsaD12b2lkIDApPT57bGV0IHk9TWF0aC5taW4oZS5vdXRwdXRDb3VudCwxKyhzPzE6MCkrKGQ/MTowKSksXz15PjE/cC5wYXN0U2VxdWVuY2VMZW5ndGg6MCxiPV8rcC5rdlNlcXVlbmNlTGVuZ3RoLHc9bCYmRS5zaXplKGwuZGltcyk+MD9sOnZvaWQgMCxTPVt0LG5dO3k+MSYmcyYmRS5zaXplKHMuZGltcyk+MCYmUy5wdXNoKHMpLHcmJlMucHVzaCh3KSxmJiZTLnB1c2goZiksaCYmUy5wdXNoKGgpO2xldCAkPWUuY29tcHV0ZShDaCh5LHQsbixzLHcscCxfLGYsaCkse2lucHV0czpTLG91dHB1dHM6eT4xP1stMSwxXTpbLTFdfSlbMF07ZS5jb21wdXRlKFRoKCQscC5iYXRjaFNpemUscC5udW1IZWFkcyxfLHAuc2VxdWVuY2VMZW5ndGgsYixmLGgpLHtpbnB1dHM6ZiYmaD9bJCxmLGhdOlskXSxvdXRwdXRzOltdfSk7bGV0IHY9WyQscl07eT4xJiZkJiZFLnNpemUoZC5kaW1zKT4wJiZ2LnB1c2goZCksZiYmdi5wdXNoKGYpLGgmJnYucHVzaChoKSxlLmNvbXB1dGUoSWgoeSwkLHIsZCxwLF8sZixoKSx7aW5wdXRzOnYsb3V0cHV0czp5PjE/WzAsMl06WzBdfSl9LEFoPShlLHQpPT57bGV0IG49W3QuYmF0Y2hTaXplLHQubnVtSGVhZHMsdC5zZXF1ZW5jZUxlbmd0aCx0LmhlYWRTaXplXSxyPXQuc2VxdWVuY2VMZW5ndGgsbz10LmlucHV0SGlkZGVuU2l6ZSxhPXQuaGVhZFNpemUscz0xMixkPXt4Ok1hdGguY2VpbCh0LmhlYWRTaXplL3MpLHk6TWF0aC5jZWlsKHQuc2VxdWVuY2VMZW5ndGgvcyksejp0LmJhdGNoU2l6ZSp0Lm51bUhlYWRzfSxsPVtlLmlucHV0c1swXSxlLmlucHV0c1sxXSxlLmlucHV0c1syXV0scD1be3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp0Lm51bUhlYWRzfSx7dHlwZToxMixkYXRhOnQuaGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6dC5oaWRkZW5TaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZSt0LmhpZGRlblNpemUrdC52SGlkZGVuU2l6ZX1dLGY9aD0+e2xldCB5PU4oXCJvdXRwdXRfcVwiLGxbMF0uZGF0YVR5cGUsbiksXz1OKFwib3V0cHV0X2tcIixsWzBdLmRhdGFUeXBlLG4pLGI9TihcIm91dHB1dF92XCIsbFswXS5kYXRhVHlwZSxuKSx3PVAoXCJpbnB1dFwiLGxbMF0uZGF0YVR5cGUsbFswXS5kaW1zKSxTPVAoXCJ3ZWlnaHRcIixsWzFdLmRhdGFUeXBlLGxbMV0uZGltcyksJD1QKFwiYmlhc1wiLGxbMl0uZGF0YVR5cGUsbFsyXS5kaW1zKSx2PXcudHlwZS5zdG9yYWdlLFQ9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJsZGJcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7c311O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7dn0sICR7cypzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke3Z9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0SzogYXJyYXk8JHt2fSwgJHtzKnN9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7dn0sICR7cypzfT47XG4gICR7aC5yZWdpc3RlclVuaWZvcm1zKFQpLmRlY2xhcmVWYXJpYWJsZXModyxTLCQseSxfLGIpfVxuICAke2gubWFpblN0YXJ0KFtzLHMsMV0pfVxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG5cbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiYXRjaEluZGV4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcbiAgICBsZXQgYmlhc09mZnNldFYgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRLO1xuXG4gICAgdmFyIHZhbHVlUSA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7dn0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodEtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRLICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xuICAgICAgICBsZXQgd2VpZ2h0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54O1xuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlViArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRWW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSAobSAqIHVuaWZvcm1zLk4gKyBuKSAlIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XG4gICAgdmFsdWVWICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRWXTtcblxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XG4gICAgICBvdXRwdXRfa1tvdXRwdXRJZHhdID0gdmFsdWVLO1xuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJlcGFyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6bixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpuLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOmQscHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6Zn0se2lucHV0czpsLG91dHB1dHM6Wy0xLC0xLC0xXX0pfSx3dT0oZSx0KT0+e2xldCBuPVNoKGUuaW5wdXRzLHQpLFtyLG8sYV09QWgoZSxuKTtyZXR1cm4gVXQoZSxyLG8sYSxlLmlucHV0c1s0XSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxlLmlucHV0c1s1XSxuKX19KTt2YXIga2gsRWgsUGgsdnUsJHU9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7dGUoKTthZSgpO0NlKCk7Y2UoKTtraD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzXCIpO2xldCBuPShyLG8sYSk9PntsZXQgcz1vLmxlbmd0aDtpZihzIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGAke2F9OiBudW0gZGltZW5zaW9ucyAhPSAke3N9YCk7by5mb3JFYWNoKChkLGwpPT57aWYoZCE9PXJbbF0pdGhyb3cgbmV3IEVycm9yKGAke2F9OiBkaW1bJHtsfV0gZG8gbm90IG1hdGNoYCl9KX07aWYoZVswXS5kaW1zLmxlbmd0aD4xKXtsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiP3Quc3BhdGlhbD9lWzBdLmRpbXMuc2xpY2UoLTEpOmVbMF0uZGltcy5zbGljZSgtMSkuY29uY2F0KGVbMF0uZGltcy5zbGljZSgxLGVbMF0uZGltcy5sZW5ndGgtMSkpOmVbMF0uZGltcy5zbGljZSgxLHQuc3BhdGlhbD8yOnZvaWQgMCk7bihlWzFdLmRpbXMscixcIkludmFsaWQgaW5wdXQgc2NhbGVcIiksbihlWzJdLmRpbXMscixcIkludmFsaWQgaW5wdXQgQlwiKSxuKGVbM10uZGltcyxyLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLG4oZVs0XS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IHZhclwiKX1lbHNlIG4oZVsxXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgc2NhbGVcIiksbihlWzJdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBCXCIpLG4oZVszXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgbWVhblwiKSxuKGVbNF0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHZhclwiKX0sRWg9KGUsdCk9PntsZXR7ZXBzaWxvbjpuLHNwYXRpYWw6cixmb3JtYXQ6b309dCxhPWVbMF0uZGltcyxzPXI/Z2UoYVthLmxlbmd0aC0xXSk6MSxkPW89PT1cIk5IV0NcIiYmYS5sZW5ndGg+MT9zOjEsbD1FLnNpemUoYSkvcyxwPXIsZj1wP2EubGVuZ3RoOmEsaD1QKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHMpLHk9UChcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsZCksXz1QKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGQpLGI9UChcImlucHV0TWVhblwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGQpLHc9UChcImlucHV0VmFyXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsZCksUz1OKFwieVwiLGVbMF0uZGF0YVR5cGUsZixzKSwkPSgpPT57bGV0IFQ9XCJcIjtpZihyKVQ9YGxldCBjT2Zmc2V0ID0gJHthLmxlbmd0aD09PTE/XCIwdVwiOm89PT1cIk5IV0NcIj9gb3V0cHV0SW5kaWNlc1ske2EubGVuZ3RoLTF9XSAvICR7c31gOlwib3V0cHV0SW5kaWNlc1sxXVwifTtgO2Vsc2UgaWYobz09PVwiTkNIV1wiKVQ9YFxuICAgICAgICAgICAgJHtTLmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke1MuaW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiKX07YDtlbHNle1Q9YHZhciBjSW5kaWNlcyA9ICR7eS50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHthLmxlbmd0aC0xfV07YDtmb3IobGV0IEM9MTtDPHkucmFuaztDKyspVCs9YGNJbmRpY2VzWyR7Q31dID0gb3V0cHV0SW5kaWNlc1ske0N9XTtgO1QrPWBsZXQgY09mZnNldCA9ICR7eS5pbmRpY2VzVG9PZmZzZXQoXCJjSW5kaWNlc1wiKX07YH1yZXR1cm4gVH0sdj1UPT5gXG4gIGNvbnN0IGVwc2lsb24gPSAke259O1xuICAke1QucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCx5LF8sYix3LFMpfVxuICAke1QubWFpblN0YXJ0KCl9XG4gICR7VC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke3N9YCl9O1xuICAgICR7JCgpfVxuICAgIGxldCBzY2FsZSA9ICR7eS5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBiaWFzID0gJHtfLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7Yi5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7dy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCB4ID0gJHtoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmVwc2lsb259XyR7dC5mb3JtYXR9XyR7cn1fJHtzfWAsaW5wdXREZXBlbmRlbmNpZXM6cD9bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdOnZvaWQgMH0sZ2V0U2hhZGVyU291cmNlOnYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cD9be3R5cGU6MTIsZGF0YTpsfSwuLi5IKGEpXTpbe3R5cGU6MTIsZGF0YTpsfV19KX19LFBoPWU9PnJlKGUpLHZ1PShlLHQpPT57bGV0e2lucHV0czpuLG91dHB1dENvdW50OnJ9PWUsbz1QaCh7Li4udCxvdXRwdXRDb3VudDpyfSk7aWYod2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZraChuLG8pLHQudHJhaW5pbmdNb2RlKXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2UuY29tcHV0ZShFaChuLG8pKX19KTt2YXIgemgsT2gseHUsU3U9RygoKT0+e1widXNlIHN0cmljdFwiO2FlKCk7Y2UoKTt6aD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxPaD1lPT57bGV0IHQ9ZVswXS5kaW1zLG49ZVswXS5kaW1zWzJdLHI9RS5zaXplKHQpLzQsbz1lWzBdLmRhdGFUeXBlLGE9UChcImlucHV0XCIsbyx0LDQpLHM9UChcImJpYXNcIixvLFtuXSw0KSxkPVAoXCJyZXNpZHVhbFwiLG8sdCw0KSxsPU4oXCJvdXRwdXRcIixvLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6Zj0+YFxuICBjb25zdCBjaGFubmVscyA9ICR7bn11IC8gNDtcbiAgJHtmLmRlY2xhcmVWYXJpYWJsZXMoYSxzLGQsbCl9XG5cbiAgJHtmLm1haW5TdGFydCgpfVxuICAgICR7Zi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHIpfVxuICAgIGxldCB2YWx1ZSA9ICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XG4gICAgICArICR7cy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9fSx4dT1lPT57emgoZS5pbnB1dHMpLGUuY29tcHV0ZShPaChlLmlucHV0cykpfX0pO3ZhciBEaCx5ZSxUdSxDdSxJdSxBdSxrdSxFdSxQdSx6dSxPdSxCaCxEdSxCdSxNdSxSdSx0cixVdSxLcixOdSxWdSxXdSxMdSxHdSxIdSxGdSxxdSxLdSxqdSxadSxRdSxZdSxYdSxKdSxlZCx0ZCxyZCxtbyxmbyxuZCxvZCxpZCxNaCxSaCxhZCxqcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtEaD0oZSx0LG4scixvLGEscyk9PntsZXQgZD1NYXRoLmNlaWwodC80KSxsPVwiXCI7dHlwZW9mIG89PVwic3RyaW5nXCI/bD1gJHtvfShhKWA6bD1vKFwiYVwiKTtsZXQgcD1QKFwiaW5wdXREYXRhXCIsbixbZF0sNCksZj1OKFwib3V0cHV0RGF0YVwiLHIsW2RdLDQpLGg9W3tuYW1lOlwidmVjX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm4gcyYmaC5wdXNoKC4uLnMpLGBcbiAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGgpLmRlY2xhcmVWYXJpYWJsZXMocCxmKX1cblxuICAke2E/P1wiXCJ9XG5cbiAgJHtlLm1haW5TdGFydCgpfVxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG5cbiAgICBsZXQgYSA9ICR7cC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7Zi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixsKX1cbiAgfWB9LHllPShlLHQsbixyLG8sYT1lLmRhdGFUeXBlLHMsZCk9PntsZXQgbD1be3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoRS5zaXplKGUuZGltcykvNCl9XTtyZXR1cm4gcyYmbC5wdXNoKC4uLnMpLHtuYW1lOnQsc2hhZGVyQ2FjaGU6e2hpbnQ6byxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6cD0+RGgocCxFLnNpemUoZS5kaW1zKSxlLmRhdGFUeXBlLGEsbixyLGQpLGdldFJ1bkRhdGE6cD0+KHtvdXRwdXRzOlt7ZGltczplLmRpbXMsZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEUuc2l6ZShwWzBdLmRpbXMpLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pfX0sVHU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sQ3U9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxJdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQWNvc2hcIixcImFjb3NoXCIpKX0sQXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxrdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sRXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSxQdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0senU9ZT0+cmUoZSksT3U9KGUsdCk9PntsZXQgbjtzd2l0Y2godC50byl7Y2FzZSAxMDpuPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOm49XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOm49XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6bj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpuPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkNhc3RcIixuLHZvaWQgMCx0LmNhY2hlS2V5LHQudG8pKX0sQmg9ZT0+e2xldCB0LG4scj1lLmxlbmd0aD49MiYmZVsxXS5kYXRhIT09MCxvPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGEhPT0wO3N3aXRjaChlWzBdLmRhdGFUeXBlKXtjYXNlIDE6dD1yP2VbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF06LTM0MDI4MjM0NjYzODUyODg2ZTIyLG49bz9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjM0MDI4MjM0NjYzODUyODg2ZTIyO2JyZWFrO2Nhc2UgMTA6dD1yP2VbMV0uZ2V0VWludDE2QXJyYXkoKVswXTo2NDUxMSxuPW8/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOjMxNzQzO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0IGRhdGEgdHlwZVwiKX1yZXR1cm4gcmUoe21pbjp0LG1heDpufSl9LER1PShlLHQpPT57bGV0IG49dHx8QmgoZS5pbnB1dHMpLHI9emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkNsaXBcIixvPT5gY2xhbXAoJHtvfSwgdmVjNDwke3J9Pih1bmlmb3Jtcy5taW4pLCB2ZWM0PCR7cn0+KHVuaWZvcm1zLm1heCkpYCx2b2lkIDAsbi5jYWNoZUtleSx2b2lkIDAsW3t0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6bi5taW59LHt0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6bi5tYXh9XSxbe25hbWU6XCJtaW5cIix0eXBlOnJ9LHtuYW1lOlwibWF4XCIsdHlwZTpyfV0pLHtpbnB1dHM6WzBdfSl9LEJ1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sTXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0sUnU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSx0cj1lPT5yZShlKSxVdT0oZSx0KT0+e2xldCBuPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJFbHVcIixyPT5gZWx1X3ZmMzIoJHtyfSlgLGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7bn0oJHt0LmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke259KSAtPiAke259IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtufT4pIC0+IHZlYzQ8JHtufT4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCx0LmNhY2hlS2V5KSl9LEtyPShlPVwiZjMyXCIpPT5gXG5jb25zdCByMDogJHtlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke2V9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHtlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke2V9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHtlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke2V9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YCxOdT1lPT57bGV0IHQ9emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkVyZlwiLG49PmBlcmZfdmYzMigke259KWAsS3IodCkpKX0sVnU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sV3U9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LEx1PWU9PntsZXQgdD16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiR2VsdVwiLG49PmAwLjUgKiAke259ICogKDEuMCArIGVyZl92ZjMyKCR7bn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsS3IodCkpKX0sR3U9KGUsdCk9PntsZXQgbj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiTGVha3lSZWx1XCIscj0+YHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7cn0sICR7cn0sICR7cn0gPj0gdmVjNDwke259PigwLjApKWAsYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtufSgke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKX0sSHU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIk5vdFwiLHQ9PmAhJHt0fWApKX0sRnU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIk5lZ1wiLHQ9PmAtJHt0fWApKX0scXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlJlY2lwcm9jYWxcIix0PT5gMS4wLyR7dH1gKSl9LEt1PWU9PntsZXQgdD16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiUmVsdVwiLG49PmBzZWxlY3QodmVjNDwke3R9PigwLjApLCAke259LCAke259ID4gdmVjNDwke3R9PigwLjApKWApKX0sanU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlNpZ21vaWRcIix0PT5gKDEuMCAvICgxLjAgKyBleHAoLSR7dH0pKSlgKSl9LFp1PWU9PnJlKGUpLFF1PShlLHQpPT57bGV0IG49emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkhhcmRTaWdtb2lkXCIscj0+YG1heCh2ZWM0PCR7bn0+KDAuMCksIG1pbih2ZWM0PCR7bn0+KDEuMCksICR7dC5hbHBoYX0gKiAke3J9ICsgdmVjNDwke259Pigke3QuYmV0YX0pKSlgLHZvaWQgMCx0LmNhY2hlS2V5KSl9LFl1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LFh1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJTaW5oXCIsXCJzaW5oXCIpKX0sSnU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSxlZD1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiVGFuXCIsXCJ0YW5cIikpfSx0ZD1lPT5gc2lnbigke2V9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7ZX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2V9KSkpYCxyZD1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiVGFuaFwiLHRkKSl9LG1vPShlPVwiZjMyXCIpPT5gXG5jb25zdCBmYXN0X2dlbHVfYTogJHtlfSA9IDAuNTtcbmNvbnN0IGZhc3RfZ2VsdV9iOiAke2V9ID0gMC43OTc4ODQ1NjA4MDI4NjU0O1xuY29uc3QgZmFzdF9nZWx1X2M6ICR7ZX0gPSAwLjAzNTY3NzQwODEzNjMwMDEyNTtcblxuZm4gdGFuaF92KHY6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICByZXR1cm4gJHt0ZChcInZcIil9O1xufVxuYCxmbz1lPT5gKGZhc3RfZ2VsdV9hICsgZmFzdF9nZWx1X2EgKiB0YW5oX3YoJHtlfSAqIChmYXN0X2dlbHVfYyAqICR7ZX0gKiAke2V9ICsgZmFzdF9nZWx1X2IpKSkgKiAke2V9YCxuZD1lPT57bGV0IHQ9emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkZhc3RHZWx1XCIsZm8sbW8odCksdm9pZCAwLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9LG9kPShlLHQpPT57bGV0IG49emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO3JldHVybiBlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJUaHJlc2hvbGRlZFJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHtufT4oMC4wKSwgJHtyfSwgJHtyfSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke259Pigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwfSxpZD1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiTG9nXCIsXCJsb2dcIikpfSxNaD0oZSx0KT0+YFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7ZX0+KCR7dH0pO1xuY29uc3Qgb25lID0gJHtlfSgxLjApO1xuY29uc3QgemVybyA9ICR7ZX0oMC4wKTtcblxuZm4gcXVpY2tfZ2VsdV9pbXBsKHg6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICBsZXQgdiA9IHggKmFscGhhO1xuICB2YXIgeDEgOiB2ZWM0PCR7ZX0+O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkgPSBpICsgMSkge1xuICAgIGlmICh2W2ldID49IHplcm8pIHtcbiAgICAgIHgxW2ldID0gb25lIC8gKG9uZSArIGV4cCgtdltpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MVtpXSA9IG9uZSAtIG9uZSAvIChvbmUgKyBleHAodltpXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geCAqIHgxO1xufVxuYCxSaD1lPT5gcXVpY2tfZ2VsdV9pbXBsKCR7ZX0pYCxhZD0oZSx0KT0+e2xldCBuPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJRdWlja0dlbHVcIixSaCxNaChuLHQuYWxwaGEpLHQuY2FjaGVLZXksZS5pbnB1dHNbMF0uZGF0YVR5cGUpKX19KTt2YXIgVWgsTmgsdWQsZGQ9RygoKT0+e1widXNlIHN0cmljdFwiO2FlKCk7Y2UoKTtqcigpO1VoPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVsyNTYwLDUxMjAsMTAyNDBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwiaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LE5oPWU9PntsZXQgdD1lWzBdLmRpbXMuc2xpY2UoKTt0WzJdPXRbMl0vMjtsZXQgbj1QKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyw0KSxyPVAoXCJiaWFzXCIsZVswXS5kYXRhVHlwZSxbZVswXS5kaW1zWzJdXSw0KSxvPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHQsNCksYT1FLnNpemUodCkvNCxzPV9lKGVbMF0uZGF0YVR5cGUpO3JldHVybntuYW1lOlwiQmlhc1NwbGl0R2VsdVwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOmw9PmBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XG5cbiAgJHtsLmRlY2xhcmVWYXJpYWJsZXMobixyLG8pfVxuXG4gICR7S3Iocyl9XG5cbiAgJHtsLm1haW5TdGFydCgpfVxuICAgICR7bC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGEpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7by5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlTGVmdCAqIGdlbHVSaWdodFwiKX1cbiAgfWB9fSx1ZD1lPT57VWgoZS5pbnB1dHMpLGUuY29tcHV0ZShOaChlLmlucHV0cykpfX0pO3ZhciBWaCxXaCxzdCxsZCxjZCxwZCxtZCxmZCxoZCxnZCx5ZCxiZCxfZCx3ZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7Vmg9KGUsdCxuLHIsbyxhLHMsZCxsLHAsZixoKT0+e2xldCB5LF87dHlwZW9mIGQ9PVwic3RyaW5nXCI/eT1fPSh2LFQpPT5gJHtkfSgoJHt2fSksKCR7VH0pKWA6dHlwZW9mIGQ9PVwiZnVuY3Rpb25cIj95PV89ZDooeT1kLnNjYWxhcixfPWQudmVjdG9yKTtsZXQgYj1OKFwib3V0cHV0RGF0YVwiLGYsci5sZW5ndGgsNCksdz1QKFwiYURhdGFcIixsLHQubGVuZ3RoLDQpLFM9UChcImJEYXRhXCIscCxuLmxlbmd0aCw0KSwkO2lmKG8paWYoYSl7bGV0IHY9RS5zaXplKHQpPT09MSxUPUUuc2l6ZShuKT09PTEsQz10Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wLEE9bi5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSU0PT09MDt2fHxUPyQ9Yi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKHY/YCR7dy50eXBlLnZhbHVlfSgke3cuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6dy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksVD9gJHtTLnR5cGUudmFsdWV9KCR7Uy5nZXRCeU9mZnNldChcIjBcIil9LngpYDpTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpOiQ9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gJHt3LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLGIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gJHtTLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLGIpfTtcbiAgICAgICAgICAgICR7Yi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKHN8fEM/dy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKTpgJHt3LnR5cGUudmFsdWV9KCR7dy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKX1bb2Zmc2V0QSAlIDR1XSlgLHN8fEE/Uy5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKTpgJHtTLnR5cGUudmFsdWV9KCR7Uy5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XG4gICAgICAgICAgYH1lbHNlICQ9Yi5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKHcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFMuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7bGV0IHY9KFQsQyxBPVwiXCIpPT57bGV0IGs9YGFEYXRhW2luZGV4QSR7Q31dW2NvbXBvbmVudEEke0N9XWAsTz1gYkRhdGFbaW5kZXhCJHtDfV1bY29tcG9uZW50QiR7Q31dYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7Q30gPSAke2Iub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke0N9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtDfSA9ICR7dy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7Q31gLGIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtDfSA9ICR7Uy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7Q31gLGIpfTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke0N9ID0gb2Zmc2V0QSR7Q30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke0N9ID0gb2Zmc2V0QiR7Q30gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtDfSA9IG9mZnNldEEke0N9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7Q30gPSBvZmZzZXRCJHtDfSAlIDR1O1xuICAgICAgICAgICAgJHtUfVske0N9XSA9ICR7QX0oJHt5KGssTyl9KTtcbiAgICAgICAgICBgfTtmPT09OT8kPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6JD1gXG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModyxTLGIpfVxuXG4gICAgICAgICR7aD8/XCJcIn1cblxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfSxXaD0oZSx0LG4scixvLGEscz1uLmRhdGFUeXBlKT0+e2xldCBkPW4uZGltcy5tYXAodz0+TnVtYmVyKHcpPz8xKSxsPXIuZGltcy5tYXAodz0+TnVtYmVyKHcpPz8xKSxwPSFFLmFyZUVxdWFsKGQsbCksZj1kLGg9RS5zaXplKGQpLHk9ITEsXz0hMSxiPVtwXTtpZihwKXtsZXQgdz1ydC5jYWxjU2hhcGUoZCxsLCExKTtpZighdyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtmPXcuc2xpY2UoKSxoPUUuc2l6ZShmKTtsZXQgUz1FLnNpemUoZCk9PT0xLCQ9RS5zaXplKGwpPT09MSx2PWQubGVuZ3RoPjAmJmRbZC5sZW5ndGgtMV0lND09PTAsVD1sLmxlbmd0aD4wJiZsW2wubGVuZ3RoLTFdJTQ9PT0wO2IucHVzaChTKSxiLnB1c2goJCksYi5wdXNoKHYpLGIucHVzaChUKTtsZXQgQz0xO2ZvcihsZXQgQT0xO0E8Zi5sZW5ndGg7QSsrKXtsZXQgaz1kW2QubGVuZ3RoLUFdLE89bFtsLmxlbmd0aC1BXTtpZihrPT09TylDKj1rO2Vsc2UgYnJlYWt9QyU0PT09MD8oXz0hMCx5PSEwKTooU3x8JHx8dnx8VCkmJih5PSEwKX1lbHNlIHk9ITA7cmV0dXJuIGIucHVzaCh5KSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OnQrYi5tYXAodz0+dy50b1N0cmluZygpKS5qb2luKFwiX1wiKSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6dz0+VmgodyxkLGwsZix5LHAsXyxvLG4uZGF0YVR5cGUsci5kYXRhVHlwZSxzLGEpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZixkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChFLnNpemUoZikvNCl9LC4uLkgoZCxsLGYpXX0pfX0sc3Q9KGUsdCxuLHIsbyxhKT0+e2UuY29tcHV0ZShXaCh0LG8/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sbixyLGEpKX0sbGQ9ZT0+e3N0KGUsXCJBZGRcIiwodCxuKT0+YCR7dH0rJHtufWApfSxjZD1lPT57c3QoZSxcIkRpdlwiLCh0LG4pPT5gJHt0fS8ke259YCl9LHBkPWU9PntzdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH09PSR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fT09JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxtZD1lPT57c3QoZSxcIk11bFwiLCh0LG4pPT5gJHt0fSoke259YCl9LGZkPWU9PntsZXQgdD1QKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO3N0KGUsXCJQb3dcIix7c2NhbGFyOihyLG8pPT5gcG93X2N1c3RvbSgke3J9LCR7b30pYCx2ZWN0b3I6KHIsbyk9PmBwb3dfdmVjdG9yX2N1c3RvbSgke3J9LCR7b30pYH0sYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKX0saGQ9ZT0+e3N0KGUsXCJTdWJcIiwodCxuKT0+YCR7dH0tJHtufWApfSxnZD1lPT57c3QoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH0+JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PiR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0seWQ9ZT0+e3N0KGUsXCJMZXNzXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PCR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fTwke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGJkPWU9PntzdChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH0+PSR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fT49JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxfZD1lPT57c3QoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PD0ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH08PSR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgR2gsSGgsRmgscWgsdmQsJGQseGQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7R2g9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgbj0wLHI9ZVtuXSxvPXIuZGF0YVR5cGUsYT1yLmRpbXMubGVuZ3RoO2UuZm9yRWFjaCgocyxkKT0+e2lmKGQhPT1uKXtpZihzLmRhdGFUeXBlIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihzLmRpbXMubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO3MuZGltcy5mb3JFYWNoKChsLHApPT57aWYocCE9PXQmJmwhPT1yLmRpbXNbcF0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9KX19KX0sSGg9KGUsdCk9PmBcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2V9dT4oJHt0fSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9OyBpICs9IDF1ICkge1xuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xuICB9YCxGaD0oZSx0KT0+e2xldCBuPWUubGVuZ3RoLHI9W107Zm9yKGxldCBvPTA7bzxuOysrbyl7bGV0IGE9dC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixlW29dLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIikpO249PT0xP3IucHVzaChhKTpvPT09MD9yLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7b311KSB7ICR7YX0gfWApOm89PT1uLTE/ci5wdXNoKGBlbHNlIHsgJHthfSB9YCk6ci5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7b30pIHsgJHthfSB9YCl9cmV0dXJuIHIuam9pbihgXG5gKX0scWg9KGUsdCxuLHIpPT57bGV0IG89RS5zaXplKG4pLGE9bmV3IEFycmF5KGUubGVuZ3RoKSxzPW5ldyBBcnJheShlLmxlbmd0aCksZD0wLGw9W10scD1bXSxmPVt7dHlwZToxMixkYXRhOm99XTtmb3IobGV0IHc9MDt3PGUubGVuZ3RoOysrdylkKz1lW3ddLmRpbXNbdF0sYVt3XT1kLHAucHVzaChlW3ddLmRpbXMubGVuZ3RoKSxzW3ddPVAoYGlucHV0JHt3fWAscixwW3ddKSxsLnB1c2goXCJyYW5rXCIpLGYucHVzaCh7dHlwZToxMixkYXRhOmFbd119KTtmb3IobGV0IHc9MDt3PGUubGVuZ3RoOysrdylmLnB1c2goLi4uSChlW3ddLmRpbXMpKTtmLnB1c2goLi4uSChuKSk7bGV0IGg9TihcIm91dHB1dFwiLHIsbi5sZW5ndGgpLHk9aC5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLHQpLF89QXJyYXkuZnJvbShBcnJheShhLmxlbmd0aCkua2V5cygpKS5tYXAodz0+YHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke3d9YCkuam9pbihcIixcIiksYj13PT5gXG5cbiAgJHsoKCk9Pnt3LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKTtmb3IobGV0IFM9MDtTPGUubGVuZ3RoO1MrKyl3LnJlZ2lzdGVyVW5pZm9ybShgc2l6ZUluQ29uY2F0QXhpcyR7U31gLFwidTMyXCIpO3JldHVybiB3LmRlY2xhcmVWYXJpYWJsZXMoLi4ucyxoKX0pKCl9XG5cbiAgJHtIaChhLmxlbmd0aCxfKX1cblxuICAke3cubWFpblN0YXJ0KCl9XG4gICAgJHt3Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke2gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHt5fSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2EubGVuZ3RofXU+KCR7X30pO1xuICAgICAgJHt5fSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHtGaChzLGgpfVxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpsfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6cn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTpifX0sdmQ9KGUsdCk9PntsZXQgbj1lLmlucHV0cyxyPW5bMF0uZGltcyxvPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsci5sZW5ndGgpO0doKG4sbyk7bGV0IGE9ci5zbGljZSgpO2Fbb109bi5yZWR1Y2UoKGQsbCk9PmQrKGwuZGltcy5sZW5ndGg+bz9sLmRpbXNbb106MCksMCk7bGV0IHM9bi5maWx0ZXIoZD0+RS5zaXplKGQuZGltcyk+MCk7ZS5jb21wdXRlKHFoKHMsbyxhLG5bMF0uZGF0YVR5cGUpLHtpbnB1dHM6c30pfSwkZD1lPT5yZSh7YXhpczplLmF4aXN9KX0pO3ZhciBqZSxaZSxRZSxacix2dD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2plPShlLHQsbj1cImYzMlwiKT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm5gdmFsdWUgPSBtYXgodmFsdWUsICR7dH0oMC4wKSk7YDtjYXNlXCJTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gKCR7dH0oMS4wKSAvICgke3R9KDEuMCkgKyBleHAoLXZhbHVlKSkpO2A7Y2FzZVwiQ2xpcFwiOnJldHVybmB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3R9KCR7bn0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt0fSgke259KHVuaWZvcm1zLmNsaXBfbWF4KSkpO2A7Y2FzZVwiSGFyZFNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSBtYXgoJHt0fSgwLjApLCBtaW4oJHt0fSgxLjApLCAke259KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlICsgJHtufSh1bmlmb3Jtcy5iZXRhKSkpO2A7Y2FzZVwiTGVha3lSZWx1XCI6cmV0dXJuYHZhbHVlID0gc2VsZWN0KCR7bn0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3R9KDAuMCkpO2A7Y2FzZVwiVGFuaFwiOnJldHVybmBsZXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnModmFsdWUpKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzaWduKHZhbHVlKSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XG4gICAgICAgIGA7Y2FzZVwiXCI6cmV0dXJuXCJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2UuYWN0aXZhdGlvbn1gKX19LFplPShlLHQpPT57ZS5hY3RpdmF0aW9uPT09XCJDbGlwXCI/dC5wdXNoKHt0eXBlOjEsZGF0YTplLmNsaXBNYXh9LHt0eXBlOjEsZGF0YTplLmNsaXBNaW59KTplLmFjdGl2YXRpb249PT1cIkhhcmRTaWdtb2lkXCI/dC5wdXNoKHt0eXBlOjEsZGF0YTplLmFscGhhfSx7dHlwZToxLGRhdGE6ZS5iZXRhfSk6ZS5hY3RpdmF0aW9uPT09XCJMZWFreVJlbHVcIiYmdC5wdXNoKHt0eXBlOjEsZGF0YTplLmFscGhhfSl9LFFlPShlLHQpPT57ZS5hY3RpdmF0aW9uPT09XCJDbGlwXCI/dC5wdXNoKHtuYW1lOlwiY2xpcF9tYXhcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiY2xpcF9taW5cIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkhhcmRTaWdtb2lkXCI/dC5wdXNoKHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSl9LFpyPWU9PntsZXQgdD1lPy5hY3RpdmF0aW9ufHxcIlwiO2lmKHQ9PT1cIkhhcmRTaWdtb2lkXCIpe2xldFtuLHJdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbLjIsLjVdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6bixiZXRhOnJ9fWVsc2UgaWYodD09PVwiQ2xpcFwiKXtsZXRbbixyXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8W0xzLEdzXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6cixjbGlwTWluOm59fWVsc2UgaWYodD09PVwiTGVha3lSZWx1XCIpe2xldFtuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4wMV07cmV0dXJue2FjdGl2YXRpb246dCxhbHBoYTpufX1yZXR1cm57YWN0aXZhdGlvbjp0fX19KTt2YXIgRWUsU2QsUXI9RygoKT0+e1widXNlIHN0cmljdFwiO0VlPShlLHQpPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt0fT5gO2Nhc2UgMzpyZXR1cm5gdmVjMzwke3R9PmA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dH0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtlfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19LFNkPWU9PmBcbiAgICAgICR7ZT9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTtcIjpcIlwifVxuICAgICAgYH0pO3ZhciBUZCxDZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VGQ9ZT0+YFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcbn1cbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgaTMyKCR7ZX0ueCksIGkzMigke2V9LnkpLCBpMzIoJHtlfS56KSwgMSkpO1xufVxuYH0pO3ZhciBycixZcixYcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7dnQoKTtycj0oZSx0LG4scixvKT0+e2xldCBhPXItbjtyZXR1cm5gXG4gICAgICAke0FycmF5LmZyb20oe2xlbmd0aDpufSkubWFwKChzLGQpPT5gXG4gICAgICBpZiAoJHtLKHQuc2hhcGUsZCx0LnJhbmspfSAhPSAxKSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCxLKG8sZCthLHIpKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCwwKX1cbiAgICAgIH1gKS5qb2luKFwiXCIpfVxuYH0sWXI9KGUsdCxuLHIsbz0hMSxhKT0+e2xldCBzPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPXNbcy5sZW5ndGgtMl0scD1kW2QubGVuZ3RoLTFdLGY9c1tzLmxlbmd0aC0xXSxoPWdlKHApLHk9Z2UoZiksXz1nZShsKSxiPUUuc2l6ZShuKS9oL18sdz1lLmxlbmd0aD4yLFM9cj9yLnNsaWNlKDAsLTIpOm4uc2xpY2UoMCwtMiksdj1bRS5zaXplKFMpLGwscF0sVD1be3R5cGU6MTIsZGF0YTpifSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTpmfV07WmUodCxUKSxULnB1c2goLi4uSChTLHMsZCkpLHcmJlQucHVzaCguLi5IKGVbMl0uZGltcykpLFQucHVzaCguLi5IKHYpKTtsZXQgQz1BPT57bGV0IGs9R3IoXCJiYXRjaF9kaW1zXCIsZVswXS5kYXRhVHlwZSxTLmxlbmd0aCksTz1QKFwiYVwiLGVbMF0uZGF0YVR5cGUscy5sZW5ndGgseSksTT1QKFwiYlwiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsaCksVj1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx2Lmxlbmd0aCxoKSxGPV9lKFYudHlwZS50ZW5zb3IpLGo9amUodCxWLnR5cGUudmFsdWUsRiksbmU9W08sTV0sVz1cIlwiO2lmKHcpe2xldCBRPW8/aDoxO25lLnB1c2goUChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsUSkpLFc9YCR7bz9gdmFsdWUgKz0gYmlhc1tjb2wgLyAke1F9XTtgOmB2YWx1ZSArPSAke1YudHlwZS52YWx1ZX0oYmlhc1tyb3cgKyBpXSk7YH1gfWxldCBKPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifV07UWUodCxKKTtsZXQgdmU9KCk9PntsZXQgUT1gdmFyIGFfZGF0YTogJHtPLnR5cGUudmFsdWV9O2A7Zm9yKGxldCBlZT0wO2VlPHk7ZWUrKylRKz1gXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2VlfSA9IGJbKGJfb2Zmc2V0ICsgKGsgKyAke2VlfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7aH1dO2A7Zm9yKGxldCBlZT0wO2VlPF87ZWUrKyl7USs9YGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7ZWV9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7eX1dO2A7Zm9yKGxldCBsZT0wO2xlPHk7bGUrKylRKz1gXG4gICAgICAgICAgICB2YWx1ZXNbJHtlZX1dID0gZm1hKCR7TS50eXBlLnZhbHVlfShhX2RhdGEke3k9PT0xP1wiXCI6YFske2xlfV1gfSksIGJfZGF0YSR7bGV9LCB2YWx1ZXNbJHtlZX1dKTtcbmB9cmV0dXJuIFF9O3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoSikucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLm5lLFYpfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7aH0pKSAqICR7aH07XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7aH0pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7X307XG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7X307XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7bi5sZW5ndGg9PT0yP1wiXCI6YGxldCBiYXRjaF9pbmRpY2VzID0gJHtrLm9mZnNldFRvSW5kaWNlcyhcImJhdGNoXCIpfTtgfVxuXG4gICAgdmFyIGFfaW5kaWNlczogJHtPLnR5cGUuaW5kaWNlc307XG4gICAgJHtycihcImFfaW5kaWNlc1wiLE8sTy5yYW5rLTIsay5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke08uaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLE8ucmFuay0yLDApfVxuICAgICR7Ty5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsTy5yYW5rLTEsMCl9XG4gICAgbGV0IGFfb2Zmc2V0ID0gJHtPLmluZGljZXNUb09mZnNldChcImFfaW5kaWNlc1wiKX07XG5cbiAgICB2YXIgYl9pbmRpY2VzOiAke00udHlwZS5pbmRpY2VzfTtcbiAgICAke3JyKFwiYl9pbmRpY2VzXCIsTSxNLnJhbmstMixrLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7TS5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsTS5yYW5rLTIsMCl9XG4gICAgJHtNLmluZGljZXNTZXQoXCJiX2luZGljZXNcIixNLnJhbmstMSwwKX1cbiAgICBsZXQgYl9vZmZzZXQgPSAke00uaW5kaWNlc1RvT2Zmc2V0KFwiYl9pbmRpY2VzXCIpfTtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke1YudHlwZS52YWx1ZX0sICR7X30+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke3l9KSB7XG4gICAgICAke3ZlKCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7X311OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7V31cbiAgICAgICR7an1cbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7Vi50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xuICAgICAgbGV0IG9mZnNldCA9ICR7Vi5pbmRpY2VzVG9PZmZzZXQoXCJjdXJfaW5kaWNlc1wiKX07XG4gICAgICAke1Yuc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7aH1gLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfVxuICBgfTtyZXR1cm57bmFtZTpcIk1hdE11bE5haXZlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5hY3RpdmF0aW9ufTske2h9OyR7eX07JHtffTske299YCxpbnB1dERlcGVuZGVuY2llczp3P1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphP2Eobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYi82NCl9LHByb2dyYW1Vbmlmb3JtczpUfSksZ2V0U2hhZGVyU291cmNlOkN9fX0pO3ZhciBLaCxqaCxobyxJZCxaaCxnbyxRaCxucixKcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7dnQoKTtYcigpO1FyKCk7S2g9KGUsdCk9PmU/YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgOmBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGAsamg9KGUsdCk9PmU/YFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxuICAgICAgICB9YDpgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxuICAgICAgICB9YCxobz0oZSx0LG49XCJmMzJcIixyLG89ITEsYT0zMixzPSExLGQ9MzIpPT57bGV0IGw9dFsxXSplWzFdLHA9dFswXSplWzBdLGY9bz9sOmEsaD1vP2E6bCx5PWYvdFswXSxfPWEvdFsxXTtpZighKChvJiZ5PT09NCYmZVsxXT09PTR8fCFvJiYoeT09PTN8fHk9PT00KSkmJmYldFswXT09PTAmJmEldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtvfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7eX0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHt5fSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke2Z9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHthfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke3l9PCR7bn0+LCAke2YveX0+LCAke2h9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtufT4sICR7cC9lWzBdfT4sICR7YX0+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke3l9O1xuY29uc3QgdGlsZUlubmVyID0gJHthfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7cz9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgJHtyP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtyLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtsfTtcblxuICBsZXQgbnVtX3RpbGVzID0gJHtzP2Ake01hdGguY2VpbChkL2EpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICB2YXIga1N0YXJ0ID0gJHtzP2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke259Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke199O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7S2gobyxyKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7eT09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cblxuICAgICAgICAgICR7amgobyx5KX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWB9LElkPShlLHQpPT5lP2BcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYDpgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGAsWmg9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIsZ289KGUsdCxuPVwiZjMyXCIscixvPSExLGE9MzIscz0hMSxkPTMyLGw9ITEpPT57bGV0IHA9ZVsxXSp0WzFdLGY9ZVswXSp0WzBdLGg9bz9wOmEseT1vP2E6cDtpZighKHkldFsxXT09PTAmJmgldFswXT09PTAmJmEldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke3l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke2F9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IF89eS90WzFdLGI9aC90WzBdLHc9YS90WzFdLFM9bD9gXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke2Z9O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3l9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7aH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgJHtJZChvLHIpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7YX07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7Zn07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke3I/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtufSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke28/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYDpgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7X307XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Yn07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7d307XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtifTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHtJZChvLHIpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7d307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7Wmgobyl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtufSwgJHtofT4sICR7eX0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtufSwgJHtmfT4sICR7YX0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke2F9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHtzP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAgICR7cj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7ci5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gICAgbGV0IG51bV90aWxlcyA9ICR7cz9gJHtNYXRoLmNlaWwoZC9hKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgICB2YXIga1N0YXJ0ID0gJHtzP2BpMzIoZ2xvYmFsSWQueikgKiAke2R9YDpcIjBcIn07XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtufSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcbiAgICAke1N9XG4gIH1cbmB9LFFoPShlLHQsbixyLG89ITEpPT57bGV0W2EscyxkLGxdPXIscD1fZShyWzBdLnR5cGUudGVuc29yKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHthLnR5cGUuaW5kaWNlc30pIC0+ICR7RWUoZSxwKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtFZShlLHApfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGFJbmRpY2VzOiAke3MudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHtycihcImFJbmRpY2VzXCIscyxzLnJhbmstMixhLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7cy5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixzLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke3MuaW5kaWNlc1NldChcImFJbmRpY2VzXCIscy5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7cy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHthLnR5cGUuaW5kaWNlc30pIC0+ICR7RWUoZSxwKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHtFZShlLHApfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGJJbmRpY2VzOiAke2QudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHtycihcImJJbmRpY2VzXCIsZCxkLnJhbmstMixhLnJhbmssXCJiYXRjaEluZGljZXNcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMixcInUzMihyb3cpXCIpfVxuICAgICAgICAke2QuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsZC5yYW5rLTEsXCJ1MzIoY29sSW4pXCIpfVxuICAgICAgICB2YWx1ZSA9ICR7ZC5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7RWUoZSxwKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7bz9cImJpYXNbY29sSW5dXCI6YCR7RWUoZSxwKX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cbiAgICAgICAgJHtufVxuICAgICAgICAke2wuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxuICAgICAgfVxuICAgIH1cbiAgICBgfSxucj0oZSx0LG4scixvPSExLGEpPT57bGV0IHM9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9cy5zbGljZSgwLC0yKSxwPWQuc2xpY2UoMCwtMiksZj1yP3Iuc2xpY2UoMCwtMik6bi5zbGljZSgwLC0yKSxoPUUuc2l6ZShmKSx5PXNbcy5sZW5ndGgtMl0sXz1zW3MubGVuZ3RoLTFdLGI9ZFtkLmxlbmd0aC0xXSx3PV8lND09PTAmJmIlND09PTAsUz15PD04P1s0LDEsMV06WzQsNCwxXSwkPVs4LDgsMV0sdj1bTWF0aC5jZWlsKGIvJFswXS9TWzBdKSxNYXRoLmNlaWwoeS8kWzFdL1NbMV0pLE1hdGguY2VpbChoLyRbMl0vU1syXSldLFQ9dz80OjEsQz1bLi4ubCx5LF8vVF0sQT1DLmxlbmd0aCxrPVsuLi5wLF8sYi9UXSxPPWsubGVuZ3RoLE09W2gseSxiL1RdLFY9W3t0eXBlOjYsZGF0YTp5fSx7dHlwZTo2LGRhdGE6Yn0se3R5cGU6NixkYXRhOl99XTtaZSh0LFYpLFYucHVzaCguLi5IKGYsQyxrKSk7bGV0IEY9W1wicmFua1wiLFwicmFua1wiXSxqPWUubGVuZ3RoPjI7aiYmKFYucHVzaCguLi5IKGVbMl0uZGltcykpLEYucHVzaChcInJhbmtcIikpLFYucHVzaCguLi5IKE0pKTtsZXQgbmU9Vz0+e2xldCBKPWYubGVuZ3RoLHZlPUdyKFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxKLDEpLFE9X2UoZVswXS5kYXRhVHlwZSksZWU9UChcImFcIixlWzBdLmRhdGFUeXBlLEEsVCksbGU9UChcImJcIixlWzFdLmRhdGFUeXBlLE8sVCksWj1OKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxNLmxlbmd0aCxUKSxwZT1bZWUsbGVdO2lmKGope2xldCBZPW8/VDoxO3BlLnB1c2goUChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsWSkpfWxldCBrZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtRZSh0LGtlKTtsZXQgU2U9X2UoWi50eXBlLnRlbnNvciksRD1qZSh0LFoudHlwZS52YWx1ZSxTZSksUj1RaChULGosRCxbdmUsZWUsbGUsWl0sbyk7cmV0dXJuYFxuICAke1cucmVnaXN0ZXJVbmlmb3JtcyhrZSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyh2ZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5wZSxaKX1cbiAgJHtSfVxuICAke3c/aG8oUywkLFEsdmUpOmdvKFMsJCxRLHZlKX1cbiAgICAgICAgICAgICAgICAgICBgfTtyZXR1cm57bmFtZTpcIk1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke1N9OyR7dC5hY3RpdmF0aW9ufTske3d9OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOkZ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YT9hKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6dlswXSx5OnZbMV0sejp2WzJdfSxwcm9ncmFtVW5pZm9ybXM6Vn0pLGdldFNoYWRlclNvdXJjZTpuZX19fSk7dmFyIFloLEFkLGtkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO3R0KCk7Y2UoKTt2dCgpO1FyKCk7Q2QoKTtKcigpO1loPShlLHQsbixyLG89ITEsYSxzPTQsZD00LGw9NCxwPVwiZjMyXCIpPT57bGV0IGY9Rj0+e3N3aXRjaChGKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtwfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7Rn0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGg9Rj0+e3N3aXRjaChGKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0Z9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx5PWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCxfPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAsYj1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIix3PWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiLFM9ZT9cInJvd1wiOlwiY29sXCIsJD1lP1wiY29sXCI6XCJyb3dcIix2PWBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgbGV0IG91dFJvdyA9ICR7U30gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHtTfSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAkeyR9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHskfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7JH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtFZShzLHApfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHtifSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7d30pIHtcbiAgICAgICR7eX1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7ZihzKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxUPWU/dCYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0VlKHMscCl9KDAuMCk7YDpyJiZuP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgICR7dn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dn1cbiAgICB9XG4gICAgcmV0dXJuICR7RWUocyxwKX0oMC4wKTtgLEM9ZT9yJiZuP2goZCk6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHtoKGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtFZShkLHApfSgwLjApO2A6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlcikge1xuICAgICAgJHtoKGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtFZShkLHApfSgwLjApO2AsQT1FZShsLHApLGs9ZT9FZShzLHApOkVlKGQscCksTz1lP0VlKGQscCk6RWUocyxwKSxNPWplKGEsQSxwKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtrfSB7XG4gICAgICAke2U/VDpDfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7T30ge1xuICAgICAgJHtlP0M6VH1cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtBfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgICAke199XG4gICAgICAke1NkKG8pfVxuICAgICAgJHtNfVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWB9LEFkPShlLHQsbixyLG8sYSxzLGQsbCk9PntsZXQgcD10LmZvcm1hdD09PVwiTkhXQ1wiLGY9cD9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGg9blswXSx5PXA/blsyXTpuWzNdLF89cD9uWzFdOm5bMl0sYj1wP25bM106blsxXSx3PXAmJihmJTQ9PT0wfHxmJTM9PT0wKSYmYiU0PT09MCxTPXA/Yjp5Kl8sJD1wP3kqXzpiLHY9WzgsOCwxXSxUPXI8PTg/WzQsMSwxXTpbNCw0LDFdLEM9W01hdGguY2VpbChTL3ZbMF0vVFswXSksTWF0aC5jZWlsKCQvdlsxXS9UWzFdKSxNYXRoLmNlaWwoaC92WzJdL1RbMl0pXTttZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7Q31gKTtsZXQgQT13P3AmJmYlNCE9PTA/Mzo0OjEsaz12WzFdKlRbMV0sTz12WzBdKlRbMF0sTT1NYXRoLm1heCh2WzBdKkEsdlsxXSksVj1yJWs9PT0wLEY9byVPPT09MCxqPWElTT09PTAsbmU9dz9bQSw0LDRdOlsxLDEsMV0sVz1be3R5cGU6NixkYXRhOnJ9LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6YX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07WmUodCxXKSxXLnB1c2goLi4uSChlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IEo9W1wicmFua1wiLFwicmFua1wiXTtzJiYoVy5wdXNoKC4uLkgoZVsyXS5kaW1zKSksSi5wdXNoKFwicmFua1wiKSksVy5wdXNoKC4uLkgobikpO2xldCB2ZT1RPT57bGV0IGVlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07UWUodCxlZSk7bGV0IGxlPXc/NDoxLFo9X2UoZVswXS5kYXRhVHlwZSkscGU9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHt3P2B2ZWM0PCR7Wn0+YDpafSkge1xuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7dz9gdmVjNDwke1p9PmA6Wn0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHt3P2B2ZWM0PCR7Wn0+YDpafSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke3c/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsa2U9UChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsQT09PTM/MTpBKSxTZT1QKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxsZSksRD1ba2UsU2VdLFI9TihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgsbGUpO2lmKHMpe2xldCBZPVAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGxlKTtELnB1c2goWSkscGUrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHt3P2B2ZWM0PCR7Wn0+YDpafSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7cD9cIndcIjpcInlcIn0ke3c/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfXJldHVybmBcbiAgICAgICAgJHtUZChcInVuaWZvcm1zLnJlc3VsdF9zdHJpZGVzXCIpfVxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcbiAgICAgICAgJHtRLnJlZ2lzdGVyVW5pZm9ybXMoZWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uRCxSKX1cbiAgICAgICAgJHtwZX1cbiAgICAgICAgJHtZaChwLFYsRixqLHMsdCxuZVswXSxuZVsxXSxuZVsyXSxaKX1cbiAgICAgICAgJHt3P2hvKFQsdixaLHZvaWQgMCwhcCxNKTpnbyhULHYsWix2b2lkIDAsIXAsTSwhMSx2b2lkIDAsZCl9YH07cmV0dXJue25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske0F9OyR7d307JHtWfTske0Z9OyR7an07JHtrfTske099OyR7TX1gLGlucHV0RGVwZW5kZW5jaWVzOkp9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bD9sKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6Q1swXSx5OkNbMV0sejpDWzJdfSxwcm9ncmFtVW5pZm9ybXM6V30pLGdldFNoYWRlclNvdXJjZTp2ZX19fSk7dmFyIFhoLEVkLGVuLEpoLFBkLGVnLHpkLE9kLERkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO3R0KCk7YWUoKTtjZSgpO3Z0KCk7UXIoKTtYaD1lPT57bGV0IHQ9MTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl0Kj1lW25dO3JldHVybiB0fSxFZD1lPT50eXBlb2YgZT09XCJudW1iZXJcIj9bZSxlLGVdOmUsZW49KGUsdCk9PnQ8PTE/ZTplKyhlLTEpKih0LTEpLEpoPShlLHQsbixyPTEpPT57bGV0IG89ZW4odCxyKTtyZXR1cm4gTWF0aC5mbG9vcigoZVswXSoobi0xKS1uK28pLzIpfSxQZD0oZSx0LG4scixvKT0+e289PW51bGwmJihvPUpoKGUsdFswXSxyWzBdKSk7bGV0IGE9WzAsMCwwLG5dO2ZvcihsZXQgcz0wO3M8MztzKyspZVtzXSsyKm8+PXRbc10mJihhW3NdPU1hdGgudHJ1bmMoKGVbc10tdFtzXSsyKm8pL3Jbc10rMSkpO3JldHVybiBhfSxlZz0oZSx0LG4scixvLGEscyxkLGwscCk9PntsZXQgZixoLHksXztpZihlPT09XCJWQUxJRFwiJiYoZT0wKSx0eXBlb2YgZT09XCJudW1iZXJcIil7Zj17dG9wOmUsYm90dG9tOmUsbGVmdDplLHJpZ2h0OmUsZnJvbnQ6ZSxiYWNrOmV9O2xldCBiPVBkKFt0LG4sciwxXSxbZCxsLHBdLDEsW28sYSxzXSxlKTtoPWJbMF0seT1iWzFdLF89YlsyXX1lbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe2lmKCFlLmV2ZXJ5KCh3LFMsJCk9Pnc9PT0kWzBdKSl0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtmPXt0b3A6ZVswXSxib3R0b206ZVsxXSxsZWZ0OmVbMl0scmlnaHQ6ZVszXSxmcm9udDplWzRdLGJhY2s6ZVs1XX07bGV0IGI9UGQoW3QsbixyLDFdLFtkLGwscF0sMSxbbyxhLHNdLGVbMF0pO2g9YlswXSx5PWJbMV0sXz1iWzJdfWVsc2UgaWYoZT09PVwiU0FNRV9VUFBFUlwiKXtoPU1hdGguY2VpbCh0L28pLHk9TWF0aC5jZWlsKG4vYSksXz1NYXRoLmNlaWwoci9zKTtsZXQgYj0oaC0xKSpvK2QtdCx3PSh5LTEpKmErbC1uLFM9KF8tMSkqcytwLXIsJD1NYXRoLmZsb29yKGIvMiksdj1iLSQsVD1NYXRoLmZsb29yKHcvMiksQz13LVQsQT1NYXRoLmZsb29yKFMvMiksaz1TLUE7Zj17dG9wOlQsYm90dG9tOkMsbGVmdDpBLHJpZ2h0OmssZnJvbnQ6JCxiYWNrOnZ9fWVsc2UgdGhyb3cgRXJyb3IoYFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtyZXR1cm57cGFkSW5mbzpmLG91dERlcHRoOmgsb3V0SGVpZ2h0Onksb3V0V2lkdGg6X319LHpkPShlLHQsbixyLG8sYT0hMSxzPVwiY2hhbm5lbHNMYXN0XCIpPT57bGV0IGQsbCxwLGYsaDtpZihzPT09XCJjaGFubmVsc0xhc3RcIilbZCxsLHAsZixoXT1lO2Vsc2UgaWYocz09PVwiY2hhbm5lbHNGaXJzdFwiKVtkLGgsbCxwLGZdPWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke3N9YCk7bGV0W3ksLF8sYix3XT10LFtTLCQsdl09RWQobiksW1QsQyxBXT1FZChyKSxrPWVuKF8sVCksTz1lbihiLEMpLE09ZW4odyxBKSx7cGFkSW5mbzpWLG91dERlcHRoOkYsb3V0SGVpZ2h0Omosb3V0V2lkdGg6bmV9PWVnKG8sbCxwLGYsUywkLHYsayxPLE0pLFc9YT95Kmg6eSxKPVswLDAsMCwwLDBdO3JldHVybiBzPT09XCJjaGFubmVsc0ZpcnN0XCI/Sj1bZCxXLEYsaixuZV06cz09PVwiY2hhbm5lbHNMYXN0XCImJihKPVtkLEYsaixuZSxXXSkse2JhdGNoU2l6ZTpkLGRhdGFGb3JtYXQ6cyxpbkRlcHRoOmwsaW5IZWlnaHQ6cCxpbldpZHRoOmYsaW5DaGFubmVsczpoLG91dERlcHRoOkYsb3V0SGVpZ2h0Omosb3V0V2lkdGg6bmUsb3V0Q2hhbm5lbHM6VyxwYWRJbmZvOlYsc3RyaWRlRGVwdGg6UyxzdHJpZGVIZWlnaHQ6JCxzdHJpZGVXaWR0aDp2LGZpbHRlckRlcHRoOl8sZmlsdGVySGVpZ2h0OmIsZmlsdGVyV2lkdGg6dyxlZmZlY3RpdmVGaWx0ZXJEZXB0aDprLGVmZmVjdGl2ZUZpbHRlckhlaWdodDpPLGVmZmVjdGl2ZUZpbHRlcldpZHRoOk0sZGlsYXRpb25EZXB0aDpULGRpbGF0aW9uSGVpZ2h0OkMsZGlsYXRpb25XaWR0aDpBLGluU2hhcGU6ZSxvdXRTaGFwZTpKLGZpbHRlclNoYXBlOnR9fSxPZD0oZSx0LG4scixvLGEpPT57bGV0IHM9YT09PVwiY2hhbm5lbHNMYXN0XCIsZD1zP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbD0hMSxwPVs2NCwxLDFdLGY9e3g6bi5tYXAoKHYsVCk9PlQpfSxoPVtNYXRoLmNlaWwoWGgoZi54Lm1hcCh2PT5uW3ZdKSkvcFswXSksMSwxXTttZShcInZlcmJvc2VcIiwoKT0+YFtjb252M2RfbmFpdmVfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7aH1gKTtsZXQgeT1sP3MmJmQlNCE9PTA/Mzo0OjEsXz1FLnNpemUobiksYj1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9XTtaZSh0LGIpLGIucHVzaCguLi5IKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgdz1bXCJyYW5rXCIsXCJyYW5rXCJdLFM9ZS5sZW5ndGg9PT0zO1MmJihiLnB1c2goLi4uSChlWzJdLmRpbXMpKSx3LnB1c2goXCJyYW5rXCIpKSxiLnB1c2goLi4uSChuKSk7bGV0ICQ9dj0+e2xldCBUPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpyLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofV07UWUodCxUKTtsZXQgQz1sPzQ6MSxBPV9lKGVbMF0uZGF0YVR5cGUpLGs9UChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgseT09PTM/MTp5KSxPPVAoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLEMpLE09W2ssT10sVj1OKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCxDKSxGPVwiXCI7aWYoUyl7bGV0IFc9UChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsQyk7TS5wdXNoKFcpLEYrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IGFycmF5PHUzMiwgNT4pIC0+ICR7bD9gdmVjNDwke0F9PmA6QX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzWyR7cz9LKFwiY29vcmRzXCIsNCw1KTpLKFwiY29vcmRzXCIsMSw1KX0ke2w/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfWxldCBqPUVlKHksQSksbmU9amUodCxqLEEpO3JldHVybmBcbiAgICAgICAgICAgICR7Rn1cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke2suZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7Ty5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoVCkuZGVjbGFyZVZhcmlhYmxlcyguLi5NLFYpfVxuICAgICAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtWLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke0soXCJjb29yZHNcIiwwLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke3M/SyhcImNvb3Jkc1wiLGsucmFuay0xLGsucmFuayk6SyhcImNvb3Jkc1wiLDEsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7cz9LKFwiY29vcmRzXCIsMSxrLnJhbmspOksoXCJjb29yZHNcIiwyLGsucmFuayl9LFxuICAgICAgICAgICAgICAke3M/SyhcImNvb3Jkc1wiLDIsay5yYW5rKTpLKFwiY29vcmRzXCIsMyxrLnJhbmspfSxcbiAgICAgICAgICAgICAgJHtzP0soXCJjb29yZHNcIiwzLGsucmFuayk6SyhcImNvb3Jkc1wiLDQsay5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHtzP0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspOksoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke3M/SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayk6SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwzLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7cz9LKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKTpLKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHtzP0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspOksoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtzP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke3M/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7cz9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke3M/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtTP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7bmV9XG4gICAgICAgICAgICAgIHJlc3VsdFtnbG9iYWxfaWR4XSA9IGYzMih2YWx1ZSk7XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQ29udjNETmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske3N9OyR7eX07JHtTfWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OmhbMF0seTpoWzFdLHo6aFsyXX0scHJvZ3JhbVVuaWZvcm1zOmJ9KSxnZXRTaGFkZXJTb3VyY2U6JH19fSk7dmFyIEJkLE1kLFJkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTt2dCgpO0JkPShlLHQsbixyKT0+e2xldCBvPWUubGVuZ3RoPjIsYT1vP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIixzPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPXQuZm9ybWF0PT09XCJOSFdDXCIscD1sP25bM106blsxXSxmPXAvdC5ncm91cCxoPWwmJmY+PTQ/Z2UocCk6MSx5PUUuc2l6ZShuKS9oLF89W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTp0LmRpbGF0aW9uc30se3R5cGU6MTIsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjEyLGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZToxMixkYXRhOmZ9XTtaZSh0LF8pLF8ucHVzaCguLi5IKHMsW2RbMF0sZFsxXSxkWzJdLGRbM10vaF0pKTtsZXQgYj1vP1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXTtfLnB1c2goLi4uSChbblswXSxuWzFdLG5bMl0sblszXS9oXSkpO2xldCB3PVM9PntsZXQgJD1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCxoKSx2PV9lKCQudHlwZS50ZW5zb3IpLFQ9amUodCwkLnR5cGUudmFsdWUsdiksQz1QKFwieFwiLGVbMF0uZGF0YVR5cGUscy5sZW5ndGgpLEE9UChcIndcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLGgpLGs9W0MsQV07byYmay5wdXNoKFAoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaCkpO2xldCBPPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV07UWUodCxPKTtsZXQgTT1sP2BcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVswXTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHtDLmdldChcImJhdGNoXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke0EuZ2V0KFwid0hlaWdodFwiLFwid1dpZHRoXCIsXCJ3SW5DaGFubmVsXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0hlaWdodCsrKSB7XG4gICAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVszXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVszXSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHhWYWwgPSAke0MuZ2V0KFwiYmF0Y2hcIixcImlucHV0X2NoYW5uZWxcIixcInhIZWlnaHRcIixcInhXaWR0aFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJvdXRwdXRfY2hhbm5lbFwiLFwid0luQ2hhbm5lbFwiLFwid0hlaWdodFwiLFwid1dpZHRoXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDtyZXR1cm5gXG4gICR7Uy5yZWdpc3RlclVuaWZvcm1zKE8pLmRlY2xhcmVWYXJpYWJsZXMoLi4uaywkKX1cblxuICAke1MubWFpblN0YXJ0KCl9XG4gICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtsPzM6MX1dO1xuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7bD8xOjJ9XSwgb3V0cHV0SW5kaWNlc1ske2w/MjozfV0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAqICR7aH0gLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgIHZhciBpbl9jaGFubmVsX29mZnNldCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVske2w/MjoxfV07XG5cbiAgICB2YXIgdmFsdWU6ICR7JC50eXBlLnZhbHVlfSA9ICR7JC50eXBlLnZhbHVlfSgwKTtcbiAgICAke019XG4gICAgJHthfVxuICAgICR7VH1cbiAgICAkeyQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnZcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fV8ke2h9YCxpbnB1dERlcGVuZGVuY2llczpifSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cihuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6d319LE1kPShlLHQsbixyKT0+e2xldCBvPWUubGVuZ3RoPjIsYT1nZShuWzNdKSxzPWdlKG5bMl0pLGQ9RS5zaXplKG4pL2EvcyxsPVtlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM10vYV0scD1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl0sZVsxXS5kaW1zWzNdL2FdLGY9W25bMF0sblsxXSxuWzJdLG5bM10vYV0saD1be3R5cGU6MTIsZGF0YTpkfSx7dHlwZTo2LGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZTo2LGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfV07WmUodCxoKSxoLnB1c2goLi4uSChsLHAsZikpO2xldCB5PShzLTEpKnQuc3RyaWRlc1sxXStwWzFdLF89Yj0+e2xldCB3PU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGYubGVuZ3RoLGEpLFM9X2Uody50eXBlLnRlbnNvciksJD1qZSh0LHcudHlwZS52YWx1ZSxTKSx2PVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxsLmxlbmd0aCxhKSxUPVAoXCJ3XCIsZVsxXS5kYXRhVHlwZSxwLmxlbmd0aCxhKSxDPVt2LFRdO28mJkMucHVzaChQKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGEpKTtsZXQgQT1vP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIixrPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn1dO3JldHVybiBRZSh0LGspLGBcbiAgJHtiLnJlZ2lzdGVyVW5pZm9ybXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5DLHcpfVxuICAke2IubWFpblN0YXJ0KCl9XG4gICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyB3aWR0aDA7XG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7c311O1xuICAgIGxldCBjb2wgPSAoaW5kZXgxICUgd2lkdGgxKSAqICR7c311O1xuICAgIGluZGV4MSA9IGluZGV4MSAvIHdpZHRoMTtcbiAgICBsZXQgcm93ID0gaW5kZXgxICUgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcblxuICAgIGxldCB4X2Nvcm5lciA9IHZlYzI8aTMyPihpMzIocm93KSwgaTMyKGNvbCkpICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG5cbiAgICB2YXIgeF92YWxzOiBhcnJheTwke3YudHlwZS52YWx1ZX0sICR7eX0+O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7dy50eXBlLnZhbHVlfSwgJHtzfT47XG4gICAgbGV0IGlucHV0X2NoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbDtcbiAgICAvLyBVc2UgY29uc3RhbnQgaW5zdGVhZCBvZiB1bmlmb3JtIGNhbiBnaXZlIGJldHRlciBwZXJmb3JtYW5jZSBmb3IgdydzIGhlaWdodC93aWR0aC5cbiAgICBmb3IgKHZhciB3X2hlaWdodDogdTMyID0gMHU7IHdfaGVpZ2h0IDwgJHtwWzBdfTsgd19oZWlnaHQrKykge1xuICAgICAgbGV0IHhfaGVpZ2h0ID0geF9jb3JuZXIueCArIGkzMih3X2hlaWdodCk7XG4gICAgICBpZiAoeF9oZWlnaHQgPj0gMCAmJiB1MzIoeF9oZWlnaHQpIDwgdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7eX07IGkrKykge1xuICAgICAgICAgIGxldCB4X3dpZHRoID0geF9jb3JuZXIueSArIGk7XG4gICAgICAgICAgaWYgKHhfd2lkdGggPj0gMCAmJiB1MzIoeF93aWR0aCkgPCB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3YuZ2V0KFwiYmF0Y2hcIixcInUzMih4X2hlaWdodClcIixcInUzMih4X3dpZHRoKVwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgd193aWR0aDogdTMyID0gMHU7IHdfd2lkdGggPCAke3BbMV19OyB3X3dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgd192YWwgPSAke1QuZ2V0KFwid19oZWlnaHRcIixcIndfd2lkdGhcIixcIjBcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3N9dTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSBmbWEoeF92YWxzW2kgKiB1MzIodW5pZm9ybXMuc3RyaWRlc1sxXSkgKyB3X3dpZHRoXSwgd192YWwsIHZhbHVlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtzfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtBfVxuICAgICAgJHskfVxuICAgICAgJHt3LnNldChcImJhdGNoXCIsXCJyb3dcIixcImNvbCArIGlcIixcIm91dHB1dF9jaGFubmVsXCIsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udi1WZWN0b3JpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2F9OyR7c307JHt5fTske3BbMF19OyR7cFsxXX1gLGlucHV0RGVwZW5kZW5jaWVzOm8/W1wicmFua1wiLFwicmFua1wiLFwidHlwZVwiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cihuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KSxnZXRTaGFkZXJTb3VyY2U6X319fSk7dmFyIHRnLHlvLHJnLGJvLF9vLFVkLG5nLG9nLHdvLE5kPUcoKCk9PntcInVzZSBzdHJpY3RcIjthZSgpO2tkKCk7RGQoKTtKcigpO1JkKCk7dnQoKTtYcigpO2N0KCk7dGc9KGUsdCxuLHIsbyxhKT0+e2xldCBzPWVbMF0sZD1lLnNsaWNlKGE/MToyLGE/Mzo0KSxsPWQubGVuZ3RoLHA9dFswXSxoPXQuc2xpY2UoMikubWFwKChiLHcpPT5iKyhiLTEpKihuW3ddLTEpKSxfPWQubWFwKChiLHcpPT5iK3Jbd10rclt3K2xdKS5tYXAoKGIsdyk9Pk1hdGguZmxvb3IoKGItaFt3XStvW3ddKS9vW3ddKSk7cmV0dXJuIF8uc3BsaWNlKDAsMCxzKSxfLnNwbGljZShhPzM6MSwwLHApLF99LHlvPVsyLDMsMSwwXSxyZz0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcImdyZWF0ZXIgdGhhbiA1RCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCBuPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxyPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKG4hPT1yKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBvPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke299RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnBhZHMubGVuZ3RoIT09byoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtvKjJ9RGApO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIil9LGJvPShlLHQpPT57bGV0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO24ubGVuZ3RoPHRbMV0uZGltcy5sZW5ndGgtMiYmbi5wdXNoKC4uLkFycmF5KHRbMV0uZGltcy5sZW5ndGgtMi1uLmxlbmd0aCkuZmlsbCgwKSk7Zm9yKGxldCBhPTI7YTx0WzFdLmRpbXMubGVuZ3RoOysrYSluW2EtMl09PT0wJiYoblthLTJdPXRbMV0uZGltc1thXSk7bGV0IHI9ZS5wYWRzLnNsaWNlKCk7a3QuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMsbixyLGUuZm9ybWF0PT09XCJOSFdDXCIsZS5hdXRvUGFkKTtsZXQgbz1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKG8se2tlcm5lbFNoYXBlOm4scGFkczpyfSksb30sX289ZT0+e2xldCB0PVpyKGUpLG49ZS5mb3JtYXQscj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLG89ZS5kaWxhdGlvbnMsYT1lLmdyb3VwLHM9ZS5rZXJuZWxfc2hhcGUsZD1lLnBhZHMsbD1lLnN0cmlkZXMscD1lLndfaXNfY29uc3QoKTtyZXR1cm57YXV0b1BhZDpyLGZvcm1hdDpuLGRpbGF0aW9uczpvLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxwYWRzOmQsc3RyaWRlczpsLHdJc0NvbnN0OnAsLi4udCxjYWNoZUtleTpgJHtlLmZvcm1hdH07JHt0LmFjdGl2YXRpb259O2B9fSxVZD0oZSx0LG4scik9PntsZXQgbz1uLmZvcm1hdD09PVwiTkhXQ1wiLGE9dGcodFswXS5kaW1zLHRbMV0uZGltcyxuLmRpbGF0aW9ucyxuLnBhZHMsbi5zdHJpZGVzLG8pO2lmKG4uZ3JvdXAhPT0xKXtsZXQgaz1bdFswXV07aWYobyl7bGV0IE09ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoT2UodFsxXSx5bykse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPU0pLGsucHVzaChNKX1lbHNlIGsucHVzaCh0WzFdKTt0Lmxlbmd0aD09PTMmJmsucHVzaCh0WzJdKSwhZS5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZShcImFtcGVyZVwiKSYmbyYmdFsxXS5kaW1zWzBdPT09bi5ncm91cCYmdFsxXS5kaW1zWzFdPT09MSYmbi5kaWxhdGlvbnNbMF09PT0xJiZuLmRpbGF0aW9uc1sxXT09PTE/ZS5jb21wdXRlKE1kKGssbixhLHIpLHtpbnB1dHM6a30pOmUuY29tcHV0ZShCZChrLG4sYSxyKSx7aW5wdXRzOmt9KTtyZXR1cm59bGV0IHM9dC5sZW5ndGg9PT0zLGQ9dFswXS5kaW1zW28/MToyXSxsPXRbMF0uZGltc1tvPzI6M10scD10WzBdLmRpbXNbbz8zOjFdLGY9dFsxXS5kaW1zWzJdLGg9dFsxXS5kaW1zWzNdLHk9YVtvPzE6Ml0sXz1hW28/MjozXSxiPWFbbz8zOjFdLHc9byYmZj09PWQmJmg9PT1sJiZuLnBhZHNbMF09PT0wJiZuLnBhZHNbMV09PT0wO2lmKHd8fGY9PT0xJiZoPT09MSYmbi5kaWxhdGlvbnNbMF09PT0xJiZuLmRpbGF0aW9uc1sxXT09PTEmJm4uc3RyaWRlc1swXT09PTEmJm4uc3RyaWRlc1sxXT09PTEmJm4ucGFkc1swXT09PTAmJm4ucGFkc1sxXT09PTApe2xldCBrPWFbMF0sTyxNLFYsRj1bXTtpZihvKXtsZXQgVz1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShPZSh0WzFdLHlvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO2lmKG4ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9Vyksdyl7bGV0IEo9ZCpsKnA7Tz10WzBdLnJlc2hhcGUoWzEsayxKXSksTT1XLnJlc2hhcGUoWzEsSixiXSksVj1bMSxrLGJdfWVsc2UgTz10WzBdLnJlc2hhcGUoW2ssZCpsLHBdKSxNPVcucmVzaGFwZShbMSxwLGJdKSxWPVtrLHkqXyxiXTtGLnB1c2goTyksRi5wdXNoKE0pfWVsc2UgTz10WzBdLnJlc2hhcGUoW2sscCxkKmxdKSxNPXRbMV0ucmVzaGFwZShbMSxiLHBdKSxWPVtrLGIseSpfXSxGLnB1c2goTSksRi5wdXNoKE8pO3MmJkYucHVzaCh0WzJdKTtsZXQgaj1WWzJdLG5lPUZbMF0uZGltc1tGWzBdLmRpbXMubGVuZ3RoLTFdO2o8OCYmbmU8OD9lLmNvbXB1dGUoWXIoRixuLGEsVixvLHIpLHtpbnB1dHM6Rn0pOmUuY29tcHV0ZShucihGLG4sYSxWLG8scikse2lucHV0czpGfSk7cmV0dXJufWxldCBTPSEwLCQ9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoT2UodFsxXSx5bykse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPSQpO2xldCB2PVt0WzBdLCRdO3MmJnYucHVzaCh0WzJdKTtsZXQgVD1vP3kqXzpiLEM9bz9iOnkqXyxBPWYqaCpwO2UuY29tcHV0ZShBZCh2LG4sYSxULEMsQSxzLFMscikse2lucHV0czp2fSl9LG5nPShlLHQpPT57bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIixyPVtlLmlucHV0c1swXS5yZXNoYXBlKG4/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZyLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0sYT1bMV0uY29uY2F0KHQuc3RyaWRlcykscz1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxkPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbD1ibyh7Li4udCxwYWRzOm8sc3RyaWRlczphLGRpbGF0aW9uczpzLGtlcm5lbFNoYXBlOmR9LHIpO1VkKGUscixsLHA9Pm4/W3BbMF0scFsyXSxwWzNdXTpbcFswXSxwWzFdLHBbM11dKX0sb2c9KGUsdCxuKT0+e2xldCByPW4uZm9ybWF0PT09XCJOSFdDXCI/XCJjaGFubmVsc0xhc3RcIjpcImNoYW5uZWxzRmlyc3RcIixvPWJvKG4sdCksYT1uLmF1dG9QYWQ9PT1cIk5PVFNFVFwiP24ucGFkczpuLmF1dG9QYWQscz16ZCh0WzBdLmRpbXMsdFsxXS5kaW1zLG4uc3RyaWRlcyxuLmRpbGF0aW9ucyxhLCExLHIpO2UuY29tcHV0ZShPZCh0LG8scy5vdXRTaGFwZSxbcy5maWx0ZXJEZXB0aCxzLmZpbHRlckhlaWdodCxzLmZpbHRlcldpZHRoXSxbcy5wYWRJbmZvLmZyb250LHMucGFkSW5mby50b3Ascy5wYWRJbmZvLmxlZnRdLHIpKX0sd289KGUsdCk9PntpZihyZyhlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpbmcoZSx0KTtlbHNlIGlmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSlvZyhlLGUuaW5wdXRzLHQpO2Vsc2V7bGV0IG49Ym8odCxlLmlucHV0cyk7VWQoZSxlLmlucHV0cyxuKX19fSk7dmFyIFZkLFdkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO3R0KCk7YWUoKTtjZSgpO1ZkPShlLHQsbik9PntsZXQgcj1lLmxlbmd0aD4yLG89dC5vdXRwdXRTaGFwZSxhPXQuZm9ybWF0PT09XCJOSFdDXCIscz10Lmdyb3VwLGQ9ZVsxXS5kaW1zLGw9ZFsyXS9zLHA9ZFszXSxmPWE/Z2UobCk6MSxoPWE/Z2UocCk6MSx5PWE/cD09PTE/ZjpoOjEsXz1FLnNpemUobykvaCxiPVtNYXRoLmNlaWwoXy82NCksMSwxXTttZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7Yn1gKTtsZXQgdz1bXCJyYW5rXCIsXCJyYW5rXCJdLFM9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLCQ9W3Qua2VybmVsU2hhcGVbYT8xOjJdLHQua2VybmVsU2hhcGVbYT8yOjNdXSx2PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sVD1bJFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVthPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSwkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2E/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxDPVtUWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksVFsxXS0xLU1hdGguZmxvb3IoKHQucGFkc1sxXSt0LnBhZHNbM10pLzIpXSxBPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6U30se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnZ9LHt0eXBlOjEyLGRhdGE6VH0se3R5cGU6NixkYXRhOkN9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSwuLi5IKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtyJiYoQS5wdXNoKC4uLkgoZVsyXS5kaW1zKSksdy5wdXNoKFwicmFua1wiKSksQS5wdXNoKC4uLkgobykpO2xldCBrPU89PntsZXQgTT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpTLmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOkMubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sVj1fZShlWzBdLmRhdGFUeXBlKSxGPWE/MToyLGo9YT8yOjMsbmU9YT8zOjEsVz1QKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCx5KSxKPVAoXCJEeVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxmKSx2ZT1bSixXXTtyJiZ2ZS5wdXNoKFAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxbb1tuZV1dLmxlbmd0aCxoKSk7bGV0IFE9TihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaCksZWU9KCk9PntsZXQgWj1cIlwiO2lmKGY9PT0xKVorPWBcbiAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcbiAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vy5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke3l9YCl9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO2Vsc2UgaWYocD09PTEpWis9YFxuICAgICAgICAgIGxldCB3VmFsdWUgPSAke1cuZ2V0QnlPZmZzZXQoYCR7Vy5pbmRpY2VzVG9PZmZzZXQoYCR7Vy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX0gLyAke3l9YCl9O1xuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtgO2Vsc2UgZm9yKGxldCBwZT0wO3BlPGY7cGUrKylaKz1gXG4gICAgICAgICAgICBsZXQgd1ZhbHVlJHtwZX0gPSAke1cuZ2V0QnlPZmZzZXQoYCR7Vy5pbmRpY2VzVG9PZmZzZXQoYCR7Vy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsICsgJHtwZX0sIHdPdXRDaGFubmVsKWApfSAvICR7eX1gKX07XG4gICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZVske3BlfV0gKiB3VmFsdWUke3BlfTtgO3JldHVybiBafSxsZT1gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7US5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2h9YCl9O1xuICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtRLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsMCl9O1xuICAgICAgICAgICAgbGV0IGQxID0gJHtRLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsbmUpfTtcbiAgICAgICAgICAgIGxldCByID0gJHtRLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRil9O1xuICAgICAgICAgICAgbGV0IGMgPSAke1EuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixqKX07XG4gICAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAke1EudHlwZS52YWx1ZX0oMC4wKTtcbiAgICAgICAgICAgIHZhciB3UjogdTMyID0gMDtcbiAgICAgICAgICAgIGlmICh1bmlmb3Jtcy5kaWxhdGlvbnMueCA9PSAxKSB7XG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gd1IgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlSQ29ybmVyICsgd1IpICUgKHVuaWZvcm1zLnN0cmlkZXMueCkgPT0gMFxuICAgICAgICAgICAgICB3UiA9IHUzMigoKGR5UkNvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIGR5UkNvcm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtWfShkeVJDb3JuZXIpICsgJHtWfSh3UikpIC8gJHtWfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtWfSh1bmlmb3Jtcy5EeV9zaGFwZVske0Z9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcbiAgICAgICAgICAgICAgdmFyIHdDOiB1MzIgPSAwO1xuICAgICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gd0MgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlDQ29ybmVyICsgd0MpICUgKHVuaWZvcm1zLnN0cmlkZXMueSkgPT0gMFxuICAgICAgICAgICAgICAgIHdDID0gdTMyKCgoZHlDQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gZHlDQ29ybmVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7Vn0oZHlDQ29ybmVyKSArICR7Vn0od0MpKSAvICR7Vn0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueSAtIDEgLSB3QyAvIHVuaWZvcm1zLmRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Vn0odW5pZm9ybXMuRHlfc2hhcGVbJHtqfV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqIHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7IGQyID0gZDIgKyAke2Z9KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHthP0ouZ2V0QnlPZmZzZXQoYCR7Si5pbmRpY2VzVG9PZmZzZXQoYCR7Si50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHtmfWApOkouZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XG4gICAgICAgICAgICAgICAgICAke2VlKCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke2Z9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3QyA9IHdDICsgdW5pZm9ybXMuc3RyaWRlcy55IC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3UiA9IHdSICsgdW5pZm9ybXMuc3RyaWRlc1swXSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtyP2AgKyBiaWFzW2QxIC8gJHtofV1gOlwiXCJ9O1xuICAgICAgICAgICAgJHtRLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgICAgIGA7cmV0dXJuYFxuICAgICR7Ty5yZWdpc3RlclVuaWZvcm1zKE0pLmRlY2xhcmVWYXJpYWJsZXMoLi4udmUsUSl9XG4gICAgICAke08ubWFpblN0YXJ0KCl9XG4gICAgICAke08uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfTtcbiAgICAke2xlfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7Zn0ke3l9JHtofSR7cD09PTF9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6YlswXSx5OmJbMV0sejpiWzJdfSxvdXRwdXRzOlt7ZGltczpuP24obyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkF9KSxnZXRTaGFkZXJTb3VyY2U6a319fSk7dmFyIGlnLGFnLHNnLExkLEdkLHVnLEhkLGRnLEZkLHFkPUcoKCk9PntcInVzZSBzdHJpY3RcIjtXZCgpO3Z0KCk7Y3QoKTtpZz0oZSx0LG4scixvLGEpPT4oZS0xKSp0K24rKHItMSkqbysxLWEsYWc9KGUsdCxuLHIsbyk9PntsZXQgYT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhuW3JdPWEsbltvXT1lLWEpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKG5bcl09ZS1hLG5bb109YSl9LHNnPShlLHQsbixyLG8sYSxzLGQsbCxwKT0+e2xldCBmPWUubGVuZ3RoLTIsaD1wLmxlbmd0aD09PTA7bC5sZW5ndGg8ZiYmbC5wdXNoKC4uLkFycmF5KGYtbC5sZW5ndGgpLmZpbGwoMCkpO2xldCB5PWVbMF0sXz10W2Q/MzoxXSpvO2ZvcihsZXQgYj0wLHc9ZS5sZW5ndGgtZi0oZD8xOjApO2I8ZjsrK2IsKyt3KXtsZXQgUz1lW3ddLCQ9aD9TKnNbYl06cFtiXSx2PWlnKFMsc1tiXSxhW2JdLHRbd10sbltiXSwkKTthZyh2LHIsYSxiLGIrZiksaCYmcC5wdXNoKHNbYl0qKFMtMSkrbFtiXSsodFt3XS0xKSpuW2JdKzEtYVtiXS1hW2IrZl0pfXAuc3BsaWNlKDAsMCx5KSxwLnNwbGljZShkPzM6MSwwLF8pfSxMZD0oZSx0KT0+e2xldCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKChoLHkpPT5oKnksMSk9PT0wKXtuLmxlbmd0aD0wO2ZvcihsZXQgaD0yO2g8dFsxXS5kaW1zLmxlbmd0aDsrK2gpbi5wdXNoKHRbMV0uZGltc1toXSl9bGV0IHI9ZS5mb3JtYXQ9PT1cIk5IV0NcIjtuLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxuLnNwbGljZShyPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksYT1lLm91dHB1dFNoYXBlLnNsaWNlKCkscz1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxsPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobC5yZWR1Y2UoKGgseSk9PmgreSwwKT09PTApe2xldCBoPXRbMF0uZGltcy5sZW5ndGgtMjtsPW5ldyBBcnJheShoKS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKChoLHkpPT5oK3ksMCk9PT0wKXtsZXQgaD10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkoaCkuZmlsbCgxKX1zZyhkLG4sbCxlLmF1dG9QYWQsZS5ncm91cCxvLHAscixzLGEpO2xldCBmPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZix7a2VybmVsU2hhcGU6bixwYWRzOm8sb3V0cHV0UGFkZGluZzpzLG91dHB1dFNoYXBlOmEsZGlsYXRpb25zOmwsc3RyaWRlczpwfSksZn0sR2Q9ZT0+e2xldCB0PVpyKGUpLG49ZS5mb3JtYXQscj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsYT1lLmdyb3VwLHM9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxmPWUub3V0cHV0UGFkZGluZyxoPWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6cixmb3JtYXQ6bixkaWxhdGlvbnM6byxncm91cDphLGtlcm5lbFNoYXBlOnMsb3V0cHV0UGFkZGluZzpmLG91dHB1dFNoYXBlOmgscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sdWc9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgbj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0scj1lWzFdLmRpbXNbMF07aWYobiE9PXIpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBhPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKGYsaCk9PmYraCwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2F9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKGYsaCk9PmYraCwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7YX1EYCk7aWYodC5wYWRzLnJlZHVjZSgoZixoKT0+ZitoLDApPjAmJnQucGFkcy5sZW5ndGghPT1hKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2EqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWEmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7YX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKGYsaCk9PmYraCwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LEhkPShlLHQsbixyKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKE9lKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO24ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGE9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZhLnB1c2godFsyXSksZS5jb21wdXRlKFZkKGEsbixyKSx7aW5wdXRzOmF9KX0sZGc9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9W2UuaW5wdXRzWzBdLnJlc2hhcGUobj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJnIucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGE9dC5kaWxhdGlvbnM7KGEubGVuZ3RoPT09MHx8YVswXT09PTApJiYoYT1bMV0pO2xldCBzPXQuc3RyaWRlczsocy5sZW5ndGg9PT0wfHxzWzBdPT09MCkmJihzPVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLHM9WzFdLmNvbmNhdChzKSxhPVsxXS5jb25jYXQoYSksbz1bMV0uY29uY2F0KG8pO2xldCBsPXQub3V0cHV0UGFkZGluZztsPVswXS5jb25jYXQobCk7bGV0IHA9TGQoey4uLnQscGFkczpkLHN0cmlkZXM6cyxkaWxhdGlvbnM6YSxrZXJuZWxTaGFwZTpvLG91dHB1dFBhZGRpbmc6bH0scik7SGQoZSxyLHAsZj0+bj9bZlswXSxmWzJdLGZbM11dOltmWzBdLGZbMV0sZlszXV0pfSxGZD0oZSx0KT0+e2lmKHVnKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09MylkZyhlLHQpO2Vsc2V7bGV0IG49TGQodCxlLmlucHV0cyk7SGQoZSxlLmlucHV0cyxuKX19fSk7dmFyIGxnLEtkLGpkLFpkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO2xnPShlLHQsbixyKT0+e2xldCBvPUUuc2l6ZSh0KSxhPXQubGVuZ3RoLHM9UChcImlucHV0XCIsZSxhKSxkPU4oXCJvdXRwdXRcIixlLGEpLGw9bi5kYXRhVHlwZT09PTY/bi5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKG4uZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxwPUUubm9ybWFsaXplQXhpcyhsLGEpLGY9aD0+e2xldCB5PWAgaTMyKCR7cy5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxfPUsoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGEpLGI9ci5yZXZlcnNlP3krKHIuZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLHc9ci5yZXZlcnNlP186eSsoci5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocyxkKX1cbiAgICAgICAgICAgICAgICAke2gubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7ZC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7Yn07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7d307XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHtzLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7cy5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnB9LC4uLkgodCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6Zn19LEtkPShlLHQpPT57bGV0IG49ZS5pbnB1dHNbMF0uZGltcyxyPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKGxnKHIsbixvLHQpLHtpbnB1dHM6WzBdfSl9LGpkPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEsbj1lLnJldmVyc2U9PT0xO3JldHVybiByZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpufSl9fSk7dmFyIGNnLHBnLG1nLFFkLFlkLFhkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO2NnPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuXCIpfSxwZz0oZSx0LG4scik9PntsZXQgbz1bXTtvLnB1c2goYGZuIHBlcm0oaTogJHtyLnR5cGUuaW5kaWNlc30pIC0+ICR7bi50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtuLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBhPTA7YTx0OysrYSlvLnB1c2gobi5pbmRpY2VzU2V0KFwiYVwiLGVbYV0sYGlbJHthfV1gKSk7cmV0dXJuIG8ucHVzaChcInJldHVybiBhO31cIiksby5qb2luKGBcbmApfSxtZz0oZSx0KT0+e2xldCBuLHIsbyxhLHMsZCxsPXQuZm9ybWF0PT09XCJOSFdDXCIscD10LmJsb2Nrc2l6ZSxmPXQubW9kZT09PVwiRENSXCI7bD8oW24scixvLGFdPWUuZGltcyxzPWY/W24scixvLHAscCxhL3AqKjJdOltuLHIsbyxhL3AqKjIscCxwXSxkPWY/WzAsMSwzLDIsNCw1XTpbMCwxLDQsMiw1LDNdKTooW24scixvLGFdPVtlLmRpbXNbMF0sZS5kaW1zWzJdLGUuZGltc1szXSxlLmRpbXNbMV1dLHM9Zj9bbixwLHAsYS9wKioyLHIsb106W24sYS9wKioyLHAscCxyLG9dLGQ9Zj9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10pO2xldCBoPWUucmVzaGFwZShzKSx5PWguZGltcy5sZW5ndGgsXz1lLmRhdGFUeXBlLGI9UChcImFcIixfLHkpLHc9TihcIm91dHB1dFwiLF8seSksUz0kPT5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYix3KX1cblxuICAke3BnKGQseSxiLHcpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7dy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixiLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJEZXB0aFRvU3BhY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtlLmRpbXN9OyR7dC5ibG9ja3NpemV9OyR7dC5tb2RlfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTokPT57bGV0IHY9bD9bbixyKnAsbypwLGEvcCoqMl06W24sYS9wKioyLHIqcCxvKnBdLFQ9RS5zaXplKHYpLEM9aC5kaW1zLEE9RS5zb3J0QmFzZWRPblBlcm0oQyxkKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dixkYXRhVHlwZTokWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoVC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpUfSwuLi5IKEMsQSldfX0sZ2V0U2hhZGVyU291cmNlOlN9fSxRZD0oZSx0KT0+e2NnKGUuaW5wdXRzKSxlLmNvbXB1dGUobWcoZS5pbnB1dHNbMF0sdCkpfSxZZD1lPT5yZSh7YmxvY2tzaXplOmUuYmxvY2tzaXplLG1vZGU6ZS5tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIHZvLHRuLEpkLGZnLGhnLCRvLHhvLGVsLGdnLHRsLHJsLG5sPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO3ZvPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsdG49XCIoXCIrdm8rXCIpK1wiLEpkPVwiXlwiK3RuK1wiJFwiLGZnPVwiKFwiK3RuK1wiLCkqXCIrdG4saGc9XCJeXCIrZmcrXCIkXCIsJG89Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxuKXtsZXQgcj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7cj09PXZvaWQgMD9yPVtuXTpyLnB1c2gobiksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQscil9fSx4bz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMuZXF1YXRpb249bjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbcixvXT1uLmluY2x1ZGVzKFwiLT5cIik/bi5zcGxpdChcIi0+XCIsMik6W24sXCJcIl07aWYoIXIubWF0Y2goUmVnRXhwKGhnKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihyLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGwpPT57bGV0IHA9dFtsXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKEpkKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgZj10aGlzLnByb2Nlc3NUZXJtKGQsITAscCxsKTt0aGlzLmxocy5wdXNoKGYpfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxsXSk9PmwuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKHRuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAodm8sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGw9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGwuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LG4scil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1uJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gocil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOm4saW5wdXRJbmRpY2VzOltyXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxuLHIsbz0tMSl7bGV0IGE9ci5sZW5ndGgscz0hMSxkPVtdLGw9MDtpZighdC5tYXRjaChSZWdFeHAoSmQpKSYmIW4mJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAodm8sXCJnXCIpKSxmPW5ldyAkbyhvKTtyZXR1cm4gcD8uZm9yRWFjaCgoaCx5KT0+e2lmKGg9PT1cIi4uLlwiKXtpZihzKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7cz0hMDtsZXQgXz1hLXAubGVuZ3RoKzE7aWYoXzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1yLnNsaWNlKGwsbCtfKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYobil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgYj0wO2I8ZC5sZW5ndGg7YisrKXtsZXQgdz1TdHJpbmcuZnJvbUNoYXJDb2RlKDQ4K2IpO2YuYWRkU3ltYm9sKHcseStiKSx0aGlzLmFkZFN5bWJvbCh3LHJbbCsrXSxvKX19ZWxzZSBmLmFkZFN5bWJvbChoLHkrKHRoaXMuaGFzRWxsaXBzaXM/dGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoLTE6MCkpLHRoaXMuYWRkU3ltYm9sKGgscltsKytdLG8pfSksZn19LGVsPWU9PmUrXCJfbWF4XCIsZ2c9KGUsdCxuLHIpPT57bGV0IGE9ZS5tYXAoZj0+Zi5sZW5ndGgpLm1hcCgoZixoKT0+UChgaW5wdXQke2h9YCx0LGYpKSxzPUUuc2l6ZShyKSxkPU4oXCJvdXRwdXRcIix0LHIubGVuZ3RoKSxsPVsuLi5uLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcihmPT4hbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhmKSkscD1mPT57bGV0IGg9W10seT1cInZhciBwcm9kID0gMS4wO1wiLF89XCJ2YXIgc3VtID0gMC4wO1wiLGI9XCJzdW0gKz0gcHJvZDtcIix3PVtdLFM9W10sJD1bXSx2PVtdLFQ9bi5zeW1ib2xUb0luZm8uc2l6ZT09PW4ucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO24uc3ltYm9sVG9JbmZvLmZvckVhY2goKEEsayk9PntpZihuLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKGspKXtsZXQgTz1uLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KGspPy5bMF07TyE9PXZvaWQgMCYmbi5saHMuZm9yRWFjaCgoTSxWKT0+e2lmKEEuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKFYpKXtsZXQgRj1NLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk7aWYoRj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtGLmZvckVhY2goaj0+e2gucHVzaChgJHthW1ZdLmluZGljZXNTZXQoYGlucHV0JHtWfUluZGljZXNgLGosZC5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLE8pKX1gKX0pfX0pfWVsc2Ugbi5saHMuZm9yRWFjaCgoTyxNKT0+e2lmKEEuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKE0pKXtsZXQgVj1PLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk7aWYoVj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtWLmZvckVhY2goRj0+e3cucHVzaChgJHthW01dLmluZGljZXNTZXQoYGlucHV0JHtNfUluZGljZXNgLEYsYCR7a31gKX1gKX0pLHYucHVzaChgcHJvZCAqPSAke2FbTV0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7TX1JbmRpY2VzYCl9O2ApfX0pLFMucHVzaChgZm9yKHZhciAke2t9OiB1MzIgPSAwOyAke2t9IDwgdW5pZm9ybXMuJHtlbChrKX07ICR7a30rKykge2ApLCQucHVzaChcIn1cIil9KTtsZXQgQz1UP1suLi5oLGBsZXQgc3VtID0gJHthLm1hcCgoQSxrKT0+QS5nZXRCeUluZGljZXMoYGlucHV0JHtrfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLmgsXywuLi5TLC4uLncseSwuLi52LGIsLi4uJF07cmV0dXJuYFxuICAgICAgICAgICAgJHtmLnJlZ2lzdGVyVW5pZm9ybXMobC5tYXAoQT0+KHtuYW1lOmAke2VsKEEpfWAsdHlwZTpcInUzMlwifSkpKS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5hLGQpfVxuXG4gICAgICAgICAgICAke2YubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke2YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICR7YS5tYXAoKEEsayk9PmB2YXIgaW5wdXQke2t9SW5kaWNlczogJHthW2tdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXG5gKX1cbiAgICAgICAgICAgICR7Qy5qb2luKGBcbmApfTtcbiAgICAgICAgICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6bi5lcXVhdGlvbixpbnB1dERlcGVuZGVuY2llczplLm1hcCgoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT57bGV0IGY9bC5maWx0ZXIoeT0+bi5zeW1ib2xUb0luZm8uaGFzKHkpKS5tYXAoeT0+KHt0eXBlOjEyLGRhdGE6bi5zeW1ib2xUb0luZm8uZ2V0KHkpPy5kaW1WYWx1ZXx8MH0pKTtmLnB1c2goe3R5cGU6MTIsZGF0YTpzfSk7bGV0IGg9ZS5tYXAoKHksXyk9PlsuLi5IKHkpXSkucmVkdWNlKCh5LF8pPT55LmNvbmNhdChfKSxmKTtyZXR1cm4gaC5wdXNoKC4uLkgocikpLHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOnR9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9fSxnZXRTaGFkZXJTb3VyY2U6cH19LHRsPShlLHQpPT57bGV0IG49bmV3IHhvKGUuaW5wdXRzLHQuZXF1YXRpb24pLHI9bi5vdXRwdXREaW1zLG89ZS5pbnB1dHMubWFwKChhLHMpPT5hLmRpbXMpO2UuY29tcHV0ZShnZyhvLGUuaW5wdXRzWzBdLmRhdGFUeXBlLG4scikpfSxybD1lPT57bGV0IHQ9ZS5lcXVhdGlvbi5yZXBsYWNlKC9cXHMrL2csXCJcIik7cmV0dXJuIHJlKHtlcXVhdGlvbjp0fSl9fSk7dmFyIHlnLG9sLGJnLF9nLGlsLGFsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTt5Zz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC5cIik7bGV0IHQ9ZVswXS5kaW1zLG49QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLHI9bi5sZW5ndGg8dC5sZW5ndGg/MDpuLmxlbmd0aC10Lmxlbmd0aCxvPXQubGVuZ3RoPG4ubGVuZ3RoPzA6dC5sZW5ndGgtbi5sZW5ndGg7Zm9yKDtyPG4ubGVuZ3RoJiZvPHQubGVuZ3RoOysrciwrK28paWYobltyXSE9PXRbb10mJm5bcl0hPT0xJiZ0W29dIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dFwiKX0sb2w9KGUsdCk9PntsZXQgbj1lLmxlbmd0aC10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288bjsrK28pci5wdXNoKGVbb10pO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7KytvKXIucHVzaCh0W29dPT09MT9lW28rbl06dFtvXSk7cmV0dXJuIHJ9LGJnPShlLHQpPT5lLmxlbmd0aD50Lmxlbmd0aD9vbChlLHQpOm9sKHQsZSksX2c9ZT0+e2xldCB0PWVbMF0uZGltcyxuPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxyPWJnKHQsbiksbz1lWzBdLmRhdGFUeXBlLGE9bz09PTl8fEUuc2l6ZSh0KT09PTEscz1vPT09OXx8dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MD80OjEsZD1hfHxyLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxsPU1hdGguY2VpbChFLnNpemUocikvZCkscD1oPT57bGV0IHk9UChcImlucHV0XCIsbyx0Lmxlbmd0aCxzKSxfPU4oXCJvdXRwdXRcIixvLHIubGVuZ3RoLGQpLGI7aWYobz09PTkpe2xldCB3PShTLCQsdj1cIlwiKT0+YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHskfSA9ICR7Xy5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7JH11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQkeyR9ID0gJHt5LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHskfWAsXyl9O1xuICAgICAgICAgIGxldCBpbmRleCR7JH0gPSBvZmZzZXQkeyR9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7JH0gPSBvZmZzZXQkeyR9ICUgNHU7XG4gICAgICAgICAgJHtTfVskeyR9XSA9ICR7dn0oJHt5LmdldEJ5T2Zmc2V0KGBpbmRleCR7JH1gKX1bY29tcG9uZW50JHskfV0pO1xuICAgICAgICBgO2I9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7ZH07XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3coXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHt3KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dyhcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAke3coXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cbiAgICAgIH1gfWVsc2UgYj1gXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7ZH1gKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7eS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixfKX07XG4gICAgICAgIGxldCBkYXRhID0gJHtfLnR5cGUudmFsdWV9KCR7eS5nZXRCeU9mZnNldChgaW5wdXRPZmZzZXQgLyAke3N9YCl9KTtcbiAgICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cbiAgICAgIH1gO3JldHVybmBcbiAgICAke2gucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHksXyl9XG4gICAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgJHtifWB9LGY9W3t0eXBlOjEyLGRhdGE6bH0sLi4uSCh0LHIpXTtyZXR1cm57bmFtZTpcIkV4cGFuZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3IubGVuZ3RofTske3N9JHtkfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnAsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KX19LGlsPWU9Pnt5ZyhlLmlucHV0cyksZS5jb21wdXRlKF9nKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciB3ZyxzbCx1bD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7anIoKTt3Zz1lPT57bGV0IHQ9ZVswXS5kYXRhVHlwZSxuPUUuc2l6ZShlWzBdLmRpbXMpLHI9RS5zaXplKGVbMV0uZGltcyksbz1yJTQ9PT0wLGE9cz0+e2xldCBkPVAoXCJ4XCIsdCxbMV0sNCksbD1QKFwiYmlhc1wiLHQsWzFdLDQpLHA9TihcInlcIix0LFsxXSw0KSxmPVt7bmFtZTpcIm91dHB1dF92ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX3NpemVcIix0eXBlOlwidTMyXCJ9XSxoPV89PmBcbiAgICAgIGxldCBiaWFzJHtffV9vZmZzZXQ6IHUzMiA9IChnbG9iYWxfaWR4ICogNCArICR7X30pICUgdW5pZm9ybXMuYmlhc19zaXplO1xuICAgICAgbGV0IGJpYXMke199ID0gJHtsLmdldEJ5T2Zmc2V0KGBiaWFzJHtffV9vZmZzZXQgLyA0YCl9W2JpYXMke199X29mZnNldCAlIDRdO2AseT1vP2BcbiAgICAgIGxldCBiaWFzID0gJHtsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KVwiKX07YDpgJHtoKDApfSR7aCgxKX0ke2goMil9JHtoKDMpfVxuICAgICAgbGV0IGJpYXMgPSAke2QudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7cmV0dXJuYCR7cy5yZWdpc3RlclVuaWZvcm1zKGYpLmRlY2xhcmVWYXJpYWJsZXMoZCxsLHApfVxuXG4gICAgJHttbyh6ZSh0KSl9XG5cbiAgICAke3MubWFpblN0YXJ0KEV0KX1cbiAgICAgICR7cy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3ZlY19zaXplXCIpfVxuXG4gICAgICBsZXQgeCA9ICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHt5fVxuICAgICAgbGV0IHhfaW4gPSB4ICsgYmlhcztcbiAgICAgICR7cC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixmbyhcInhfaW5cIikpfVxuICAgIH1gfTtyZXR1cm57bmFtZTpcIkZhc3RHZWx1V2l0aEJpYXNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmEsZ2V0UnVuRGF0YTpzPT4oe291dHB1dHM6W3tkaW1zOnNbMF0uZGltcyxkYXRhVHlwZTpzWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChuLzQpfSx7dHlwZToxMixkYXRhOnJ9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuL0V0LzQpfX0pfX0sc2w9ZT0+e2UuaW5wdXRzLmxlbmd0aDwyfHxFLnNpemUoZS5pbnB1dHNbMV0uZGltcyk9PT0wP25kKGUpOmUuY29tcHV0ZSh3ZyhlLmlucHV0cykpfX0pO3ZhciB2ZywkZyxkbCxsbCxjbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTt2Zz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpfSwkZz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4ubGVuZ3RoLGE9RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSxzPW4uc2xpY2UoMCk7cy5zcGxpY2UoYSwxLC4uLnIpO2xldCBkPW5bYV0sbD1lWzBdLmRhdGFUeXBlPT09OT80OjEscD1NYXRoLmNlaWwoRS5zaXplKHMpL2wpLGY9W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6NixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6YX0sLi4uSChlWzBdLmRpbXMsZVsxXS5kaW1zLHMpXSxoPXk9PntsZXQgXz1QKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxsKSxiPVAoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLHc9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscy5sZW5ndGgsbCksUz12PT57bGV0IFQ9ci5sZW5ndGgsQz1gdmFyIGluZGljZXNJbmRpY2VzJHt2fSAgPSAke2IudHlwZS5pbmRpY2VzfSgwKTtgO2ZvcihsZXQgQT0wO0E8VDtBKyspQys9YCR7VD4xP2BpbmRpY2VzSW5kaWNlcyR7dn1bJHtBfV1gOmBpbmRpY2VzSW5kaWNlcyR7dn1gfSA9ICR7cy5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7dn1bdW5pZm9ybXMuYXhpcyArICR7QX1dYDpgb3V0cHV0SW5kaWNlcyR7dn1gfTtgO0MrPWBcbiAgICAgICAgICB2YXIgaWR4JHt2fSA9ICR7Yi5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHt2fWApfTtcbiAgICAgICAgICBpZiAoaWR4JHt2fSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7dn0gPSBpZHgke3Z9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3Z9IDogJHtfLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7Zm9yKGxldCBBPTAsaz0wO0E8bztBKyspQT09PWE/KEMrPWAke28+MT9gZGF0YUluZGljZXMke3Z9WyR7QX1dYDpgZGF0YUluZGljZXMke3Z9YH0gPSB1MzIoaWR4JHt2fSk7YCxrKz1UKTooQys9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9ICR7cy5sZW5ndGg+MT9gb3V0cHV0SW5kaWNlcyR7dn1bJHtrfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2AsaysrKTtyZXR1cm4gQ30sJDtpZihlWzBdLmRhdGFUeXBlPT09OSl7bGV0IHY9KFQsQyxBPVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke0N9ID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHtDfXVgKX07XG4gICAgICAgICAgJHtTKEMpfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHtDfSA9ICR7Xy5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHtDfWApfTtcbiAgICAgICAgICBsZXQgaW5kZXgke0N9ID0gb2Zmc2V0JHtDfSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke0N9ID0gb2Zmc2V0JHtDfSAlIDR1O1xuICAgICAgICAgICR7VH1bJHtDfV0gPSAke0F9KCR7Xy5nZXRCeU9mZnNldChgaW5kZXgke0N9YCl9W2NvbXBvbmVudCR7Q31dKTtcbiAgICAgICAgYDskPWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2x9O1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7dihcInZhbHVlXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwxLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHt3LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gICAgICBgfWVsc2UgJD1gXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7UyhcIlwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke18uZ2V0QnlJbmRpY2VzKFwiZGF0YUluZGljZXNcIil9O1xuICAgICAgJHt3LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgYDtyZXR1cm5gXG4gICAgICAke3kucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNEaW1MaW1pdFwiLFwiaTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKF8sYix3KX1cbiAgICAgICR7eS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOmh9fSxkbD1lPT5yZSh7YXhpczplLmF4aXN9KSxsbD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzO3ZnKG4pLGUuY29tcHV0ZSgkZyhlLmlucHV0cyx0KSl9fSk7dmFyIHhnLHBsLG1sLGZsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTt4Zz0oZSx0LG4scixvLGEscyxkLGwpPT57bGV0IHA9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH1dLGY9W2FdO3AucHVzaCguLi5IKHQuZGltcyxmKSk7bGV0IGg9eT0+e2xldCBfPVAoXCJpbmRpY2VzX2RhdGFcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLGI9TihcImlucHV0X3NsaWNlX29mZnNldHNfZGF0YVwiLDEyLDEsMSksdz1bXyxiXSxTPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJhdGNoX2RpbXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm4ubGVuZ3RofSx7bmFtZTpcIm51bV9zbGljZXNfcGVyX2JhdGNoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2JhdGNoX3N0cmlkZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1fc2xpY2VfZGltc1wiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMoUykuZGVjbGFyZVZhcmlhYmxlcyguLi53KX1cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJhdGNoX2lkeCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5udW1fc2xpY2VzX3Blcl9iYXRjaDtcbiAgICBsZXQgYmFzZV9vZmZzZXQgPSBiYXRjaF9pZHggKiB1bmlmb3Jtcy5pbnB1dF9iYXRjaF9zdHJpZGU7XG5cbiAgICBsZXQgc2xpY2VfaW5kaWNlc19iYXNlX29mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5udW1fc2xpY2VfZGltcztcbiAgICB2YXIgcmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBkaW1faWR4ID0gMHU7IGRpbV9pZHggPCB1bmlmb3Jtcy5udW1fc2xpY2VfZGltczsgZGltX2lkeCArKykge1xuICAgICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNfZGF0YVtkaW1faWR4ICsgc2xpY2VfaW5kaWNlc19iYXNlX29mZnNldF0ueCk7XG4gICAgICBsZXQgaW5wdXRfZGltX2lkeCA9IHVuaWZvcm1zLmJhdGNoX2RpbXMgKyBkaW1faWR4O1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAke28ubGVuZ3RoPT09MT9cImluZGV4ICs9IGkzMih1bmlmb3Jtcy5pbnB1dF9kaW1zKTtcIjpcImluZGV4ICs9IGkzMih1bmlmb3Jtcy5pbnB1dF9kaW1zW2lucHV0X2RpbV9pZHhdKTtcIn1cbiAgICAgIH1cbiAgICAgICR7bi5sZW5ndGg9PT0xP1wicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhKTtcIjpcInJlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVtkaW1faWR4XSk7XCJ9XG4gICAgfVxuXG4gICAgaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhW2dsb2JhbF9pZHhdID0gIGJhc2Vfb2Zmc2V0ICsgdTMyKHJlbGF0aXZlX3NsaWNlX29mZnNldCk7XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiY29tcHV0ZVNsaWNlT2Zmc2V0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke28ubGVuZ3RofV8ke24ubGVuZ3RofWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpmLGRhdGFUeXBlOmUuaW5wdXRzWzFdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOmh9LHtpbnB1dHM6W3RdLG91dHB1dHM6Wy0xXX0pWzBdfSxwbD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzLHI9blswXS5kaW1zLG89blswXS5kYXRhVHlwZSxhPW5bMV0uZGltcyxzPWFbYS5sZW5ndGgtMV0sZD1FLnNpemVUb0RpbWVuc2lvbihhLGEubGVuZ3RoLTEpLGw9RS5zaXplRnJvbURpbWVuc2lvbihyLHQuYmF0Y2hEaW1zK3MpLHA9RS5zaXplVG9EaW1lbnNpb24ocix0LmJhdGNoRGltcyksZj1FLnNpemVGcm9tRGltZW5zaW9uKHIsdC5iYXRjaERpbXMpLGg9ZC9wLHk9bmV3IEFycmF5KHMpLF89bDtmb3IobGV0IEM9MDtDPHM7KytDKXlbcy0xLUNdPV8sXyo9clt0LmJhdGNoRGltcytzLTEtQ107bGV0IGI9eGcoZSxuWzFdLHksdC5iYXRjaERpbXMscixkLGgsZixzKSx3PXQuYmF0Y2hEaW1zK3M7aWYodz5yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbmRpY2VzIG11c3Qgbm90IGJlIGxhcmdlciB0aGFuIHJhbmsgb2YgaW5wdXQgdGVuc29yXCIpO2xldCBTPWEuc2xpY2UoMCwtMSkuY29uY2F0KHIuc2xpY2UodykpLCQ9RS5zaXplKFMpLHY9W3t0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpsfSwuLi5IKG5bMF0uZGltcyxiLmRpbXMsUyldLFQ9Qz0+e2xldCBBPVAoXCJkYXRhXCIsblswXS5kYXRhVHlwZSxuWzBdLmRpbXMubGVuZ3RoKSxrPVAoXCJzbGljZV9vZmZzZXRzXCIsMTIsYi5kaW1zLmxlbmd0aCksTz1OKFwib3V0cHV0XCIsblswXS5kYXRhVHlwZSxTLmxlbmd0aCk7cmV0dXJuYFxuICAgICAgICAgICR7Qy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNsaWNlX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKEEsayxPKX1cbiAgICAgICAgICAgICR7Qy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7Qy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgbGV0IHNsaWNlX29mZnNldCA9IHNsaWNlX29mZnNldHNbZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGRhdGFbdTMyKHNsaWNlX29mZnNldCkgKyBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJHYXRoZXJORFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpTLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCgkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnZ9KSxnZXRTaGFkZXJTb3VyY2U6VH0se2lucHV0czpbblswXSxiXX0pfSxtbD1lPT4oe2JhdGNoRGltczplLmJhdGNoX2RpbXMsY2FjaGVLZXk6XCJcIn0pfSk7dmFyIFNnLFRnLGhsLGdsLHlsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO1NnPShlLHQpPT57aWYoZS5sZW5ndGg8M3x8ZS5sZW5ndGg+NCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLlwiKTtsZXQgbj1FLm5vcm1hbGl6ZUF4aXModC5xdWFudGl6ZUF4aXMsZVswXS5kaW1zLmxlbmd0aCkscj10LmJsb2NrU2l6ZSxvPWVbMF0sYT1lWzJdLHM9ZS5sZW5ndGg9PT00P2VbM106dm9pZCAwO2lmKGEuZGltcy5sZW5ndGghPT1vLmRpbXMubGVuZ3RofHwhby5kaW1zLm1hcCgoZCxsKT0+bD09PW4/TWF0aC5jZWlsKGQvcik9PT1hLmRpbXNbbF06ZD09PWEuZGltc1tsXSkucmVkdWNlKChkLGwpPT5kJiZsLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBnYXRoZXJBeGlzLlwiKTtpZihzKXtpZihzLmRhdGFUeXBlIT09by5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgdGhlIGlucHV0IHRlbnNvci5cIik7aWYocy5kaW1zLmxlbmd0aCE9PWEuZGltcy5sZW5ndGh8fCFzLmRpbXMubWFwKChkLGwpPT5kPT09YS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuXCIpfX0sVGc9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzFdLmRpbXMsbz1uLmxlbmd0aCxhPUUubm9ybWFsaXplQXhpcyh0LmdhdGhlckF4aXMsbykscz1FLm5vcm1hbGl6ZUF4aXModC5xdWFudGl6ZUF4aXMsbyksZD1uLnNsaWNlKDApO2Quc3BsaWNlKGEsMSwuLi5yKTtsZXQgbD1FLnNpemUoZCkscD1lWzJdLmRhdGFUeXBlLGg9ZVswXS5kYXRhVHlwZT09PTIyLHk9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6dC5ibG9ja1NpemV9LC4uLkgoLi4uZS5tYXAoKGIsdyk9PmIuZGltcyksZCldLF89Yj0+e2xldCB3PVAoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxTPVAoXCJpbnB1dEluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLCQ9UChcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksdj1lLmxlbmd0aD4zP1AoXCJ6ZXJvUG9pbnRcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMCxUPU4oXCJvdXRwdXRcIixwLGQubGVuZ3RoKSxDPVt3LFMsJF07diYmQy5wdXNoKHYpO2xldCBBPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInF1YW50aXplX2F4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZ2F0aGVyX2F4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICAgJHtiLnJlZ2lzdGVyVW5pZm9ybXMoQSkuZGVjbGFyZVZhcmlhYmxlcyguLi5DLFQpfVxuICAgICAgICAke2IubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7VC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGluZGljZXNfaW5kaWNlcyA9ICR7Uy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAke3IubGVuZ3RoPjE/YFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke1QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIGlcIil9O1xuICAgICAgICAgICAgJHtTLmluZGljZXNTZXQoXCJpbmRpY2VzX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgICB9YDpgaW5kaWNlc19pbmRpY2VzID0gJHtULmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIil9O2B9O1xuICAgICAgICB2YXIgZGF0YV9pbmRpY2VzID0gJHt3LnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5nYXRoZXJfYXhpczsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgJHt3LmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHtTLmdldEJ5SW5kaWNlcyhcImluZGljZXNfaW5kaWNlc1wiKX07XG4gICAgICAgIGlmIChpbmRleF9mcm9tX2luZGljZXMgPCAwKSB7XG4gICAgICAgICAgaW5kZXhfZnJvbV9pbmRpY2VzICs9ICR7blthXX07XG4gICAgICAgIH1cbiAgICAgICAgJHt3LmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIsXCJ1MzIoaW5kZXhfZnJvbV9pbmRpY2VzKVwiKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke2QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLGBpICsgJHtyLmxlbmd0aH0gLSAxYCl9O1xuICAgICAgICAgICR7dy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHt3LmluZGljZXNUb09mZnNldChcImRhdGFfaW5kaWNlc1wiKX07XG4gICAgICAgIGxldCBkYXRhX2luZGV4ID0gZGF0YV9vZmZzZXQgJSA4O1xuICAgICAgICAvLyBDb252ZXJ0IDQtYml0IHBhY2tlZCBkYXRhIHRvIDgtYml0IHBhY2tlZCBkYXRhLlxuICAgICAgICBsZXQgcGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPSAke3cuZ2V0QnlPZmZzZXQoXCJkYXRhX29mZnNldCAvIDhcIil9O1xuICAgICAgICBsZXQgcGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEgPSAocGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPj4gKDQgKiAoZGF0YV9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGFfdmVjID0gJHtoP1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgJHskLmluZGljZXNTZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIsXCJxdWFudGl6ZV9heGlzX2luZGV4XCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHskLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAke3Y/YFxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRpY2VzID0gc2NhbGVfaW5kaWNlcztcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHt2LmluZGljZXNUb09mZnNldChcInplcm9fcG9pbnRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gemVyb19wb2ludF9vZmZzZXQgJSA4O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzRiaXRfemVyb19wb2ludHMgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDhcIil9O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzhiaXRfemVyb19wb2ludHMgPSAocGFja2VkXzRiaXRfemVyb19wb2ludHMgPj4gKDQgKiAoemVyb19wb2ludF9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke2g/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF96ZXJvX3BvaW50cykpO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgOlwidmFyIHplcm9fcG9pbnQgPSAwXCJ9O1xuICAgICAgICBsZXQgZGVxdWFudGl6ZWRfZGF0YSA9ICR7emUocCl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtULnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGVxdWFudGl6ZWRfZGF0YVwiKX07XG4gICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2UuZmlsdGVyKChiLHcpPT53IT09MSkubWFwKGI9PmIuZGltcy5qb2luKFwiX1wiKSkuam9pbihcIjtcIil9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheS5mcm9tKHtsZW5ndGg6ZS5sZW5ndGh9LChiLHcpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTpwfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3Jtczp5fSksZ2V0U2hhZGVyU291cmNlOl99fSxobD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzO1NnKG4sdCksZS5jb21wdXRlKFRnKGUuaW5wdXRzLHQpKX0sZ2w9ZT0+cmUoe2Jsb2NrU2l6ZTplLmJsb2NrU2l6ZSxnYXRoZXJBeGlzOmUuZ2F0aGVyQXhpcyxxdWFudGl6ZUF4aXM6ZS5xdWFudGl6ZUF4aXN9KX0pO3ZhciBDZyxJZyxibCxfbCx3bD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtDZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxJZz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMF0uZGF0YVR5cGUsbz1uLmxlbmd0aCxhPWVbMV0uZGltcyxzPWVbMV0uZGF0YVR5cGUsZD1FLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGw9bltkXSxwPWEuc2xpY2UoMCksZj1FLnNpemUocCksaD1QKFwiaW5wdXRcIixyLG8pLHk9UChcImluZGljZXNJbnB1dFwiLHMsYS5sZW5ndGgpLF89TihcIm91dHB1dFwiLHIscC5sZW5ndGgpLGI9W3t0eXBlOjEyLGRhdGE6Zn0se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6ZH1dO3JldHVybiBiLnB1c2goLi4uSChuLGEscCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChmLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmJ9KSxnZXRTaGFkZXJTb3VyY2U6JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLHksXyl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHt5LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtoLnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke2guaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHtoLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxibD1lPT5yZSh7YXhpczplLmF4aXN9KSxfbD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzO0NnKG4pLGUuY29tcHV0ZShJZyhlLmlucHV0cyx0KSl9fSk7dmFyIEFnLGtnLHZsLCRsLHhsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtBZz1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sa2c9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMuc2xpY2UoKSxyPWVbMV0uZGltcy5zbGljZSgpLFtvLGEsc109V3IuZ2V0U2hhcGVPZkdlbW1SZXN1bHQobix0LnRyYW5zQSxyLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtvLGFdO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPTE2LHA9TWF0aC5jZWlsKGEvbCksZj1NYXRoLmNlaWwoby9sKSxoPSEwLHk9RS5zaXplKGQpLF89W3t0eXBlOjEyLGRhdGE6aD9wOnl9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0sYj1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKF8ucHVzaCguLi5IKGVbMl0uZGltcykpLGIucHVzaChcInJhbmtcIikpLF8ucHVzaCguLi5IKGQpKTtsZXQgdz0kPT57bGV0IHY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYodj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IFQ9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLEM9UChcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksQT1QKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxrPUMudHlwZS52YWx1ZSxPPW51bGwsTT1bQyxBXTtlLmxlbmd0aD09PTMmJihPPVAoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxNLnB1c2goTykpO2xldCBWPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtNLnB1c2goVik7bGV0IEY9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoRikuZGVjbGFyZVZhcmlhYmxlcyguLi5NKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7a30oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7dn1cbiAgICB9XG5cbiAgICAke1R9XG4gICAgJHtPIT1udWxsP2BsZXQgY09mZnNldCA9ICR7Ty5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixWKX07IHZhbHVlICs9ICR7a30odW5pZm9ybXMuYmV0YSkgKiAke08uZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCJ9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gIH1gfSxTPSQ9PntsZXQgdj1QKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxUPVAoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLEM9bnVsbCxBPVt2LFRdO2UubGVuZ3RoPT09MyYmKEM9UChcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEEucHVzaChDKSk7bGV0IGs9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZC5sZW5ndGgpO0EucHVzaChrKTtsZXQgTz1be25hbWU6XCJudW1fdGlsZV9uXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9XSxNPVwiXCIsVj1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj8oVj1gXG4gICAgICB2YXIgY29sID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLk0gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7VC50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsTT1cInZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtcIik6dC50cmFuc0EmJiF0LnRyYW5zQj8oVj1gXG4gICAgICB2YXIgY29sID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLk0gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7VC50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsTT1cInZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtcIik6IXQudHJhbnNBJiZ0LnRyYW5zQj8oVj1gXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7VC50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsTT1cInZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtcIik6IXQudHJhbnNBJiYhdC50cmFuc0ImJihWPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtULnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxNPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTtsZXQgRj10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCI7cmV0dXJuYFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhPKS5kZWNsYXJlVmFyaWFibGVzKC4uLkEpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlX2E6IGFycmF5PGFycmF5PCR7di50eXBlLnN0b3JhZ2V9LCAke2x9PiwgJHtsfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYjogYXJyYXk8YXJyYXk8JHtULnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgJHskLm1haW5TdGFydChbbCxsLDFdKX1cbiAgICBsZXQgdGlsZV9jb2xfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke2x9O1xuICAgIGxldCB0aWxlX3Jvd19zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IG51bV90aWxlcyA9ICh1bmlmb3Jtcy5LIC0gMSkgLyAke2x9ICsgMTtcbiAgICB2YXIga19zdGFydCA9IDB1O1xuICAgIHZhciB2YWx1ZSA9ICR7ay50eXBlLnZhbHVlfSgwKTtcbiAgICBmb3IgKHZhciB0OiB1MzIgPSAwdTsgdCA8IG51bV90aWxlczsgdCsrKSB7XG4gICAgICAke1Z9XG4gICAgICBrX3N0YXJ0ID0ga19zdGFydCArICR7bH07XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgJHtsfTsgaysrKSB7XG4gICAgICAgICR7TX1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICAke0Z9XG4gICAgbGV0IG0gPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgbGV0IG4gPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgJHtDIT1udWxsP2BsZXQgY09mZnNldCA9ICR7Qy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixrKX07IHZhbHVlICs9ICR7ay50eXBlLnZhbHVlfSh1bmlmb3Jtcy5iZXRhKSAqICR7Qy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIn1cbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XG4gICAgfVxuICB9YH07cmV0dXJuIGg/e25hbWU6XCJHZW1tU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOmJ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpwKmZ9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOlN9OntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczpifSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp3fX0sdmw9ZT0+e2xldCB0PWUudHJhbnNBLG49ZS50cmFuc0Iscj1lLmFscGhhLG89ZS5iZXRhO3JldHVybnt0cmFuc0E6dCx0cmFuc0I6bixhbHBoYTpyLGJldGE6byxjYWNoZUtleTpgJHtlLnRyYW5zQX07JHtlLnRyYW5zQn07JHtlLmFscGhhPT09MX1gfX0sJGw9KGUsdCk9PntBZyhlLmlucHV0cyksZS5jb21wdXRlKGtnKGUuaW5wdXRzLHQpKX19KTt2YXIgcHQsJHQsTnQsVnQsRWcsUGcsemcsT2csRGcsQmcsTWcsUmcsU2wsVGwsQ2w9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7W3B0LCR0LE50LFZ0XT1bMCwxLDIsM10sRWc9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIm9ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImlucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zLmxlbmd0aC0yIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMV0pdGhyb3cgbmV3IEVycm9yKGBsYXN0IGRpbWVuc2lvbiBvZiBncmlkIG11c3QgYmUgZXF1YWwgdG8gJHtlWzBdLmRpbXMubGVuZ3RoLTJ9YCk7aWYoZVswXS5kaW1zWzBdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImdyaWQgYmF0Y2ggc2l6ZSBtdXN0IG1hdGNoIGlucHV0IGJhdGNoIHNpemVcIil9LFBnPWBcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgbGV0IGN1YmljX2FscGhhID0gLTAuNzVmO1xuICAgIGxldCB4X2FicyA9IGFicyh4KTtcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XG4gICAgY29lZmZzWzBdID0gKCgoY3ViaWNfYWxwaGEgKiAoeF9hYnMgKyAxKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSArIDggKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcbiAgICBjb2VmZnNbM10gPSAoKChjdWJpY19hbHBoYSAqICgyIC0geF9hYnMpIC0gNSAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpICsgOCAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5gLHpnPWU9PmBcbiAgZm4gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwOiBtYXQ0eDQ8JHtlfT4sIHg6IGYzMiwgeTogZjMyKSAtPiAke2V9IHtcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xuICAgIHZhciBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcbiAgICB9XG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcbiAgICBsZXQgcGl4ZWwgPSAke2V9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xuICAgIHJldHVybiBwaXhlbDtcbiAgfVxuYCxPZz1lPT5gXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XG4gICAgJHtlLmFsaWduQ29ybmVycz09PTA/YFxuICAgIC8vIGFsaWduQ29ybmVyczogZmFsc2UgPT4gWy0xLCAxXSB0byBbLTAuNSwgbGVuZ3RoIC0gMC41XVxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xuICAgIGA6YFxuICAgIC8vIGFsaWduQ29ybmVyczogdHJ1ZSA9PiBbLTEsIDFdIHRvIFswLCBsZW5ndGggLSAxXVxuICAgIHJldHVybiAobiArIDEuMCkgLyAyLjAgKiAoZjMyKGxlbmd0aCAtIDEpKTtcbiAgICBgfVxuICB9XG5gLERnPWU9PmBcbiAgJHtlLnBhZGRpbmdNb2RlPT09XCJyZWZsZWN0aW9uXCI/YFxuICAgICAgZm4gZ3NfcmVmbGVjdCh4OiBpMzIsIHhfbWluOiBmMzIsIHhfbWF4OiBmMzIpIC0+IHUzMiB7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xuICAgICAgICBsZXQgcmFuZ2UgPSB4X21heCAtIHhfbWluO1xuICAgICAgICBpZiAoZnggPCB4X21pbikge1xuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XG4gICAgICB9YDpcIlwifVxuYCxCZz0oZSx0LG4pPT5gXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke3R9IHtcbiAgICAgdmFyIHBpeGVsID0gJHt0fSgwKTtcbiAgICAgdmFyIGluZGljZXMgPSB2ZWM0PHUzMj4oMCk7XG4gICAgIGluZGljZXNbJHtwdH1dID0gYmF0Y2g7XG4gICAgIGluZGljZXNbJHskdH1dID0gY2hhbm5lbDtgKygoKT0+e3N3aXRjaChuLnBhZGRpbmdNb2RlKXtjYXNlXCJ6ZXJvc1wiOnJldHVybmBcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XG4gICAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihyKTtcbiAgICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gdTMyKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJib3JkZXJcIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIoY2xhbXAociwgMCwgSCAtIDEpKTtcbiAgICAgICAgICBpbmRpY2VzWyR7VnR9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xuICAgICAgICBgO2Nhc2VcInJlZmxlY3Rpb25cIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSBnc19yZWZsZWN0KHIsIGJvcmRlclsxXSwgYm9yZGVyWzNdKTtcbiAgICAgICAgICBpbmRpY2VzWyR7VnR9XSA9IGdzX3JlZmxlY3QoYywgYm9yZGVyWzBdLCBib3JkZXJbMl0pO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nIG1vZGUgJHtuLnBhZGRpbmdNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgXG4gICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpfTtcbiAgfVxuYCxNZz0oZSx0LG4pPT4oKCk9Pntzd2l0Y2gobi5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcbiAgICAgICAgYDtjYXNlXCJiaWxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xuICAgICAgICAgIGxldCB5MSA9IGkzMihmbG9vcih5KSk7XG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcblxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMTIgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuXG4gICAgICAgICAgbGV0IGR4MiA9ICR7dH0oZjMyKHgyKSAtIHgpO1xuICAgICAgICAgIGxldCBkeDEgPSAke3R9KHggLSBmMzIoeDEpKTtcbiAgICAgICAgICBsZXQgZHkyID0gJHt0fShmMzIoeTIpIC0geSk7XG4gICAgICAgICAgbGV0IGR5MSA9ICR7dH0oeSAtIGYzMih5MSkpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xuICAgICAgICBgO2Nhc2VcImJpY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgwID0gaTMyKGZsb29yKHgpKSAtIDE7XG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke3R9PjtcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCA0OyB3KyspIHtcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZHggPSB4IC0gZjMyKHgwICsgMSk7XG4gICAgICAgICAgbGV0IGR5ID0geSAtIGYzMih5MCArIDEpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBnc19iaWN1YmljX2ludGVycG9sYXRlKHAsIGR4LCBkeSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG1vZGUgJHtuLm1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2Ake2Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJyZXN1bHRcIil9YCxSZz0oZSx0KT0+e2xldCBuPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxyPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV0sbz1QKFwiZ3JpZFwiLGVbMV0uZGF0YVR5cGUsci5sZW5ndGgsMiksYT1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXTt0LmZvcm1hdD09PVwiTkhXQ1wiJiYoYT1bZVswXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxbcHQsJHQsTnQsVnRdPVswLDMsMSwyXSk7bGV0IHM9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgpLGQ9bi50eXBlLnZhbHVlLGw9RS5zaXplKGEpLHA9W3t0eXBlOjEyLGRhdGE6bH0sLi4uSChlWzBdLmRpbXMscixhKV0sZj1oPT5gXG4gICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobixvLHMpfVxuICAke1BnfVxuICAke3pnKGQpfVxuICAke09nKHQpfVxuICAke0RnKHQpfVxuICAke0JnKG4sZCx0KX1cblxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBIX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtOdH1dKTtcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtWdH1dKTtcblxuICAgICAgJHt0LmFsaWduQ29ybmVycz09PTA/YFxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcbiAgICAgIGxldCB5X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XG4gICAgICBgOmBcbiAgICAgIGxldCB4X21pbiA9IDAuMDtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDEuMDtcbiAgICAgIGxldCB5X21pbiA9IDAuMDtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDEuMDtcbiAgICAgIGB9O1xuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XG5cbiAgICAgIGxldCBpbmRpY2VzID0gJHtzLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1ske050fV0sIGluZGljZXNbJHtWdH1dKTtcbiAgICAgIGxldCBueHkgPSAke28uZ2V0QnlJbmRpY2VzKFwiZ3JpZF9pbmRpY2VzXCIpfTtcbiAgICAgIHZhciB4ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVswXSksIFdfaW4pO1xuICAgICAgdmFyIHkgPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzFdKSwgSF9pbik7XG5cbiAgICAgICR7TWcocyxkLHQpfVxuICB9YDtyZXR1cm57bmFtZTpcIkdyaWRTYW1wbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTpoPT57bGV0IHk9RS5zaXplKGEpO3JldHVybntvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmhbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9fSxnZXRTaGFkZXJTb3VyY2U6Zn19LFNsPShlLHQpPT57RWcoZS5pbnB1dHMpLGUuY29tcHV0ZShSZyhlLmlucHV0cyx0KSl9LFRsPWU9PnJlKHthbGlnbkNvcm5lcnM6ZS5hbGlnbl9jb3JuZXJzLG1vZGU6ZS5tb2RlLHBhZGRpbmdNb2RlOmUucGFkZGluZ19tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIE1lLFZnLEFsLElsLFdnLG9yLGtsLFNvPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtWcigpO3FyKCk7Y2UoKTtjdCgpO01lPShlLHQpPT5lLmxlbmd0aD50JiZlW3RdLmRpbXMubGVuZ3RoPjA/ZVt0XTp2b2lkIDAsVmc9KGUsdCk9PntsZXQgbj1lWzBdLHI9TWUoZSwxKSxvPU1lKGUsMiksYT1NZShlLDMpLHM9TWUoZSw0KSxkPU1lKGUsNSksbD1NZShlLDYpLHA9TWUoZSw3KTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgZj1uLmRpbXNbMF0saD1uLmRpbXNbMV0seT1uLmRpbXMubGVuZ3RoPT09Mz9uLmRpbXNbMl06dC5udW1IZWFkcypuLmRpbXNbNF0sXz1oLGI9MCx3PTAsUz1NYXRoLmZsb29yKHkvdC5udW1IZWFkcyk7aWYobCYmcCYmRS5zaXplKGwuZGltcykmJkUuc2l6ZShwLmRpbXMpKXtpZihsLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGwuZGltc1swXSE9PWZ8fGwuZGltc1sxXSE9PXQubnVtSGVhZHN8fGwuZGltc1szXSE9PVMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZihwLmRpbXNbMF0hPT1mfHxwLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxwLmRpbXNbM10hPT1TKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZihsLmRpbXNbMl0hPT1wLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7aWYocC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2I9bC5kaW1zWzJdLHc9bC5kaW1zWzJdfWVsc2UgaWYobCYmRS5zaXplKGwuZGltcyl8fHAmJkUuc2l6ZShwLmRpbXMpKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgJDtpZihyJiZFLnNpemUoci5kaW1zKT4wKXtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKHIuZGltcy5sZW5ndGg8M3x8ci5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PXIuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYoci5kaW1zLmxlbmd0aD09PTMpe2lmKHIuZGltc1syXSE9PW4uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpOyQ9MixfPXIuZGltc1sxXX1lbHNlIGlmKHIuZGltcy5sZW5ndGg9PT01KXtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0yfHxyLmRpbXNbNF0hPT1TKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihvKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTskPTUsXz1yLmRpbXNbMV19ZWxzZXtpZihyLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT1TKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpOyQ9MCxfPXIuZGltc1syXX19ZWxzZXtpZihuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7JD0zfWlmKGEmJkUuc2l6ZShhLmRpbXMpPjApe2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO2lmKHImJnIuZGltcy5sZW5ndGg9PT01JiZyLmRpbXNbM109PT0yKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi5cIil9bGV0IHY9YitfLFQ9MDtpZihzJiZFLnNpemUocy5kaW1zKT4wKXtUPTg7bGV0IE89cy5kaW1zO3Rocm93IE8ubGVuZ3RoPT09MT9PWzBdPT09Zj9UPTE6T1swXT09PTMqZisyJiYoVD0zKTpPLmxlbmd0aD09PTImJk9bMF09PT1mJiZPWzFdPT09diYmKFQ9NSksVD09PTg/bmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTpuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIil9bGV0IEM9ITEsQT15O2lmKG8mJkUuc2l6ZShvLmRpbXMpPjApe2lmKG8uZGltcy5sZW5ndGghPT0zJiZvLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09by5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihfIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1syXX1lbHNle2lmKF8hPT1vLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxDPSEwfX1sZXQgaz0hMTtpZihzJiZFLnNpemUocy5kaW1zKT4wKXRocm93IG5ldyBFcnJvcihcIktleSBwYWRkaW5nIG1hc2sgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkJiZFLnNpemUoZC5kaW1zKT4wKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGQuZGltc1swXSE9PWZ8fGQuZGltc1sxXSE9PXQubnVtSGVhZHN8fGQuZGltc1syXSE9PWh8fGQuZGltc1szXSE9PXYpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6ZixzZXF1ZW5jZUxlbmd0aDpoLHBhc3RTZXF1ZW5jZUxlbmd0aDpiLGt2U2VxdWVuY2VMZW5ndGg6Xyx0b3RhbFNlcXVlbmNlTGVuZ3RoOnYsbWF4U2VxdWVuY2VMZW5ndGg6dyxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOnksdkhpZGRlblNpemU6QSxoZWFkU2l6ZTpTLHZIZWFkU2l6ZTpNYXRoLmZsb29yKEEvdC5udW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxpc1VuaWRpcmVjdGlvbmFsOiExLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza0ZpbHRlclZhbHVlOnQubWFza0ZpbHRlclZhbHVlLG1hc2tUeXBlOlQsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOmsscGFzc1Bhc3RJbkt2OkMscWt2Rm9ybWF0OiR9fSxBbD1lPT5yZSh7Li4uZX0pLElsPXJlKHtwZXJtOlswLDIsMSwzXX0pLFdnPShlLHQsbixyLG8sYSxzKT0+e2xldCBkPVtyLG8sYV0sbD1FLnNpemUoZCkscD1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6YX1dLGY9aD0+e2xldCB5PU4oXCJxa3Zfd2l0aF9iaWFzXCIsdC5kYXRhVHlwZSxkKSxfPVAoXCJxa3ZcIix0LmRhdGFUeXBlLGQpLGI9UChcImJpYXNcIixuLmRhdGFUeXBlLGQpLHc9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19vZmZzZXRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7aC5yZWdpc3RlclVuaWZvcm1zKHcpLmRlY2xhcmVWYXJpYWJsZXMoXyxiLHkpfVxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcblxuICAgIHFrdl93aXRoX2JpYXNbZ2xvYmFsX2lkeF0gPSBxa3ZbZ2xvYmFsX2lkeF0gKyBiaWFzW2JpYXNfb2Zmc2V0X2lkeF07XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhc1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOmZ9LHtpbnB1dHM6W3Qsbl0sb3V0cHV0czpbLTFdfSlbMF19LG9yPShlLHQsbixyLG8sYSxzLGQpPT57bGV0IGw9YTtpZihzJiZFLnNpemUocy5kaW1zKT4wKXtpZihyPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1ZcIik7cmV0dXJuIGw9V2coZSxhLHMsdCxyLG4qbyxkKSxsPWwucmVzaGFwZShbdCxyLG4sb10pLG49PT0xfHxyPT09MT9sOmUuY29tcHV0ZShPZShsLElsLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfWVsc2UgcmV0dXJuIGEuZGltcy5sZW5ndGg9PT0zJiYobD1hLnJlc2hhcGUoW3QscixuLG9dKSksbj09PTF8fHI9PT0xP2w6ZS5jb21wdXRlKE9lKGwsSWwucGVybSkse2lucHV0czpbbF0sb3V0cHV0czpbLTFdfSlbMF19LGtsPShlLHQpPT57bGV0IG49VmcoZS5pbnB1dHMsdCkscj1lLmlucHV0c1swXSxvPU1lKGUuaW5wdXRzLDEpLGE9TWUoZS5pbnB1dHMsMikscz1NZShlLmlucHV0cywzKSxkPU1lKGUuaW5wdXRzLDQpLGw9TWUoZS5pbnB1dHMsNSkscD1NZShlLmlucHV0cyw2KSxmPU1lKGUuaW5wdXRzLDcpO2lmKHIuZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKG8/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCBoPW8mJmEmJm8uZGltcy5sZW5ndGg9PT00JiZhLmRpbXMubGVuZ3RoPT09NCx5PW9yKGUsbi5iYXRjaFNpemUsbi5udW1IZWFkcyxuLnNlcXVlbmNlTGVuZ3RoLG4uaGVhZFNpemUscixzLDApO2lmKGgpcmV0dXJuIFV0KGUseSxvLGEsZCx2b2lkIDAscCxmLGwsbik7aWYoIW98fCFhKXRocm93IG5ldyBFcnJvcihcImtleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZFwiKTtsZXQgXz1vcihlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5rdlNlcXVlbmNlTGVuZ3RoLG4uaGVhZFNpemUsbyxzLG4uaGlkZGVuU2l6ZSksYj1vcihlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5rdlNlcXVlbmNlTGVuZ3RoLG4udkhlYWRTaXplLGEscywyKm4uaGlkZGVuU2l6ZSk7VXQoZSx5LF8sYixkLHZvaWQgMCxwLGYsbCxuKX19KTt2YXIgTGcsR2csSGcsRmcsVG8sRWwsUGwsQ289RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7TGc9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSxHZz0oZSx0KT0+e2xldCBuPVtdLHI9dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+bi5wdXNoKE51bWJlcihvKSkpLHI9bi5sZW5ndGgpLHJlKHtudW1PdXRwdXRzOnIsYXhpczp0LmF4aXMsc3BsaXRTaXplczpufSl9LEhnPWU9PmBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCAke0soXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcImlcIixlKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG59YCxGZz1lPT57bGV0IHQ9ZS5sZW5ndGgsbj1bXTtmb3IobGV0IHI9MDtyPHQ7KytyKXtsZXQgbz1lW3JdLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP24ucHVzaChvKTpyPT09MD9uLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7cn11KSB7ICR7b30gfWApOnI9PT10LTE/bi5wdXNoKGBlbHNlIHsgJHtvfSB9YCk6bi5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7cn0pIHsgJHtvfSB9YCl9cmV0dXJuYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke24uam9pbihgXG5gKX1cbiAgICAgIH1gfSxUbz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPUUuc2l6ZShuKSxvPWVbMF0uZGF0YVR5cGUsYT1FLm5vcm1hbGl6ZUF4aXModC5heGlzLG4ubGVuZ3RoKSxzPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLGQ9UChcImlucHV0XCIsbyxuLmxlbmd0aCksbD1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxwPVtdLGY9W10saD0wLHk9W3t0eXBlOjEyLGRhdGE6cn1dO2ZvcihsZXQgYj0wO2I8dC5udW1PdXRwdXRzO2IrKyl7aCs9dC5zcGxpdFNpemVzW2JdLGxbYl09aDtsZXQgdz1uLnNsaWNlKCk7d1thXT10LnNwbGl0U2l6ZXNbYl0sZi5wdXNoKHcpLHNbYl09Tihgb3V0cHV0JHtifWAsbyx3Lmxlbmd0aCkscC5wdXNoKHtkaW1zOmZbYl0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfXkucHVzaCh7dHlwZToxMixkYXRhOmx9LC4uLkgobiwuLi5mKSk7bGV0IF89Yj0+YFxuICAke2IucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIsbC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoZCwuLi5zKX1cbiAgJHtIZyhsLmxlbmd0aCl9XG4gICR7Rmcocyl9XG5cbiAgJHtiLm1haW5TdGFydCgpfVxuICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMuaW5wdXRfc2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbmRleCA9ICR7ZC5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGEpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke0soXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcIm91dHB1dF9udW1iZXIgLSAxdVwiLGwubGVuZ3RoKX07XG4gICAgICAke2QuaW5kaWNlc1NldChcImluZGljZXNcIixhLFwiaW5kZXhcIil9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpfLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpwLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6eX0pfX0sRWw9KGUsdCk9PntMZyhlLmlucHV0cyk7bGV0IG49ZS5pbnB1dHMubGVuZ3RoPT09MT90OkdnKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShUbyhlLmlucHV0cyxuKSx7aW5wdXRzOlswXX0pfSxQbD1lPT57bGV0IHQ9ZS5heGlzLG49ZS5zcGxpdFNpemVzLHI9ZS5udW1PdXRwdXRzPDA/bi5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKHIhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIHJlKHtheGlzOnQsbnVtT3V0cHV0czpyLHNwbGl0U2l6ZXM6bn0pfX0pO3ZhciBxZyxLZyx6bCxPbCxEbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtxcigpO1NvKCk7Q28oKTtjdCgpO3FnPShlLHQpPT57aWYodC5kb1JvdGFyeSl0aHJvdyBuZXcgRXJyb3IoXCJHcm91cFF1ZXJyeUF0dGVudGlvbiBkb19yb3RhcnkgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5kb1JvdGFyeSYmZS5sZW5ndGg8PTcpdGhyb3cgbmV3IEVycm9yKFwiY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW5wdXRzIGFyZSByZXF1aXJlZCBpZiBkb19yb3RhcnkgaXMgc3BlY2lmaWVkXCIpO2xldCBuPWVbMF0scj1lWzFdLG89ZVsyXSxhPWVbM10scz1lWzRdO2lmKHQubG9jYWxXaW5kb3dTaXplIT09LTEpdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgYXR0ZW50aW9uIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zb2Z0Y2FwIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0Y2FwIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5yb3RhcnlJbnRlcmxlYXZlZCE9PTApdGhyb3cgbmV3IEVycm9yKFwiUm90YXJ5IGludGVybGVhdmVkIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zbW9vdGhTb2Z0bWF4KXRocm93IG5ldyBFcnJvcihcIlNtb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IGQ9ITEsbD1uLmRpbXNbMF0scD1uLmRpbXNbMV0sZj1uLmRpbXMubGVuZ3RoPT09Mz9kP24uZGltc1syXS8zOm4uZGltc1syXTp0Lm51bUhlYWRzKm4uZGltc1s0XSxoPXAseT0wLF89IXJ8fHIuZGltcy5sZW5ndGg9PT0wLGI9TWF0aC5mbG9vcihfP2YvKHQubnVtSGVhZHMrMip0Lmt2TnVtSGVhZHMpOmYvdC5udW1IZWFkcyk7XyYmKGY9Yip0Lm51bUhlYWRzKTtsZXQgdz1hJiZhLmRpbXMubGVuZ3RoIT09MCxTPXMmJnMuZGltcy5sZW5ndGghPT0wO2lmKHcmJmEuZGltcy5sZW5ndGg9PT00JiZhLmRpbXNbMF09PT1sJiZhLmRpbXNbMV0hPT10Lmt2TnVtSGVhZHMmJmEuZGltc1syXT09PXQua3ZOdW1IZWFkcyYmYS5kaW1zWzNdPT09Yil0aHJvdyBuZXcgRXJyb3IoXCJCU05IIHBhc3RLZXkvcGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodyYmUyl7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihzLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7eT1hLmRpbXNbMl19ZWxzZSBpZih3fHxTKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgdj0xO2lmKHImJnIuZGltcy5sZW5ndGg+MCl7aWYobi5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihyLmRpbXMubGVuZ3RoPDN8fHIuZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1yLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKHIuZGltcy5sZW5ndGg9PT0zKXtpZihuLmRpbXNbMl0lci5kaW1zWzJdIT09MCl0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7aD1yLmRpbXNbMV19ZWxzZSBpZihyLmRpbXMubGVuZ3RoPT09NSl7aWYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09Mnx8ci5kaW1zWzRdIT09Yil0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7aD1yLmRpbXNbMV19ZWxzZXtpZihyLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT1iKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO2g9ci5kaW1zWzJdfX1lbHNle2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYobi5kaW1zLmxlbmd0aD09PTUmJihuLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT0zKSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTt2PTN9bGV0IFQ9MCxDPSExLEE9dC5rdk51bUhlYWRzP2IqdC5rdk51bUhlYWRzOmY7aWYobyYmby5kaW1zLmxlbmd0aD4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoaCE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihoIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMV0qby5kaW1zWzNdLEM9ITB9fWxldCBrPWUubGVuZ3RoPjQ/ZVs1XTp2b2lkIDA7aWYoayYmay5kaW1zLmxlbmd0aCE9PTEmJmsuZGltc1swXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInNlcWxlbnNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uIGFuZCB0aGUgc2FtZSBkaW0gMCBhcyBiYXRjaF9zaXplJyk7cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOnksa3ZTZXF1ZW5jZUxlbmd0aDpoLHRvdGFsU2VxdWVuY2VMZW5ndGg6LTEsbWF4U2VxdWVuY2VMZW5ndGg6LTEsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTpmLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6Yix2SGVhZFNpemU6TWF0aC5mbG9vcihBL3Qua3ZOdW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxrdk51bUhlYWRzOnQua3ZOdW1IZWFkcyxuUmVwczp0Lm51bUhlYWRzL3Qua3ZOdW1IZWFkcyxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tUeXBlOlQsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOiExLHBhc3NQYXN0SW5LdjpDLHFrdkZvcm1hdDp2fX0sS2c9cmUoe3Blcm06WzAsMiwxLDNdfSksemw9KGUsdCxuKT0+e2xldCByPXQsbz1uLmt2TnVtSGVhZHM7cmV0dXJuIHQuZGltcy5sZW5ndGg9PT0zJiZuLmt2U2VxdWVuY2VMZW5ndGghPT0wJiYocj10LnJlc2hhcGUoW24uYmF0Y2hTaXplLG4ua3ZTZXF1ZW5jZUxlbmd0aCxvLG4uaGVhZFNpemVdKSxyPWUuY29tcHV0ZShPZShyLEtnLnBlcm0pLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xXX0pWzBdKSxyfSxPbD0oZSx0KT0+e2xldCBuPXFnKGUuaW5wdXRzLHQpO2lmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihlLmlucHV0c1sxXT8uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7bGV0IHI9ZS5pbnB1dHNbMF0sbz1lLmlucHV0c1sxXSYmZS5pbnB1dHNbMV0uZGltcy5sZW5ndGg+MD9lLmlucHV0c1sxXTp2b2lkIDAsYT1lLmlucHV0c1syXSYmZS5pbnB1dHNbMl0uZGltcy5sZW5ndGg+MD9lLmlucHV0c1syXTp2b2lkIDAscz1lLmlucHV0c1szXSYmZS5pbnB1dHNbM10uZGltcy5sZW5ndGghPT0wP2UuaW5wdXRzWzNdOnZvaWQgMCxkPWUuaW5wdXRzWzRdJiZlLmlucHV0c1s0XS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbNF06dm9pZCAwLGw9ZS5pbnB1dHMubGVuZ3RoPjQ/ZS5pbnB1dHNbNV06dm9pZCAwLHA9ZS5pbnB1dHMubGVuZ3RoPjU/ZS5pbnB1dHNbNl06dm9pZCAwLGY9bi5rdk51bUhlYWRzP24ua3ZOdW1IZWFkczpuLm51bUhlYWRzLGg9cmUoe2F4aXM6MixudW1PdXRwdXRzOjMsc3BsaXRTaXplczpbbi5udW1IZWFkcypuLmhlYWRTaXplLGYqbi5oZWFkU2l6ZSxmKm4uaGVhZFNpemVdfSksW3ksXyxiXT0hbyYmIWE/ZS5jb21wdXRlKFRvKFtyXSxoKSx7aW5wdXRzOltyXSxvdXRwdXRzOlstMSwtMSwtMV19KTpbcixvLGFdLHc9b3IoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4uc2VxdWVuY2VMZW5ndGgsbi5oZWFkU2l6ZSx5LHZvaWQgMCwwKTtVdChlLHcsemwoZSxfLG4pLHpsKGUsYixuKSx2b2lkIDAsdm9pZCAwLHMsZCx2b2lkIDAsbixsLHApfX0pO3ZhciBCbCxqZyxaZyxNbCxSbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2N0KCk7Y2UoKTtCbD0oZSx0LG4scixvLGEscyxkKT0+e2xldCBsPWdlKGEpLHA9bD09PTE/XCJmMzJcIjpgdmVjJHtsfWZgLGY9bD09PTE/XCJ2ZWMyZlwiOmBtYXQyeCR7bH1mYCxoPW8qcyx5PTY0O2g9PT0xJiYoeT0yNTYpO2xldCBfPVtvLHMsYS9sXSxiPVtvLHMsMl0sdz1bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdLFM9W107Uy5wdXNoKC4uLkgoXyxiKSk7bGV0ICQ9dj0+e2xldCBUPVAoXCJ4XCIsdC5kYXRhVHlwZSwzLGwpLEM9UChcInNjYWxlXCIsbi5kYXRhVHlwZSxuLmRpbXMpLEE9UChcImJpYXNcIixyLmRhdGFUeXBlLHIuZGltcyksaz1OKFwib3V0cHV0XCIsMSwzLDIpLE89W1QsQyxBLGtdO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZCA6IGFycmF5PCR7Zn0sICR7eX0+O1xuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7eX11O1xuICAke3YuZGVjbGFyZVZhcmlhYmxlcyguLi5PKX1cbiAgJHt2Lm1haW5TdGFydCh5KX1cbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgaGlnaHQgPSB1bmlmb3Jtcy54X3NoYXBlWzJdO1xuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBzdW0gPSAke3B9KDApO1xuICAgIHZhciBzcXVhcmVkX3N1bSA9ICR7cH0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke3B9KCR7VC5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0pO1xuICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgc3F1YXJlZF9zdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gJHtmfShzdW0sIHNxdWFyZWRfc3VtKTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cF9zaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9IHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSArIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxfaWR4ID09IDApIHtcbiAgICAgIGxldCBzdW1fZmluYWwgPSAke0tlKFwid29ya2dyb3VwX3NoYXJlZFswXVswXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuICAgICAgbGV0IHNxdWFyZWRfc3VtX2ZpbmFsID0gJHtLZShcIndvcmtncm91cF9zaGFyZWRbMF1bMV1cIixsKX0gLyBmMzIoaGlnaHQgKiAke2x9KTtcblxuICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZF9zdW1fZmluYWwgLSBzdW1fZmluYWwgKiBzdW1fZmluYWwgKyBmMzIoJHtkfSkpO1xuICAgICAgbGV0IGNoYW5uZWxfc2NhbGUgPSBpbnZfc3RkX2RldiAqIGYzMihzY2FsZVtjaGFubmVsXSk7XG4gICAgICBsZXQgY2hhbm5lbF9zaGlmdCA9IGYzMihiaWFzW2NoYW5uZWxdKSAtIHN1bV9maW5hbCAqIGNoYW5uZWxfc2NhbGU7XG4gICAgICBvdXRwdXRbd29ya2dyb3VwX2luZGV4XSA9IHZlYzJmKGNoYW5uZWxfc2NhbGUsIGNoYW5uZWxfc2hpZnQpO1xuICAgIH1cbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsfTske2R9OyR7eX1gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YixkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpofSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTokfSx7aW5wdXRzOlt0LG4scl0sb3V0cHV0czpbLTFdfSlbMF19LGpnPShlLHQsbik9PntsZXQgcj10WzBdLmRpbXMsbz1yLGE9MixzPXJbMF0sZD1yWzFdLGw9RS5zaXplRnJvbURpbWVuc2lvbihyLGEpLHA9Z2UobCksZj1FLnNpemUobykvcCxoPUJsKGUsdFswXSx0WzFdLHRbMl0scyxsLGQsbi5lcHNpbG9uKSx5PVtzLGQsbC9wXSxfPVtzLGRdLGI9W1widHlwZVwiLFwibm9uZVwiXSx3PVM9PntsZXQgJD1QKFwieFwiLHRbMF0uZGF0YVR5cGUseS5sZW5ndGgscCksdj1QKFwic2NhbGVfc2hpZnRcIiwxLF8ubGVuZ3RoLDIpLFQ9TihcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUseS5sZW5ndGgscCksQz1bJCx2LFRdO3JldHVybmBcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5DKX1cbiAgJHtTLm1haW5TdGFydCgpfVxuICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgICAgbGV0IGNoYW5uZWwgPSBvdXRwdXRJbmRpY2VzWzFdO1xuICAgICAgbGV0IHNjYWxlX3NoaWZ0ID0gJHt2LmdldEJ5SW5kaWNlcyhcInZlYzI8dTMyPihiYXRjaCwgY2hhbm5lbClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHskLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX0gKiAke1QudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueCkgKyAke1QudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueSk7XG4gICAgICAke1Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6Yn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChmLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmZ9LC4uLkgoeSxfLHkpXX0pLGdldFNoYWRlclNvdXJjZTp3fSx7aW5wdXRzOlt0WzBdLGhdfSl9LFpnPShlLHQsbik9PntsZXQgcj10WzBdLmRpbXMsbz1yLGE9clswXSxzPXJbci5sZW5ndGgtMV0sZD1FLnNpemVGcm9tRGltZW5zaW9uKHIsMSkvcyxsPWdlKHMpLHA9RS5zaXplKG8pL2wsZj1be3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOk1hdGguZmxvb3Iocy9sKX1dLGg9W1widHlwZVwiLFwidHlwZVwiXSx5PSExLF89WzAsci5sZW5ndGgtMV07Zm9yKGxldCAkPTA7JDxyLmxlbmd0aC0yOyQrKyl5PXl8fHJbJCsxXSE9PTEsXy5wdXNoKCQrMSk7eT15JiZyW3IubGVuZ3RoLTFdIT09MTtsZXQgYj15P2UuY29tcHV0ZShPZShlLmlucHV0c1swXSxfKSx7aW5wdXRzOltlLmlucHV0c1swXV0sb3V0cHV0czpbLTFdfSlbMF06ZS5pbnB1dHNbMF0ucmVzaGFwZShBcnJheS5mcm9tKHtsZW5ndGg6ci5sZW5ndGh9LCgkLHYpPT5yW19bdl1dKSksdz1CbChlLGIsdFsxXSx0WzJdLGEsZCxzLG4uZXBzaWxvbiksUz0kPT57bGV0IHY9X2UodFswXS5kYXRhVHlwZSksVD1sPT09MT9cInZlYzJmXCI6YG1hdCR7bH14MmZgLEM9Tz0+e2xldCBNPU89PT0wP1wieFwiOlwieVwiLFY9bD09PTE/XCJmMzJcIjpgdmVjJHtsfWZgO3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuYCR7dn0oJHtWfShzY2FsZS4ke019KSlgO2Nhc2UgMjpyZXR1cm5gdmVjMjwke3Z9Pigke1Z9KHNjYWxlWzBdLiR7TX0sIHNjYWxlWzFdLiR7TX0pKWA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dn0+KCR7Vn0oc2NhbGVbMF0uJHtNfSwgc2NhbGVbMV0uJHtNfSwgc2NhbGVbMl0uJHtNfSwgc2NhbGVbM10uJHtNfSkpYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBjb21wb2VudHMgJHtsfWApfX0sQT1QKFwiaW5wdXRcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcyxsKSxrPU4oXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLG8sbCk7cmV0dXJuYFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtBLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlX2lucHV0IDogYXJyYXk8JHtUfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtrLnR5cGUuc3RvcmFnZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICBsZXQgY3VycmVudF9pbWFnZV9udW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcbiAgICBsZXQgY3VycmVudF9jaGFubmVsX251bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlX29mZnNldCA9IGN1cnJlbnRfaW1hZ2VfbnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRfY2hhbm5lbF9udW1iZXI7XG4gICAgbGV0IHNjYWxlID0gc2NhbGVfaW5wdXRbc2NhbGVfb2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7QygwKX0sICR7QygxKX0pO1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQ1wiLHNoYWRlckNhY2hlOntoaW50OmAke2x9YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOlt0WzBdLHddfSl9LE1sPShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9aZyhlLGUuaW5wdXRzLHQpOmpnKGUsZS5pbnB1dHMsdCl9fSk7dmFyIFFnLFlnLFVsLE5sPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtRZz1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0sWWc9KGUsdCxuKT0+e2xldCByPXQuc2ltcGxpZmllZCxvPWVbMF0uZGltcyxhPWVbMV0scz0hciYmZVsyXSxkPW8sbD1FLm5vcm1hbGl6ZUF4aXModC5heGlzLG8ubGVuZ3RoKSxwPUUuc2l6ZVRvRGltZW5zaW9uKG8sbCksZj1FLnNpemVGcm9tRGltZW5zaW9uKG8sbCksaD1FLnNpemUoYS5kaW1zKSx5PXM/RS5zaXplKHMuZGltcyk6MDtpZihoIT09Znx8cyYmeSE9PWYpdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtmfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7aH0gYW5kIGJpYXMgc2l6ZSBvZiAke3l9YCk7bGV0IF89W107Zm9yKGxldCBBPTA7QTxvLmxlbmd0aDsrK0EpQTxsP18ucHVzaChvW0FdKTpfLnB1c2goMSk7bGV0IGI9Z2UoZiksdz1bXCJ0eXBlXCIsXCJ0eXBlXCJdLFM9W3t0eXBlOjEyLGRhdGE6cH0se3R5cGU6MSxkYXRhOmZ9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihmL2IpfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV07cyYmdy5wdXNoKFwidHlwZVwiKTtsZXQgJD1uPjEsdj1uPjIsVD1BPT57bGV0IGs9X2UoZVswXS5kYXRhVHlwZSksTz1bUChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxiKSxQKFwic2NhbGVcIixhLmRhdGFUeXBlLGEuZGltcyxiKV07cyYmTy5wdXNoKFAoXCJiaWFzXCIscy5kYXRhVHlwZSxzLmRpbXMsYikpLE8ucHVzaChOKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLGIpKSwkJiZPLnB1c2goTihcIm1lYW5fZGF0YV9vdXRwdXRcIiwxLF8pKSx2JiZPLnB1c2goTihcImludl9zdGRfb3V0cHV0XCIsMSxfKSk7bGV0IE09W3tuYW1lOlwibm9ybV9jb3VudFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJub3JtX3NpemVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwibm9ybV9zaXplX3ZlY3Rvcml6ZWRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoTSkuZGVjbGFyZVZhcmlhYmxlcyguLi5PKX1cbiAgJHtBLm1haW5TdGFydCgpfVxuICAgICR7QS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMubm9ybV9jb3VudFwiKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xuICAgIHZhciBtZWFuX3ZlY3RvciA9ICR7dW8oXCJmMzJcIixiKX07XG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7dW8oXCJmMzJcIixiKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7UHQoayxiLFwieFtoICsgb2Zmc2V0XVwiKX07XG4gICAgICBtZWFuX3ZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7S2UoXCJtZWFuX3ZlY3RvclwiLGIpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZTtcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke0tlKFwibWVhbl9zcXVhcmVfdmVjdG9yXCIsYil9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7cj9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBqKyspIHtcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7UHQoayxiLFwieFtqICsgb2Zmc2V0XVwiKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke1B0KGssYixcInNjYWxlW2pdXCIpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7T1swXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgJHtyP1wiXCI6XCItIG1lYW5cIn0pICogaW52X3N0ZF9kZXYgKiBmMzJzY2FsZVxuICAgICAgICAke3M/YCsgJHtQdChrLGIsXCJiaWFzW2pdXCIpfWA6XCJcIn1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHskP1wibWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcbiAgICAke3Y/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2XCI6XCJcIn07XG4gIH1gfSxDPVt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gJCYmQy5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHYmJkMucHVzaCh7ZGltczpfLGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke2J9OyR7bn07JHtyfWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkMsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpTfSksZ2V0U2hhZGVyU291cmNlOlR9fSxVbD0oZSx0KT0+e1FnKGUuaW5wdXRzKSxlLmNvbXB1dGUoWWcoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyIFhnLFZsLFdsPUcoKCk9PntcInVzZSBzdHJpY3RcIjthZSgpO1hyKCk7SnIoKTtYZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTFdIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIil9LFZsPWU9PntYZyhlLmlucHV0cyk7bGV0IHQ9cnQuY2FsY1NoYXBlKGUuaW5wdXRzWzBdLmRpbXMsZS5pbnB1dHNbMV0uZGltcywhMCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgbj10W3QubGVuZ3RoLTFdLHI9ZS5pbnB1dHNbMF0uZGltc1tlLmlucHV0c1swXS5kaW1zLmxlbmd0aC0xXTtpZihuPDgmJnI8OCllLmNvbXB1dGUoWXIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpO2Vsc2V7bGV0IG89dFt0Lmxlbmd0aC0yXSxhPUUuc2l6ZShlLmlucHV0c1swXS5kaW1zLnNsaWNlKDAsLTIpKSxzPUUuc2l6ZShlLmlucHV0c1sxXS5kaW1zLnNsaWNlKDAsLTIpKTtpZihhIT09MSYmbz09PTEmJnM9PT0xKXtsZXQgZD1lLmlucHV0c1swXS5yZXNoYXBlKFsxLGEscl0pLGw9ZS5pbnB1dHNbMV0ucmVzaGFwZShbMSxyLG5dKSxwPVsxLGEsbl0sZj1bZCxsXTtlLmNvbXB1dGUobnIoZix7YWN0aXZhdGlvbjpcIlwifSx0LHApLHtpbnB1dHM6Zn0pfWVsc2UgZS5jb21wdXRlKG5yKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKX19fSk7dmFyIEpnLGV5LHR5LExsLEdsLEhsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0pnPShlLHQpPT57aWYoZS5sZW5ndGg8M3x8ZS5sZW5ndGg+NCl0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWxOQml0cyByZXF1aXJlcyAzIG9yIDQgaW5wdXRzXCIpO2xldCBuPWVbMF0scj1uLmRpbXMubGVuZ3RoO2lmKG4uZGltc1tyLTFdIT09dC5rKXRocm93IG5ldyBFcnJvcihcIlRoZSBsYXN0IGRpbSBvZiBpbnB1dCBzaGFwZSBkb2VzIG5vdCBtYXRjaCB0aGUgayB2YWx1ZVwiKTtsZXQgbz1NYXRoLmZsb29yKCh0LmsrdC5ibG9ja1NpemUtMSkvdC5ibG9ja1NpemUpLGE9dC5ibG9ja1NpemUvOCp0LmJpdHMscz1lWzFdO2lmKCFFLmFyZUVxdWFsKHMuZGltcyxbdC5uLG8sYV0pKXRocm93IG5ldyBFcnJvcihcIlRoZSBzZWNvbmQgaW5wdXRzIG11c3QgYmUgM0QgdGVuc29yIHdpdGggc2hhcGUgTiBYIG5CbG9ja3NQZXJDb2wgWCBibG9iU2l6ZVwiKTtsZXQgbD1lWzJdLmRpbXM7aWYoRS5zaXplKGwpIT09dC5uKm8pdGhyb3cgbmV3IEVycm9yKFwic2NhbGVzIGlucHV0IHNpemUgZXJyb3IuXCIpO2lmKGUubGVuZ3RoPT09NCl7bGV0IGY9ZVszXS5kaW1zLGg9dC5iaXRzPjQ/dC5uKm86dC5uKk1hdGguZmxvb3IoKG8rMSkvMik7aWYoRS5zaXplKGYpIT09aCl0aHJvdyBuZXcgRXJyb3IoXCJ6ZXJvUG9pbnRzIGlucHV0IHNpemUgZXJyb3IuXCIpfX0sZXk9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1uLmxlbmd0aCxvPW5bci0yXSxhPXQuayxzPXQubixkPW4uc2xpY2UoMCxyLTIpLGw9RS5zaXplKGQpLGY9ZVsxXS5kaW1zWzJdLzQsaD1lWzBdLmRhdGFUeXBlLHk9Z2UodC5rKSxfPWdlKGYpLGI9Z2Uocyksdz1kLmNvbmNhdChbbyxzXSksUz1vPjEmJnMvYiUyPT09MD8yOjEsJD1FLnNpemUodykvYi9TLHY9NjQsVD1bXSxDPVtsLG8sYS95XSxBPUUuY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtBLnNwbGljZSgtMSwxLGYvXyksVC5wdXNoKC4uLkgoQykpLFQucHVzaCguLi5IKEEpKSxULnB1c2goLi4uSChlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJlQucHVzaCguLi5IKEUuY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgaz1bbCxvLHMvYl07VC5wdXNoKC4uLkgoaykpO2xldCBPPU09PntsZXQgVj1DLmxlbmd0aCxGPVAoXCJhXCIsZVswXS5kYXRhVHlwZSxWLHkpLGo9UChcImJcIiwxMixBLmxlbmd0aCxfKSxuZT1QKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxXPVtGLGosbmVdLEo9ZS5sZW5ndGg9PT00P1AoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtKJiZXLnB1c2goSik7bGV0IHZlPWsubGVuZ3RoLFE9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdmUsYiksZWU9X2UoZVswXS5kYXRhVHlwZSksbGU9KCgpPT57c3dpdGNoKHkpe2Nhc2UgMTpyZXR1cm5gYXJyYXk8JHtlZX0sIDg+YDtjYXNlIDI6cmV0dXJuYG1hdDR4Mjwke2VlfT5gO2Nhc2UgNDpyZXR1cm5gbWF0Mng0PCR7ZWV9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7eX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSkoKSxaPSgpPT57bGV0IFNlPWBcbiAgICAgICAgICAvLyByZXVzZSBhIGRhdGFcbiAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke0YuaW5kaWNlc1RvT2Zmc2V0KGAke0YudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCB3b3JkX29mZnNldClgKX07XG4gICAgICAgICAgICB2YXIgYV9kYXRhOiAke2xlfTtcbiAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCAkezgveX07IGorKykge1xuICAgICAgICAgICAgICBhX2RhdGFbal0gPSAke0YuZ2V0QnlPZmZzZXQoXCJpbnB1dF9vZmZzZXRcIil9O1xuICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO2ZvcihsZXQgRD0wO0Q8YipTO0QrKylTZSs9YFxuICAgICAgICAgICAgYl92YWx1ZSA9ICR7Xz09PTE/YGIke0R9X2RhdGFgOmBiJHtEfV9kYXRhW2ldYH07XG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7bGV9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChSLFkpPT5gJHtlZX0oYl92YWx1ZV9sb3dlclske1l9XSksICR7ZWV9KGJfdmFsdWVfdXBwZXJbJHtZfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7eT09PTE/YCR7bGV9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjh9LChSLFkpPT5gKGJfcXVhbnRpemVkX3ZhbHVlc1ske1l9XSAtICR7Sj9gemVyb19wb2ludCR7RH1gOlwiemVyb19wb2ludFwifSkgKiBzY2FsZSR7RH1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtsZX0oJHtBcnJheSg4KS5maWxsKGAke0o/YHplcm9fcG9pbnQke0R9YDpcInplcm9fcG9pbnRcIn1gKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlJHtEfTtgfTtcbiAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWQueCAqICR7U30gKyAke01hdGguZmxvb3IoRC9iKX1dJHtiPjE/YFske0QlYn1dYDpcIlwifSArPSAke0FycmF5LmZyb20oe2xlbmd0aDo4L3l9LChSLFkpPT5gJHt5PT09MT9gYV9kYXRhWyR7WX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtZfV1gOmBkb3QoYV9kYXRhWyR7WX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske1l9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgIGA7cmV0dXJuIFNlfSxwZT0oKT0+e2xldCBTZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHtifTtcbiAgICAgICAgICAgICR7Sj9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2VlfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IEQ9MDtEPGIqUztEKyspU2UrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7RH0gPSAke25lLmdldEJ5T2Zmc2V0KFwiY29sX2luZGV4ICogbkJsb2Nrc1BlckNvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgICR7Sj9gXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7Si5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtEfSA9ICR7ZWV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpcIlwifVxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gU2V9LGtlPSgpPT57bGV0IFNlPWBjb2xfaW5kZXggPSBjb2wgKiAke2J9O2A7Zm9yKGxldCBEPTA7RDxiKlM7RCsrKVNlKz1gXG4gICAgICAgICAgICBsZXQgYiR7RH1fZGF0YSA9ICR7ai5nZXRCeUluZGljZXMoYCR7ai50eXBlLmluZGljZXN9KGNvbF9pbmRleCwgYmxvY2ssIHdvcmQpYCl9O1xuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gU2UrPWBcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlOiB1MzI7XG4gICAgICAgICAgICBsZXQgYl9tYXNrOiB1MzIgPSAweDBGMEYwRjBGdTtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX2xvd2VyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV91cHBlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfcXVhbnRpemVkX3ZhbHVlczogJHtsZX07XG4gICAgICAgICAgICB2YXIgYl9kZXF1YW50aXplZF92YWx1ZXM6ICR7bGV9O2AsU2V9O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtRLnR5cGUudmFsdWV9LCAke1Mqdn0+O1xuICAgICAgICAke00uZGVjbGFyZVZhcmlhYmxlcyguLi5XLFEpfVxuICAgICAgICAke00ubWFpblN0YXJ0KFt2LDEsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7US5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt2fSkgKiAke1N9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5CbG9ja3NQZXJDb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7dn0pIHtcbiAgICAgICAgICAgIC8vcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke3QuYmxvY2tTaXplL3l9O1xuICAgICAgICAgICAgJHtwZSgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7Zn07IHdvcmQgKz0gJHtffSkge1xuICAgICAgICAgICAgICAke2tlKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke1ooKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgveX07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke1N9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke1EudHlwZS52YWx1ZX0gPSAke1EudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7dn11OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke1N9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtRLnNldEJ5SW5kaWNlcyhgJHtRLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLFwib3V0cHV0X3ZhbHVlXCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIk1hdE11bE5CaXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7dC5iaXRzfTske3l9OyR7X307JHtifTske1N9OyR7dn1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp3LGRhdGFUeXBlOmh9XSxkaXNwYXRjaEdyb3VwOnt4OiR9LHByb2dyYW1Vbmlmb3JtczpUfSksZ2V0U2hhZGVyU291cmNlOk99fSx0eT0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPW4ubGVuZ3RoLG89bltyLTJdLGE9dC5rLHM9dC5uLGQ9bi5zbGljZSgwLHItMiksbD1FLnNpemUoZCksZj1lWzFdLmRpbXNbMl0vNCxoPWVbMF0uZGF0YVR5cGUseT1nZSh0LmspLF89Z2UoZiksYj1kLmNvbmNhdChbbyxzXSksdz0xMjgsUz1zJTg9PT0wPzg6cyU0PT09MD80OjEsJD13L1Msdj0kKl8qOCxUPXYveSxDPXYvdC5ibG9ja1NpemUsQT1FLnNpemUoYikvUyxrPVtdLE89W2wsbyxhL3ldLE09RS5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO00uc3BsaWNlKC0xLDEsZi9fKSxrLnB1c2goLi4uSChPKSksay5wdXNoKC4uLkgoTSkpLGsucHVzaCguLi5IKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmay5wdXNoKC4uLkgoRS5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBWPVtsLG8sc107ay5wdXNoKC4uLkgoVikpO2xldCBGPWo9PntsZXQgbmU9Ty5sZW5ndGgsVz1QKFwiYVwiLGVbMF0uZGF0YVR5cGUsbmUseSksSj1QKFwiYlwiLDEyLE0ubGVuZ3RoLF8pLHZlPVAoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFE9W1csSix2ZV0sZWU9ZS5sZW5ndGg9PT00P1AoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtlZSYmUS5wdXNoKGVlKTtsZXQgbGU9Vi5sZW5ndGgsWj1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxsZSkscGU9X2UoZVswXS5kYXRhVHlwZSksa2U9KCk9Pntzd2l0Y2goeSl7Y2FzZSAxOnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO2Nhc2UgMjpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7cGV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke3BlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7YDtjYXNlIDQ6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gc3ViX2Fbd29yZF9vZmZzZXRdO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gc3ViX2Fbd29yZF9vZmZzZXQgKyAxXTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke3l9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHtXLnR5cGUudmFsdWV9LCAke1R9PjtcbiAgICAgICAgdmFyPHdvcmtncm91cD4gaW50ZXJfcmVzdWx0czogYXJyYXk8YXJyYXk8JHtaLnR5cGUudmFsdWV9LCAkeyR9PiwgJHtTfT47XG4gICAgICAgICR7ai5kZWNsYXJlVmFyaWFibGVzKC4uLlEsWil9XG4gICAgICAgICR7ai5tYWluU3RhcnQoWyQsUywxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtaLm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHtTfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke0N9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7VH07XG4gICAgICAgICAgICAvLyBsb2FkIG9uZSB0aWxlIEEgZGF0YSBpbnRvIHNoYXJlZCBtZW1vcnkuXG4gICAgICAgICAgICBmb3IgKHZhciBhX29mZnNldCA9IGxvY2FsX2lkeDsgYV9vZmZzZXQgPCAke1R9OyBhX29mZnNldCArPSAke3d9KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgYV9jb2wgPSBhX2NvbF9zdGFydCArIGFfb2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAoYV9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzJdKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHtXLmdldEJ5SW5kaWNlcyhgJHtXLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgYV9jb2wpYCl9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vy50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgICAvLyBlYWNoIHRocmVhZCBwcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgbGV0IGJfcm93ID0gY29sICsgbG9jYWxfaWQueTtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRpbGUgKiAke0N9ICsgbG9jYWxfaWQueDtcbiAgICAgICAgICAgICR7ZWU/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHtlZS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtwZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke3BlfSg4KTtgfVxuICAgICAgICAgICAgbGV0IHNjYWxlID0gJHt2ZS5nZXRCeU9mZnNldChcImJfcm93ICogbl9ibG9ja3NfcGVyX2NvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgIGxldCBiX2RhdGEgPSAke0ouZ2V0QnlJbmRpY2VzKGAke0oudHlwZS5pbmRpY2VzfShiX3JvdywgYmxvY2ssIDApYCl9O1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0ID0gbG9jYWxfaWQueCAqICR7dC5ibG9ja1NpemUveX07XG4gICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtffTsgaSsrKSB7XG4gICAgICAgICAgICAgICR7a2UoKX1cbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWUgPSAke189PT0xP1wiYl9kYXRhXCI6XCJiX2RhdGFbaV1cIn07XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3F1YW50aXplZF92YWx1ZXMgPSBtYXQyeDQ8JHtwZX0+KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChTZSxEKT0+YCR7cGV9KGJfdmFsdWVfbG93ZXJbJHtEfV0pLCAke3BlfShiX3ZhbHVlX3VwcGVyWyR7RH1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgICBsZXQgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gbWF0Mng0PCR7cGV9Pigke0FycmF5KDgpLmZpbGwoXCJ6ZXJvX3BvaW50XCIpLmpvaW4oXCIsXCIpfSkpICogc2NhbGU7XG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6Mn0sKFNlLEQpPT5gJHtgZG90KGFfZGF0YSR7RH0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7RH1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OC95fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgJHtTfSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtaLnR5cGUudmFsdWV9ID0gJHtaLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHskfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke1ouc2V0QnlJbmRpY2VzKGAke1oudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZHgpYCxcIm91dHB1dF92YWx1ZVwiKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkJsb2Nrd2lzZU1hdE11bE5CaXRzMzJcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmJsb2NrU2l6ZX07JHt5fTske199OyR7JH07JHtTfWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkoZS5sZW5ndGgpLmZpbGwoXCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmIsZGF0YVR5cGU6aH1dLGRpc3BhdGNoR3JvdXA6e3g6QX0scHJvZ3JhbVVuaWZvcm1zOmt9KSxnZXRTaGFkZXJTb3VyY2U6Rn19LExsPShlLHQpPT57SmcoZS5pbnB1dHMsdCksdC5ibG9ja1NpemU9PT0zMiYmZS5hZGFwdGVySW5mby5pc1ZlbmRvcihcImludGVsXCIpJiZlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiZ2VuLTEybHBcIik/ZS5jb21wdXRlKHR5KGUuaW5wdXRzLHQpKTplLmNvbXB1dGUoZXkoZS5pbnB1dHMsdCkpfSxHbD1lPT5yZShlKX0pO3ZhciByeSxueSxveSxpeSxheSxzeSx1eSxkeSxGbCxxbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7cnk9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIlRvbyBmZXcgaW5wdXRzXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09MTApdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0IG9yIGZsb2F0MTYuXCIpO2lmKGUubGVuZ3RoPj0yKXtsZXQgdD1lWzBdLmRpbXMubGVuZ3RoKjI9PT1lWzFdLmRpbXNbMF07aWYoZS5sZW5ndGg9PT00JiYodD1lWzNdLmRpbXNbMF0qMj09PWVbMV0uZGltc1swXSksIXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uXCIpfX0sbnk9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0soXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7SyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgdmFsdWUgPSAke2UudHlwZS52YWx1ZX0odW5pZm9ybXMuY29uc3RhbnRfdmFsdWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGB9LG95PShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7SyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAtaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGV0IF8ybl8xID0gMiAqIChpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDEpO1xuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtLKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0saXk9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtLKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0soXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxheT0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0soXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSAge1xuICAgICAgICAgICAgICAgICAgayArPSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICBrIC09IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0soXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxzeT0oZSx0LG4pPT57c3dpdGNoKG4ubW9kZSl7Y2FzZSAwOnJldHVybiBueShlLHQsbi5wYWRzLmxlbmd0aCk7Y2FzZSAxOnJldHVybiBveShlLHQsbi5wYWRzLmxlbmd0aCk7Y2FzZSAyOnJldHVybiBpeShlLHQsbi5wYWRzLmxlbmd0aCk7Y2FzZSAzOnJldHVybiBheShlLHQsbi5wYWRzLmxlbmd0aCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSx1eT0oZSx0KT0+e2xldCBuPUUucGFkU2hhcGUoZVswXS5kaW1zLnNsaWNlKCksdC5wYWRzKSxyPWVbMF0uZGltcyxvPUUuc2l6ZShuKSxhPVt7dHlwZToxMixkYXRhOm99LHt0eXBlOjYsZGF0YTp0LnBhZHN9XSxzPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE7dC5tb2RlPT09MCYmYS5wdXNoKHt0eXBlOnM/ZVsyXS5kYXRhVHlwZToxLGRhdGE6dC52YWx1ZX0pLGEucHVzaCguLi5IKGVbMF0uZGltcyxuKSk7bGV0IGQ9W1wicmFua1wiXSxsPXA9PntsZXQgZj1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCksaD1QKFwieFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgpLHk9aC50eXBlLnZhbHVlLF89c3koZixyLmxlbmd0aCx0KSxiPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOnQucGFkcy5sZW5ndGh9XTtyZXR1cm4gdC5tb2RlPT09MCYmYi5wdXNoKHtuYW1lOlwiY29uc3RhbnRfdmFsdWVcIix0eXBlOnM/eTpcImYzMlwifSksYFxuICAgICAgICAgICAgJHtwLnJlZ2lzdGVyVW5pZm9ybXMoYikuZGVjbGFyZVZhcmlhYmxlcyhoLGYpfVxuICAgICAgICAgICAgJHtwLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke2Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7eX0oMCk7XG4gICAgICAgICAgICAke199XG4gICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUGFkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5tb2RlfSR7c31gLGlucHV0RGVwZW5kZW5jaWVzOmR9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRS5zaXplKG4pLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmF9KSxnZXRTaGFkZXJTb3VyY2U6bH19LGR5PShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IG49ZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkscj1lLmxlbmd0aD49MyYmZVsyXS5kYXRhP2VbMl0uZGF0YVR5cGU9PT0xMD9lWzJdLmdldFVpbnQxNkFycmF5KClbMF06ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTowLG89ZVswXS5kaW1zLmxlbmd0aCxhPW5ldyBJbnQzMkFycmF5KDIqbykuZmlsbCgwKTtpZihlLmxlbmd0aD49NCl7bGV0IGQ9ZVszXS5nZXRCaWdJbnQ2NEFycmF5KCk7Zm9yKGxldCBsPTA7bDxkLmxlbmd0aDtsKyspYVtOdW1iZXIoZFtsXSldPU51bWJlcihuW2xdKSxhW051bWJlcihkW2xdKStvXT1OdW1iZXIobltsK2QubGVuZ3RoXSl9ZWxzZSBuLmZvckVhY2goKGQsbCk9PmFbTnVtYmVyKGwpXT1OdW1iZXIoZCkpO2xldCBzPVtdO3JldHVybiBhLmZvckVhY2goZD0+cy5wdXNoKGQpKSx7bW9kZTp0Lm1vZGUsdmFsdWU6cixwYWRzOnN9fWVsc2UgcmV0dXJuIHR9LEZsPShlLHQpPT57cnkoZS5pbnB1dHMpO2xldCBuPWR5KGUuaW5wdXRzLHQpO2UuY29tcHV0ZSh1eShlLmlucHV0cyxuKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBybixLbCxqbCxabCxRbCxseSxjeSxZbCxYbCxKbCxlYyx0YyxyYyxuYyxvYyxpYyxhYyxzYyx1YyxkYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt0ZSgpO2FlKCk7Y2UoKTtybj1lPT57aWYod2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiYoIWV8fGUubGVuZ3RoIT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIil9LEtsPShlLHQsbik9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG89ZS5kaW1zLnNsaWNlKCk7ciYmby5zcGxpY2UoMSwwLG8ucG9wKCkpO2xldCBhPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIikscz10Lmtlcm5lbFNoYXBlLnNsaWNlKCksZD10LnN0cmlkZXMuc2xpY2UoKSxsPWE/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxwPXQucGFkcy5zbGljZSgpO2t0LmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4sbyxzLGQsbCxwKTtsZXQgZj1rdC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKG4sbyxkLGwscyxwLHQuYXV0b1BhZCksaD1PYmplY3QuYXNzaWduKHt9LHQpO2E/T2JqZWN0LmFzc2lnbihoLHtrZXJuZWxTaGFwZTpzLHN0cmlkZXM6ZCxwYWRzOnAsZGlsYXRpb25zOmwsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oaCx7a2VybmVsU2hhcGU6cyxzdHJpZGVzOmQscGFkczpwLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgeT1mLnNsaWNlKCk7cmV0dXJuIHkucHVzaCh5LnNwbGljZSgxLDEpWzBdKSxbaCxyP3k6Zl19LGpsPShlLHQpPT57bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIixyPUUuc2l6ZShlKSxvPUUuc2l6ZSh0Lmtlcm5lbFNoYXBlKSxhPVt7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b31dLHM9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcInUzMlwifV07aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBkPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMV0sbD10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0xXSxwPXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMV0sZj10LnBhZHNbdC5wYWRzLmxlbmd0aC0xXSxoPSEhKHArZik7YS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6Zn0pLHMucHVzaCh7bmFtZTpcImt3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3U3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdFbmRcIix0eXBlOlwidTMyXCJ9KTtsZXQgeT0hMTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBfPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sYj10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSx3PXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0sUz10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXTt5PSEhKHcrUyksYS5wdXNoKHt0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpifSx7dHlwZToxMixkYXRhOnd9LHt0eXBlOjEyLGRhdGE6U30pLHMucHVzaCh7bmFtZTpcImtoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoU3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhFbmRcIix0eXBlOlwidTMyXCJ9KX1yZXR1cm5bYSxzLCEwLGgseV19ZWxzZXtpZihuKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgZD1FLmNvbXB1dGVTdHJpZGVzKHQua2VybmVsU2hhcGUpO2EucHVzaCh7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6dC5wYWRzfSx7dHlwZToxMixkYXRhOnQuc3RyaWRlc30pLHMucHVzaCh7bmFtZTpcImtlcm5lbFN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmQubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQucGFkcy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0pO2xldCBsPXQucGFkcy5yZWR1Y2UoKHAsZik9PnArZik7cmV0dXJuW2EscywhIWwsITEsITFdfX0sWmw9KGUsdCxuLHIsbyxhLHMsZCxsLHAsZixoKT0+e2xldCB5PW8uZm9ybWF0PT09XCJOSFdDXCIsXz10LnR5cGUudmFsdWUsYj1OKFwib3V0cHV0XCIsdC50eXBlLnRlbnNvcixyKTtpZihvLmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IHc9XCJcIixTPVwiXCIsJD1cIlwiLHY9bi0oeT8yOjEpO2lmKGY/dz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3Z9XSA9IGluZGljZXNbJHt2fV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7dn1dIDwgMCB8fCB4SW5kaWNlc1ske3Z9XVxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHt2fV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgICAgICB9YDp3PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHthfVxuICAgICAgICAgICAgICAgIH1gLG8ua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IEM9bi0oeT8zOjIpO2g/Uz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske0N9XSA9IGluZGljZXNbJHtDfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7Q31dIDwgMCB8fCB4SW5kaWNlc1ske0N9XSA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7Q31dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCArPSBpMzIodW5pZm9ybXMua3cpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYDpTPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Q31dID0gaW5kaWNlc1ske0N9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgYCwkPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhsKS5kZWNsYXJlVmFyaWFibGVzKHQsYil9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtiLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtffSgke2R9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7U31cbiAgICAgICAgICAgICAgJHt3fVxuICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgICR7c31cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfWVsc2V7aWYoeSl0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IHc9by5rZXJuZWxTaGFwZS5sZW5ndGgsUz1vLnBhZHMubGVuZ3RoLCQ9XCJcIjtyZXR1cm4gcD8kPWBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgJHthfVxuICAgICAgICAgICAgICB9YDokPWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICBgLGBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCxiKX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtiLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHt3fT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtffSgke2R9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDB1OyBqIDwgJHt3LTF9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8gJHtLKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLHcpfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtLKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLHcpfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske3ctMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtuLXd9dTsgaiA8ICR7bn11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqICR7SyhcInVuaWZvcm1zLnN0cmlkZXNcIixgaiAtICR7bi13fXVgLHcpfVxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7bi13fXVdIC0gJHtLKFwidW5pZm9ybXMucGFkc1wiLFwiaiAtIDJ1XCIsUyl9O1xuICAgICAgICAgICAgICAgICAgJHskfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7c31cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfX0sUWw9ZT0+YCR7ZS5mb3JtYXR9OyR7ZS5jZWlsTW9kZX07JHtlLmF1dG9QYWR9OyR7ZS5rZXJuZWxTaGFwZS5sZW5ndGh9YCxseT1lPT5gJHtRbChlKX07JHtlLmNvdW50SW5jbHVkZVBhZH1gLGN5PWU9PmAke1FsKGUpfTske2Uuc3RvcmFnZU9yZGVyfTske2UuZGlsYXRpb25zfWAsWWw9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSksWGw9KGUsdCxuLHIpPT57bGV0W28sYV09S2wodCxyLG4pLHM9UChcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLGQ9cy50eXBlLnZhbHVlLGw9XCJ2YWx1ZSArPSB4X3ZhbDtcIixwPVwiXCI7by5jb3VudEluY2x1ZGVQYWQ/cCs9YHZhbHVlIC89ICR7ZH0odW5pZm9ybXMua2VybmVsU2l6ZSk7YDpwKz1gdmFsdWUgLz0gJHtkfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7bGV0W2YsaCx5LF8sYl09amwoYSxvKTtmLnB1c2goLi4uSCh0LmRpbXMsYSkpO2xldCB3PVtcInJhbmtcIl07cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtyLmNhY2hlS2V5fTske3l9OyR7X307JHtifWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChFLnNpemUoYSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTpTPT5abChTLHMsdC5kaW1zLmxlbmd0aCxhLmxlbmd0aCxvLGwscCwwLGgseSxfLGIpfX0sSmw9ZT0+e2xldCB0PWUuY291bnRfaW5jbHVkZV9wYWQhPT0wLG49WWwoZSk7aWYobi5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtsZXQgcj17Y291bnRJbmNsdWRlUGFkOnQsLi4ubixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ucixjYWNoZUtleTpseShyKX19LGVjPShlLHQpPT57cm4oZS5pbnB1dHMpLGUuY29tcHV0ZShYbChcIkF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSx0Yz17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W119LHJjPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4udGMsY2FjaGVLZXk6dH19LG5jPShlLHQpPT57cm4oZS5pbnB1dHMpLGUuY29tcHV0ZShYbChcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfSxvYz0oZSx0LG4scik9PntsZXRbbyxhXT1LbCh0LHIsbikscz1gXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGAsZD1cIlwiLGw9UChcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLHA9W1wicmFua1wiXSxbZixoLHksXyxiXT1qbChhLG8pO3JldHVybiBmLnB1c2goLi4uSCh0LmRpbXMsYSkpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5jYWNoZUtleX07JHt5fTske199OyR7Yn1gLGlucHV0RGVwZW5kZW5jaWVzOnB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRS5zaXplKGEpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6dz0+WmwodyxsLHQuZGltcy5sZW5ndGgsYS5sZW5ndGgsbyxzLGQsdC5kYXRhVHlwZT09PTEwPy02NTUwNDotMWU1LGgseSxfLGIpfX0saWM9KGUsdCk9PntybihlLmlucHV0cyksZS5jb21wdXRlKG9jKFwiTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sYWM9ZT0+e2xldCB0PWUuc3RvcmFnZV9vcmRlcixuPWUuZGlsYXRpb25zLHI9WWwoZSk7aWYodCE9PTApdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoci5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2xldCBvPXtzdG9yYWdlT3JkZXI6dCxkaWxhdGlvbnM6biwuLi5yLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5vLGNhY2hlS2V5OmN5KG8pfX0sc2M9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi50YyxjYWNoZUtleTp0fX0sdWM9KGUsdCk9PntybihlLmlucHV0cyksZS5jb21wdXRlKG9jKFwiR2xvYmFsTWF4UG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX19KTt2YXIgbXksZnksbGMsY2MscGM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7bXk9KGUsdCk9PntpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkRlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzFdLmRpbXM9PT1lWzJdLmRpbXMpdGhyb3cgbmV3IEVycm9yKFwieC1zY2FsZSBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS5cIik7aWYoZVswXS5kYXRhVHlwZT09PTYmJmUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW4gdGhlIGNhc2Ugb2YgZGVxdWFudGl6aW5nIGludDMyIHRoZXJlIGlzIG5vIHplcm8gcG9pbnQuXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0wJiZlWzFdLmRpbXMubGVuZ3RoIT09MSYmZVsxXS5kaW1zLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihlLmxlbmd0aD4yKXtpZihlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PWVbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobixyKT0+bj09PWVbMl0uZGltc1tyXSkucmVkdWNlKChuLHIpPT5uJiZyLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKX1pZih0LmJsb2NrU2l6ZT4wKXtpZihlWzFdLmRpbXMubGVuZ3RoPT09MHx8ZVsxXS5kaW1zLmxlbmd0aD09PTEmJmVbMV0uZGltc1swXT09PTEpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgc2V0IG9ubHkgZm9yIGJsb2NrIHF1YW50aXphdGlvbi5cIik7aWYoIWVbMV0uZGltcy5tYXAoKG8sYSk9PmE9PT10LmF4aXN8fG89PT1lWzBdLmRpbXNbYV0pLnJlZHVjZSgobyxhKT0+byYmYSwhMCkpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXNcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGJsb2NrIHF1bmF0aXphdGlvbiB0aGUgc2NhbGUgaW5wdXQgcmFuayBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSB4IHJhbmsuXCIpO2xldCBuPWVbMF0uZGltc1t0LmF4aXNdLHI9ZVsxXS5kaW1zW3QuYXhpc107aWYodC5ibG9ja1NpemU8TWF0aC5jZWlsKG4vcil8fHQuYmxvY2tTaXplPk1hdGguY2VpbChuLyhyLTEpLTEpKXRocm93IG5ldyBFcnJvcihcImJsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uXCIpfX0sZnk9KGUsdCk9PntsZXQgbj1FLm5vcm1hbGl6ZUF4aXModC5heGlzLGVbMF0uZGltcy5sZW5ndGgpLHI9ZVswXS5kYXRhVHlwZSxvPXI9PT0zLGE9ZVswXS5kaW1zLHM9ZVsxXS5kYXRhVHlwZSxkPUUuc2l6ZShhKSxsPXI9PT0zfHxyPT09MixwPWw/W01hdGguY2VpbChFLnNpemUoZVswXS5kaW1zKS80KV06ZVswXS5kaW1zLGY9ZVsxXS5kaW1zLGg9ZS5sZW5ndGg+Mj9lWzJdOnZvaWQgMCx5PWg/bD9bTWF0aC5jZWlsKEUuc2l6ZShoLmRpbXMpLzQpXTpoLmRpbXM6dm9pZCAwLF89Zi5sZW5ndGg9PT0wfHxmLmxlbmd0aD09PTEmJmZbMF09PT0xLGI9Xz09PSExJiZmLmxlbmd0aD09PTEsdz1nZShkKSxTPV8mJighbHx8dz09PTQpLCQ9Uz93OjEsdj1TJiYhbD93OjEsVD1QKFwiaW5wdXRcIixsPzEyOnIscC5sZW5ndGgsdiksQz1QKFwic2NhbGVcIixzLGYubGVuZ3RoKSxBPWg/UChcInplcm9fcG9pbnRcIixsPzEyOnIseS5sZW5ndGgpOnZvaWQgMCxrPU4oXCJvdXRwdXRcIixzLGEubGVuZ3RoLCQpLE89W1QsQ107QSYmTy5wdXNoKEEpO2xldCBNPVtwLGZdO2gmJk0ucHVzaCh5KTtsZXQgVj1be3R5cGU6MTIsZGF0YTpkLyR9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uSCguLi5NLGEpXSxGPWo9PntsZXQgbmU9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgJHtqLnJlZ2lzdGVyVW5pZm9ybXMobmUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uTyxrKX1cbiAgICAgICR7ai5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke2ouZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHtsP2BcbiAgICAgICAgICAgIGxldCBpbnB1dCA9ICR7VC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggLyA0XCIpfTtcbiAgICAgICAgICAgIGxldCB4X3ZlYyA9ICR7bz9cInVucGFjazR4STgoaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KGlucHV0KVwifTtcbiAgICAgICAgICAgIGxldCB4X3ZhbHVlID0gJHskPT09MT9cInhfdmVjW2dsb2JhbF9pZHggJSA0XVwiOlwieF92ZWNcIn07YDpgbGV0IHhfdmFsdWUgPSAke1QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtgfTtcblxuICAgICAgICAgIC8vIFNldCBzY2FsZSBpbnB1dFxuICAgICAgICAgICR7Xz9gbGV0IHNjYWxlX3ZhbHVlPSAke0MuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6Yj9gXG4gICAgICAgICAgICBsZXQgc2NhbGVfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtDLmdldEJ5T2Zmc2V0KFwic2NhbGVfaW5kZXhcIil9O2A6YFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7Qy50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke0MuaW5kaWNlc0dldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICR7Qy5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwiaW5kZXhcIil9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke0MuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07YH07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7QT9fP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6Yj9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDpgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXhcIil9O2A6bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtDLmluZGljZXNUb09mZnNldChcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7bD9vP1wiaTMyXCI6XCJ1MzJcIjpULnR5cGUudmFsdWV9KDApO2B9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke2suc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYCR7ay50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkRlcXVhbnRpemVMaW5lYXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOkE/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6RixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvJC82NCkseToxLHo6MX0scHJvZ3JhbVVuaWZvcm1zOlZ9KX19LGxjPShlLHQpPT57bXkoZS5pbnB1dHMsdCksZS5jb21wdXRlKGZ5KGUuaW5wdXRzLHQpKX0sY2M9ZT0+cmUoe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIGh5LGd5LG1jLGZjPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3RlKCk7Y2UoKTtoeT0oZSx0LG4pPT57bGV0IHI9ZT09PXQsbz1lPHQmJm48MCxhPWU+dCYmbj4wO2lmKHJ8fG98fGEpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LGd5PShlLHQsbixyKT0+e2xldCBvPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9uKSksYT1bb10scz1vLGQ9W3t0eXBlOjEyLGRhdGE6c30se3R5cGU6cixkYXRhOmV9LHt0eXBlOnIsZGF0YTpufSwuLi5IKGEpXSxsPXA9PntsZXQgZj1OKFwib3V0cHV0XCIscixhLmxlbmd0aCksaD1mLnR5cGUudmFsdWUseT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0XCIsdHlwZTpofSx7bmFtZTpcImRlbHRhXCIsdHlwZTpofV07cmV0dXJuYFxuICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKGYpfVxuICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke2h9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YH0sZ2V0U2hhZGVyU291cmNlOmwsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnJ9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KX19LG1jPWU9PntsZXQgdD0wLG49MCxyPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLHdlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmaHkodCxuLHIpLGUuY29tcHV0ZShneSh0LG4scixlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciB5eSxieSxoYyxnYyx5Yz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTt5eT0oZSx0LG4scik9PntpZihlIT09XCJub25lXCImJnIhPT1cImkzMlwiJiZyIT09XCJ1MzJcIiYmciE9PVwiZjMyXCIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3J9IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtlfS5gKTtsZXQgbz1ge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWVGMzIgPWAsYT1gO1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3R9LCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWA7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm5gJHt0fT0ke259O2A7Y2FzZVwiYWRkXCI6cmV0dXJuIHI9PT1cImkzMlwifHxyPT09XCJ1MzJcIj9gYXRvbWljQWRkKCYke3R9LCBiaXRjYXN0PCR7cn0+KCR7bn0pKTtgOmBcbiAgICAgICAgICAgICAgJHtvfWJpdGNhc3Q8JHtyfT4ob2xkVmFsdWUpICsgKCR7bn0pJHthfWA7Y2FzZVwibWF4XCI6cmV0dXJuIHI9PT1cImkzMlwifHxyPT09XCJ1MzJcIj9gYXRvbWljTWF4KCYke3R9LCBiaXRjYXN0PCR7cn0+KCR7bn0pKTtgOmBcbiAgICAgICAgICAgICAgICAke299bWF4KGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSksICgke259KSkke2F9YDtjYXNlXCJtaW5cIjpyZXR1cm4gcj09PVwiaTMyXCJ8fHI9PT1cInUzMlwiP2BhdG9taWNNaW4oJiR7dH0sIGJpdGNhc3Q8JHtyfT4oJHtufSkpO2A6YCR7b31taW4oYml0Y2FzdDwke3J9PihvbGRWYWx1ZSksICgke259KSkke2F9YDtjYXNlXCJtdWxcIjpyZXR1cm5gJHtvfShiaXRjYXN0PCR7cn0+KG9sZFZhbHVlKSAqICgke259KSkke2F9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgUmVkdWN0aW9uICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGJ5PShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVsxXS5kaW1zLG89bixhPTEscz1NYXRoLmNlaWwoRS5zaXplKHIpL2EpLGQ9cltyLmxlbmd0aC0xXSxsPUUuc2l6ZUZyb21EaW1lbnNpb24obixkKSxwPVt7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSwuLi5IKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLGY9aD0+e2xldCB5PVAoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPVAoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGEpLGI9dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP0hzKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsYSk7cmV0dXJuYFxuICAgICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxfLGIpfVxuICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgaGFzRHVwbGljYXRlcyA9IGZhbHNlO1xuICBpZiAoJHt0LnJlZHVjdGlvbj09PVwibm9uZVwifSkge1xuICAgIGxldCBuID0gJHtFLnNpemUocil9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSA9IGkgKyAxKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgdmFyIGluZGV4X2kgPSBpMzIoaW5kaWNlc1tpXS54KTtcbiAgICAgICAgdmFyIGluZGV4X2ogPSBpMzIoaW5kaWNlc1tqXS54KTtcbiAgICAgICAgaWYgKGluZGV4X2kgPT0gaW5kZXhfaikge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzRHVwbGljYXRlcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgdmFyIGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGlmICgke3QucmVkdWN0aW9uPT09XCJub25lXCJ9ICYmIGhhc0R1cGxpY2F0ZXMpIHtcbiAgICBpZiAoZ2xvYmFsX2lkeCAhPSAwdSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmRpY2VzX3N0YXJ0ID0gMHU7XG4gIH1cbiAgbGV0IGluZGljZXNfZW5kID0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uO1xuICBmb3IgKHZhciBpID0gaW5kaWNlc19zdGFydDsgaSA8IGluZGljZXNfZW5kOyBpKyspIHtcbiAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc1tpXS54KTtcbiAgICAke2VbMF0uZGltcy5sZW5ndGg9PT0xP2BcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2A6YFxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzW2kgLSBpbmRpY2VzX3N0YXJ0XTtcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlW2kgLSBpbmRpY2VzX3N0YXJ0ICsgdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb25dO2B9XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGlmIChpbmRleCA+PSBpMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IGkzMihkaW1fdmFsdWUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgLWkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IGkzMihkaW1fdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhX29mZnNldCArPSB1MzIoKHUzMihpbmRleCkgKiBlbGVtZW50X2NvdW50X2RpbSkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDB1OyBpIDwgdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHM7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IHVwZGF0ZXNbdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHMgKiBnbG9iYWxfaWR4ICsgaV07XG4gICAgJHt5eSh0LnJlZHVjdGlvbixcIm91dHB1dFtkYXRhX29mZnNldCArIGldXCIsXCJ2YWx1ZVwiLGIudHlwZS52YWx1ZSl9XG4gIH1cblxuICAgICAgfWB9O3JldHVybntuYW1lOlwiU2NhdHRlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHt0LnJlZHVjdGlvbn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOmZ9fSxoYz1lPT5yZSh7cmVkdWN0aW9uOmUucmVkdWN0aW9ufSksZ2M9KGUsdCk9PntlLmNvbXB1dGUoYnkoZS5pbnB1dHMsdCkse2lucHV0czpbZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLG91dHB1dHM6W119KX19KTt2YXIgX3ksd3ksdnksYmMsJHkseHksU3ksVHksQ3ksSXksQXksa3ksX2MsRXksUHksenksT3ksRHksd2MsdmMsJGM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7X3k9KGUsdCk9PntpZihlLmV2ZXJ5KG49Pm4+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09M3x8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xfHxlLmxlbmd0aD09PTUmJmVbMF09PT0xJiZlWzFdPT09MSkpdGhyb3cgbmV3IEVycm9yKGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LHd5PShlLHQsbik9Pnt0LmV2ZXJ5KG89Pm8+PTAmJm88bnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgcj1uZXcgQXJyYXkobikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChvLGEpPT5yW29dPWVbYV0pLHJ9LHZ5PShlLHQsbixyLG8sYSk9PntsZXRbcyxkLGxdPW4+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxwPWVbMF0uZGltcy5sZW5ndGg7aWYocz4wJiZlLmxlbmd0aD5zJiZlW3NdLmRpbXMubGVuZ3RoPjApZVtzXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGY9PmEucHVzaChmKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihkPjAmJmUubGVuZ3RoPmQmJmVbZF0uZGltcy5sZW5ndGg9PT0xJiZlW2RdLmRpbXNbMF0+MCl7aWYoZVtkXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKGY9PnIucHVzaChmKSksci5sZW5ndGghPT0wJiZyLmxlbmd0aCE9PXAmJm4+PTE4JiZyLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtfeShyLHQpLHQuYXhlcy5sZW5ndGg+MCYmd3kocix0LmF4ZXMscCkuZm9yRWFjaCgoZixoKT0+cltoXT1mKX1pZihsPjAmJmUubGVuZ3RoPmwmJmVbbF0uZGltcy5sZW5ndGg9PT0xJiZlW2xdLmRpbXNbMF0+MCYmKGVbbF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goZj0+by5wdXNoKE51bWJlcihmKSkpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1wJiZuPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihyLmxlbmd0aCE9PTAmJnIubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO2lmKG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpfWlmKHR5cGVvZiByPFwidVwiJiZ0eXBlb2YgbzxcInVcIiYmci5sZW5ndGg+MCYmby5sZW5ndGg+cCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSxiYz0oZSx0LG4scik9PmBcbiAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICBsZXQgYmlnID0gKCR7ZX0pICogKCR7dH0pO1xuICBsZXQgd2hvbGUgPSAke3J9KGJpZyAvICgke259KSk7XG4gIGxldCBmcmFjdCA9ICR7cn0oYmlnICUgKCR7bn0pKSAvICR7cn0oJHtufSk7XG4gIHJldHVybiB3aG9sZSArIGZyYWN0O1xuYCwkeT0oZSx0KT0+YGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHt0fSB7IGArKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHhTY2FsZSA8IDEuMCB8fCBmbG9vcih4U2NhbGUpICE9IHhTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICR7dH0oeFJlc2l6ZWQpIC8gJHt0fSh4U2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke2JjKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsXCIsXCJsZW5ndGhSZXNpemVkXCIsdCl9XG4gICAgICAgICAgfVxuICAgICAgICBgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR7YmMoXCJ4UmVzaXplZFwiLFwibGVuZ3RoT3JpZ2luYWwgLSAxXCIsXCJsZW5ndGhSZXNpemVkIC0gMVwiLHQpfVxuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHt0fShyb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7dH0oeFJlc2l6ZWQpICogJHt0fShyb2lFbmQgLSByb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7dH0ocm9pU3RhcnQgKyByb2lFbmQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5gY29uc3Qgb3V0cHV0V2lkdGggPSAke3R9eFNjYWxlICogJHt0fShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke3R9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke3R9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5gcmV0dXJuICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIseHk9KGUsdCxuKT0+YGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7bn0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtufSB7YCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixTeT0oZSx0LG4pPT57bGV0IHI9bmV3IEFycmF5KG4pLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShuKS5maWxsKDEpKSxvPWUubGVuZ3RoPT09MD9yOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChhLHMpPT57clthXT1vW3NdLHJbcytuXT1vW3QubGVuZ3RoK3NdfSkscik6b30sVHk9KGUsdCxuLHIpPT57bGV0IG89W107aWYobi5sZW5ndGg+MClpZihyLmxlbmd0aD4wKXtpZihlLmZvckVhY2goYT0+by5wdXNoKGEpKSxNYXRoLm1heCguLi5yKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTtyLmZvckVhY2goKGEscyk9Pm9bYV09bltzXSl9ZWxzZSBuLmZvckVhY2goYT0+by5wdXNoKGEpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bz1lLm1hcCgoYSxzKT0+TWF0aC5yb3VuZChhKnRbc10pKX1yZXR1cm4gb30sQ3k9KGUsdCxuKT0+e2xldCByPSgoKT0+e3N3aXRjaChuLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiBuLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4ubi5heGVzLm1hcChhPT50W2FdKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi50LE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIG4uYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5uLmF4ZXMubWFwKGE9PnRbYV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnQsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke24ua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTt0LmZpbGwoMSwwLHQubGVuZ3RoKTtsZXQgbz1lLnNsaWNlKCk7cmV0dXJuIG4uYXhlcy5sZW5ndGg+MD8obi5heGVzLmZvckVhY2goYT0+dFthXT1yKSxuLmF4ZXMuZm9yRWFjaChhPT5vW2FdPU1hdGgucm91bmQoZVthXSp0W2FdKSkpOih0LmZpbGwociwwLHQubGVuZ3RoKSxvLmZvckVhY2goKGEscyk9Pm9bc109TWF0aC5yb3VuZChhKnRbc10pKSksb30sSXk9KGUsdCxuLHIsbyk9PmBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtuLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7bi5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke0soXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixyKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtLKFwidW5pZm9ybXMucm9pXCIsXCJpXCIsbyl9O1xuICAgICAgICB2YXIgcm9pX2hpID0gJHtLKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3QubGVuZ3RofWAsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7ZS50eXBlLnZhbHVlfShvdXRwdXRfaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtLKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7SyhcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xuICAgIH1gLEF5PShlLHQsbixyLG8sYSxzKT0+YFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRleDogdTMyO1xuICAgICAgICB2YXIgc2NhbGUgPSAke0soXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixvKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7SyhcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGEpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtLKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke24ubGVuZ3RofWAsYSl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtLKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7SyhcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgICAgaWYgKCEke3N9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgfWAsa3k9KGUsdCk9PmBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtLKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YCxfYz0oZSx0LG4scik9PmUucmFuaz5yP2BcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIix0LFwiY2hhbm5lbFwiKX07XG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbixcImJhdGNoXCIpfTtcbmA6XCJcIixFeT0oZSx0LG4scixvKT0+e2xldFtzLGQsbCxwXT1uLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06WzAsMiwzLDFdLGY9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiAke2Z9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4ocm93LCAke25bZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihjb2wsICR7bltsXX0gLSAxKSlgKX07XG4gICAgICAke19jKGUscCxzLDIpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2Z9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7Zn0gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICB2YXIgY29sOiR7Zn0gPSBvcmlnaW5hbEluZGljZXNbJHtsfV07XG4gICAgICAke3I/YGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke25bZF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtuW2xdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke299O1xuICAgICAgfWA6XCJcIn07XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtuW2RdfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke25bbF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtuLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7cH1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtuLmxlbmd0aD4yP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7c31dKWA6XCIwXCJ9O1xuICAgICAgdmFyIHgxMTogJHtmfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogJHtmfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogJHtmfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHtmfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogJHtmfSA9IGFicyhyb3cgLSAke2Z9KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7Zn0gPSBhYnMoJHtmfShyb3cyKSAtIHJvdyk7XG4gICAgICB2YXIgZHkxOiAke2Z9ID0gYWJzKGNvbCAtICR7Zn0oY29sMSkpO1xuICAgICAgdmFyIGR5MjogJHtmfSA9IGFicygke2Z9KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gfSxQeT0oZSx0LG4scixvLGEscyxkLGwscCk9PntsZXQgZj1uLmxlbmd0aD09PTIsaD0hMCxbeSxfXT1mP1swLDFdOmg/WzIsM106WzEsMl0sYj1lLnR5cGUudmFsdWUsdz1TPT57bGV0ICQ9Uz09PXk/XCJyb3dcIjpcImNvbFwiO3JldHVybmBcbiAgICAgIGZuICR7JH1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtifSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsUyl9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7Yn0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke29bU119LFxuICAgICAgICAke3JbU119LCAke25bU119LCAke2FbU119LCAke2FbU119ICsgJHtuLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHtifSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHtkfSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7bltTXX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtsfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8JHtifSwgND4gPSBhcnJheTwke2J9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAkeyR9OiAke2J9ID0gb3JpZ2luYWxJZHggKyAke2J9KGkpO1xuICAgICAgICAgIGlmICgkeyR9IDwgMCB8fCAkeyR9ID49ICR7bltTXX0pIHtcbiAgICAgICAgICAgICR7cD9gY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDpkP2ByZXR1cm4gJHtsfTtgOmAkeyR9ID0gbWF4KDAsIG1pbigkeyR9LCAke25bU119IC0gMSkpO2B9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc19jb3B5XCIsUyxgdTMyKCR7JH0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHtTPT09eT9lLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNfY29weVwiKTpcInJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKVwifTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWB9O3JldHVybmBcbiAgICAke3coeSl9O1xuICAgICR7dyhfKX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7Yn0pIC0+IGFycmF5PCR7Yn0sIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke2J9LCA0PiA9IGFycmF5PCR7Yn0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHtifSA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHtifSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke2J9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7c30gKiBvbmVQbHVzQWJzUyAtIDUgKiAke3N9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7c30pICogb25lUGx1c0Fic1MgLSA0ICogJHtzfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7c30gKyAyKSAqIGFic1MgLSAoJHtzfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7c30gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke3N9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7c30gKiB0d29NaW51c0Fic1MgLSA1ICogJHtzfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHtzfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtzfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHtifSwgND4sIGNvZWZzOiBhcnJheTwke2J9LCA0PikgLT4gJHtifSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke2J9ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2J9IHtcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGB9LHp5PShlLHQsbixyLG8pPT57bGV0W3MsZCxsLHAsZl09bi5sZW5ndGg9PT0zP1stMSwwLDEsMiwtMV06WzAsMiwzLDQsMV0saD1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke2h9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4oZGVwdGgsICR7bltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGhlaWdodCwgJHtuW2xdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHAsYG1heCgwLCBtaW4od2lkdGgsICR7bltwXX0gLSAxKSlgKX07XG4gICAgICAke19jKGUsZixzLDMpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtofSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7aH0gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICB2YXIgaGVpZ2h0OiR7aH0gPSBvcmlnaW5hbEluZGljZXNbJHtsfV07XG4gICAgICB2YXIgd2lkdGg6JHtofSA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcbiAgICAgICR7cj9gaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke25bZF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtuW2xdfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke25bcF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke299O1xuICAgICAgICB9YDpcIlwifTtcblxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtuW2RdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke25bbF19IC0gMSkpO1xuICAgICAgd2lkdGggPSBtYXgoMCwgbWluKHdpZHRoLCAke25bcF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke24ubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHtmfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke24ubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHtzfV0pYDpcIjBcIn07XG5cbiAgICAgIHZhciB4MTExOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDEyMTogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIxMjogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgZHgxOiAke2h9ID0gYWJzKGRlcHRoIC0gJHtofShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7aH0gPSBhYnMoJHtofShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtofSA9IGFicyhoZWlnaHQgLSAke2h9KGhlaWdodDEpKTtcbiAgICAgIHZhciBkeTI6ICR7aH0gPSBhYnMoJHtofShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke2h9ID0gYWJzKHdpZHRoIC0gJHtofSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7aH0gPSBhYnMoJHtofSh3aWR0aDIpIC0gd2lkdGgpO1xuICAgICAgaWYgKGRlcHRoMSA9PSBkZXB0aDIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcbiAgICAgICAgZHoxID0gMC41O1xuICAgICAgICBkejIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMTEgKiBkeDIgKiBkeTIgKiBkejIgKyB4MTEyICogZHgyICogZHkyICogZHoxICsgeDEyMSAqIGR4MiAqIGR5MSAqZHoyICsgeDEyMiAqIGR4MiAqIGR5MSAqIGR6MSArXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XG4gICAgfWB9LE95PShlLHQsbixyLG8sYSk9PntsZXQgcz1lLmRpbXMsZD1TeShhLHQuYXhlcyxzLmxlbmd0aCksbD1UeShzLHIsbyx0LmF4ZXMpLHA9ci5zbGljZSgpO3IubGVuZ3RoPT09MCYmKHA9cy5tYXAoKHYsVCk9PnY9PT0wPzE6bFtUXS92KSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYobD1DeShzLHAsdCkpKTtsZXQgZj1OKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxsLmxlbmd0aCksaD1QKFwiaW5wdXRcIixlLmRhdGFUeXBlLHMubGVuZ3RoKSx5PUUuc2l6ZShsKSxfPXMubGVuZ3RoPT09bC5sZW5ndGgmJnMuZXZlcnkoKHYsVCk9PnY9PT1sW1RdKSxiPXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLHc9dC5leHRyYXBvbGF0aW9uVmFsdWUsUz1oLnR5cGUudmFsdWUsJD12PT5gXG4gICAgICAke18/XCJcIjpgXG4gICAgICAkeyR5KHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsUyl9O1xuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke2t5KGgscyl9O1xuICAgICAgICAgICAgICAke3h5KHQubmVhcmVzdE1vZGUsbixTKX07XG4gICAgICAgICAgICAgICR7QXkoaCxmLHMsbCxwLmxlbmd0aCxkLmxlbmd0aCxiKX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke0l5KGYscyxsLHAubGVuZ3RoLGQubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpPT57aWYocy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQpcmV0dXJuYCR7RXkoaCxmLHMsYix3KX1gO2lmKHMubGVuZ3RoPT09M3x8cy5sZW5ndGg9PT01KXJldHVybmAke3p5KGgsZixzLGIsdyl9YDt0aHJvdyBFcnJvcihcIkxpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgICAgJHsoKCk9PntpZihzLmxlbmd0aD09PTJ8fHMubGVuZ3RoPT09NClyZXR1cm5gJHtQeShoLGYscyxsLHAsZCx0LmN1YmljQ29lZmZBLGIsdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9YDt0aHJvdyBFcnJvcihcIkN1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XG4gICAgICBgfVxuICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2NhbGVzXCIsXCJmMzJcIixwLmxlbmd0aCkucmVnaXN0ZXJVbmlmb3JtKFwicm9pXCIsXCJmMzJcIixkLmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyhoLGYpfVxuICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAke18/XCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcIjpgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Zi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aC50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7aC5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7cy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQ/XCJiaWxpbmVhckludGVycG9sYXRpb25cIjpcInRyaWxpbmVhckludGVycG9sYXRpb25cIn0ob3V0cHV0X2luZGljZXMpO2A7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XG5gfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke259fCR7cC5sZW5ndGg+MD90Lm1vZGU9PT1cImN1YmljXCI/cDpwLmxlbmd0aDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2QubGVuZ3RoPjA/ZDpcIlwifXwke199fCR7dC5tb2RlPT09XCJuZWFyZXN0XCI/cy5sZW5ndGg6c31gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LC4uLkgocyxsKV19KX19LER5PWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sd2M9KGUsdCk9PntsZXQgbj1bXSxyPVtdLG89W10sYT1EeShlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTt2eShlLmlucHV0cyx0LGEsbixyLG8pLGUuY29tcHV0ZShPeShlLmlucHV0c1swXSx0LGEsbixyLG8pLHtpbnB1dHM6WzBdfSl9LHZjPWU9PntsZXQgdD1lLmFudGlhbGlhcyxuPWUuYXhlcyxyPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGE9ZS5leGNsdWRlT3V0c2lkZSE9PTAscz1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGw9ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiByZSh7YW50aWFsaWFzOnQsYXhlczpuLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnIsY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6bCxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIEJ5LE15LHhjLFNjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0J5PShlLHQpPT57bGV0W24scixvLGFdPWUse251bUhlYWRzOnMscm90YXJ5RW1iZWRkaW5nRGltOmR9PXQ7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke24uZGltcy5sZW5ndGh9YCk7aWYoIUUuYXJlRXF1YWwoci5kaW1zLFtdKSYmIUUuYXJlRXF1YWwoci5kaW1zLFsxXSkmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke3IuZGltcy5sZW5ndGh9YCk7aWYoby5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7by5kaW1zLmxlbmd0aH1gKTtpZihhLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHthLmRpbXMubGVuZ3RofWApO2lmKCFFLmFyZUVxdWFsKG8uZGltcyxhLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7aWYoZD4wJiZzPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWRcIik7bGV0IGw9bi5kaW1zWzBdLHA9bi5kaW1zW24uZGltcy5sZW5ndGgtMl0sZj1vLmRpbXNbMF0saD1FLnNpemVGcm9tRGltZW5zaW9uKG4uZGltcywxKS9wLHk9ZD09PTA/by5kaW1zWzFdKjI6aC9zO2lmKGQ+eSl0aHJvdyBuZXcgRXJyb3IoXCJyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemVcIik7aWYoci5kaW1zLmxlbmd0aD09PTIpe2lmKGwhPT1yLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtyLmRpbXNbMF19YCk7aWYocCE9PXIuZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7ci5kaW1zWzFdfWApfWlmKHkvMiE9PW8uZGltc1sxXSYmZC8yIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke28uZGltc1sxXX1gKTtpZihwPmYpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpfSxNeT0oZSx0KT0+e2xldHtpbnRlcmxlYXZlZDpuLG51bUhlYWRzOnIscm90YXJ5RW1iZWRkaW5nRGltOm8sc2NhbGU6YX09dCxzPWVbMF0uZGltc1swXSxkPUUuc2l6ZUZyb21EaW1lbnNpb24oZVswXS5kaW1zLDEpLGw9ZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMl0scD1kL2wsZj1lWzJdLmRpbXNbMV0saD1vPT09MD9mKjI6cC9yLHk9bmV3IEFycmF5KHMsbCxwL2gsaC1mKSxfPUUuY29tcHV0ZVN0cmlkZXMoeSksYj1be3R5cGU6MSxkYXRhOmF9LHt0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpffSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09Mz9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCxwLGgsMV19KTpbXSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09ND9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCxoLGwqaCwxXX0pOltdLC4uLkgoZVswXS5kaW1zLGVbMV0uZGltcyxlWzJdLmRpbXMsZVszXS5kaW1zLGVbMF0uZGltcyldLHc9Uz0+e2xldCAkPVAoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksdj1QKFwicG9zaXRpb25faWRzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxUPVAoXCJjb3NfY2FjaGVcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEM9UChcInNpbl9jYWNoZVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCksQT1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKTtyZXR1cm4gUy5yZWdpc3RlclVuaWZvcm1zKFt7bmFtZTpcInNjYWxlXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImdsb2JhbF9zaGFwZVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6eS5sZW5ndGh9LHtuYW1lOlwiZ2xvYmFsX3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofSx7bmFtZTpcImlucHV0X291dHB1dF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH1dKSxgXG4gICAgICAgICR7Uy5kZWNsYXJlVmFyaWFibGVzKCQsdixULEMsQSl9XG5cbiAgICAgICAgJHtTLm1haW5TdGFydChFdCl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke1QubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInNpemVcIil9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3YuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJic25oLnh5XCIsTihcIlwiLHYudHlwZS50ZW5zb3IsMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7di5nZXRCeU9mZnNldChcInBvc2l0aW9uX2lkc19pZHhcIil9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7bn0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7bn0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1QuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9IC1cbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7Qy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJpXCIsXCJyZVwiKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtDLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSArXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke1QuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwialwiLFwiaW1cIil9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJrXCIsJC5nZXRCeU9mZnNldChcImtcIikpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUm90YXJ5RW1iZWRkaW5nXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6cmUoe2ludGVybGVhdmVkOm59KS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6dyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRS5zaXplKHkpL0V0KX0scHJvZ3JhbVVuaWZvcm1zOmJ9KX19LHhjPShlLHQpPT57QnkoZS5pbnB1dHMsdCksZS5jb21wdXRlKE15KGUuaW5wdXRzLHQpKX19KTt2YXIgUnksVXksVGMsQ2M9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO1J5PWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0sbj1lWzFdLHI9ZVsyXTtpZih0LmRhdGFUeXBlIT09bi5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PXIuZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0sYT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihuLmRpbXNbbi5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYobi5kaW1zW24uZGltcy5sZW5ndGgtMl0hPT1hKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IHM9ZVszXTtpZihzLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYocy5kaW1zW3MuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBzPWVbNF07aWYocy5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKHMuZGltc1tzLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFV5PShlLHQsbixyKT0+e2xldCBvPXQuc2ltcGxpZmllZCxhPWVbMF0uZGltcyxzPUUuc2l6ZShhKSxkPWEsbD1zLHA9YS5zbGljZSgtMSlbMF0sZj1yP2Euc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLGg9IW8mJmUubGVuZ3RoPjMseT1lLmxlbmd0aD40LF89ciYmbj4xLGI9ciYmbj4yLHc9bj4zLFM9NjQsJD1nZShwKSx2PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sVD1BPT57bGV0IGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sTz1bUChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcywkKSxQKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLCQpLFAoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLCQpXTtoJiZPLnB1c2goUChcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcywkKSkseSYmTy5wdXNoKFAoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsJCkpLE8ucHVzaChOKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLCQpKSxfJiZPLnB1c2goTihcIm1lYW5fb3V0cHV0XCIsMSxmKSksYiYmTy5wdXNoKE4oXCJpbnZfc3RkX291dHB1dFwiLDEsZikpLHcmJk8ucHVzaChOKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsZCwkKSk7bGV0IE09X2UoZVswXS5kYXRhVHlwZSksVj1fZSgxLCQpO3JldHVybmBcblxuICAgICAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5PKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke1Z9LCAke1N9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7Vn0sICR7U30+O1xuXG4gICAgICAke0EubWFpblN0YXJ0KFtTLDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7U307XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke1N9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHtTLTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7eT9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOk0rXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHt3P1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7UHQoTSwkLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHtTfTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtLZShcInN1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7S2UoXCJzcXVhcmVfc3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtfP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7Yj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7TX0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtNfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2g/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sQz1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIG4+MSYmQy5wdXNoKHtkaW1zOmYsZGF0YVR5cGU6MX0pLG4+MiYmQy5wdXNoKHtkaW1zOmYsZGF0YVR5cGU6MX0pLG4+MyYmQy5wdXNoKHtkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAkeyR9OyR7X307JHtifTske3d9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgoQSxrKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6VCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6QyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL3ApfSxwcm9ncmFtVW5pZm9ybXM6dn0pfX0sVGM9KGUsdCk9PntSeShlLmlucHV0cyk7bGV0IHI9WzBdO2Uub3V0cHV0Q291bnQ+MSYmci5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJnIucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZyLnB1c2goMyksZS5jb21wdXRlKFV5KGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6cn0pfX0pO3ZhciBOeSxubixWeSxJYyxXeSxMeSxBYyxrYyxFYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtOeT0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChuLHIpPT57aWYoZVtyKzFdLmRhdGFUeXBlIT09NiYmZVtyKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7cn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LG5uPShlLHQpPT57bGV0IG49W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHI9Pm4ucHVzaChOdW1iZXIocikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gocj0+bi5wdXNoKE51bWJlcihyKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gbn0sVnk9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgbj1ubihlLDEpLHI9bm4oZSwyKSxvPW5uKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLHJlKHtzdGFydHM6bixlbmRzOnIsYXhlczpvfSl9ZWxzZSByZXR1cm4gdH0sSWM9KGUsdCxuLHIsbyk9PntsZXQgYT1lO3JldHVybiBlPDAmJihhKz1uW3JbdF1dKSxvW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihhLG5bclt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4oYSxuW3JbdF1dKSl9LFd5PShlLHQsbik9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke24ubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtLKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke0soXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7SyhcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7SyhcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsTHk9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1FLnNpemUobiksbz10LmF4ZXMubGVuZ3RoPjA/RS5ub3JtYWxpemVBeGVzKHQuYXhlcyxuLmxlbmd0aCk6Wy4uLkFycmF5KG4ubGVuZ3RoKS5rZXlzKCldLGE9bm4oZSw0KTthLmZvckVhY2goJD0+JCE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksYS5sZW5ndGg9PT0wJiYoYT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IHM9dC5zdGFydHMubWFwKCgkLHYpPT5JYygkLHYsbixvLGEpKSxkPXQuZW5kcy5tYXAoKCQsdik9PkljKCQsdixuLG8sYSkpO2lmKG8ubGVuZ3RoIT09cy5sZW5ndGh8fG8ubGVuZ3RoIT09ZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09bi5sZW5ndGgpZm9yKGxldCAkPTA7JDxuLmxlbmd0aDsrKyQpby5pbmNsdWRlcygkKXx8KHMuc3BsaWNlKCQsMCwwKSxkLnNwbGljZSgkLDAsblskXSksYS5zcGxpY2UoJCwwLDEpKTtsZXQgbD1hLm1hcCgkPT5NYXRoLnNpZ24oJCkpO2EuZm9yRWFjaCgoJCx2LFQpPT57aWYoJDwwKXtsZXQgQz0oZFt2XS1zW3ZdKS8kLEE9c1t2XSxrPUErQyphW3ZdO3Nbdl09ayxkW3ZdPUEsVFt2XT0tJH19KTtsZXQgcD1uLnNsaWNlKDApO28uZm9yRWFjaCgoJCx2KT0+e3BbJF09TWF0aC5jZWlsKChkWyRdLXNbJF0pL2FbJF0pfSk7bGV0IGY9e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSxoPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHAubGVuZ3RoKSx5PVAoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksXz1FLnNpemUocCksYj1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6cy5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDphLmxlbmd0aH1dLHc9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpzfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSwuLi5IKGVbMF0uZGltcyxwKV0sUz0kPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhiKS5kZWNsYXJlVmFyaWFibGVzKHksaCl9XG4gICAgICAgICR7V3koeSxoLG4pfVxuICAgICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7aC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHtoLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHkuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bC5sZW5ndGh9XyR7cy5sZW5ndGh9XyR7YS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W2ZdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6d30pfX0sQWM9KGUsdCk9PntOeShlLmlucHV0cyx0KTtsZXQgbj1WeShlLmlucHV0cyx0KTtlLmNvbXB1dGUoTHkoZS5pbnB1dHMsbikse2lucHV0czpbMF19KX0sa2M9ZT0+e2xldCB0PWUuc3RhcnRzLG49ZS5lbmRzLHI9ZS5heGVzO3JldHVybiByZSh7c3RhcnRzOnQsZW5kczpuLGF4ZXM6cn0pfX0pO3ZhciBHeSxIeSxQYyx6YyxPYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y3QoKTtjZSgpO0d5PWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LEh5PShlLHQpPT57bGV0IG49ZS5pbnB1dHNbMF0scj1uLmRpbXMsbz1FLnNpemUociksYT1yLmxlbmd0aCxzPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsYSksZD1zPHIubGVuZ3RoLTEsbCxwPVtdO2Q/KHA9QXJyYXkuZnJvbSh7bGVuZ3RoOmF9LChPLE0pPT5NKSxwW3NdPWEtMSxwW2EtMV09cyxsPWUuY29tcHV0ZShPZShuLHApLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xXX0pWzBdKTpsPW47bGV0IGY9bC5kaW1zLGg9ZlthLTFdLHk9by9oLF89Z2UoaCksYj1oL18sdz02NDt5PT09MSYmKHc9MjU2KTtsZXQgUz0oTyxNKT0+TT09PTQ/YG1heChtYXgoJHtPfS54LCAke099LnkpLCBtYXgoJHtPfS56LCAke099LncpKWA6TT09PTI/YG1heCgke099LngsICR7T30ueSlgOk09PT0zP2BtYXgobWF4KCR7T30ueCwgJHtPfS55KSwgJHtPfS56KWA6TywkPVAoXCJ4XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksdj1OKFwicmVzdWx0XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksVD0kLnR5cGUudmFsdWUsQz1fZShsLmRhdGFUeXBlKT09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke1R9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHtUfSgtNjU1MDQuMGgpO2AsQT1PPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke1R9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHtUfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7VH0sICR7d30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHtUfSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke1R9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7Ty5yZWdpc3RlclVuaWZvcm0oXCJwYWNrZWRDb2xzXCIsXCJpMzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICAgICAgJHtPLm1haW5TdGFydCh3KX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7d307XG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcbiAgICAgICAgJHtDfVxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke1R9KCR7UyhcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke1R9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke1R9KCR7S2UoXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWAsaz1lLmNvbXB1dGUoe25hbWU6XCJTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7X307JHt3fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpmLGRhdGFUeXBlOmwuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Onl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6NixkYXRhOmJ9XX0pLGdldFNoYWRlclNvdXJjZTpBfSx7aW5wdXRzOltsXSxvdXRwdXRzOltkPy0xOjBdfSlbMF07ZCYmZS5jb21wdXRlKE9lKGsscCkse2lucHV0czpba119KX0sUGM9KGUsdCk9PntHeShlLmlucHV0cyksSHkoZSx0KX0semM9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgRGMsRnkscXksS3ksQmMsTWM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO0RjPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxGeT1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihEYyhlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LHF5PShlLHQpPT57bGV0IG49W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5wdXNoKGVbcl0qdFtyXSk7cmV0dXJuIG59LEt5PShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9dD8/RGMoZVsxXSksbz1xeShuLHIpLGE9RS5zaXplKG8pLHM9ZVswXS5kYXRhVHlwZSxkPVAoXCJpbnB1dFwiLHMsbi5sZW5ndGgpLGw9TihcIm91dHB1dFwiLHMsby5sZW5ndGgpLHA9Zj0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7ZC5pbmRpY2VzKC4uLm4pfTtcbiAgICAgICR7Zi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cbiAgICAgICR7Zi5tYWluU3RhcnQoKX1cbiAgICAgICR7Zi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtkLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2QuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6YX0sLi4uSChlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOnB9fSxCYz1lPT57RnkoZS5pbnB1dHMpLGUuY29tcHV0ZShLeShlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIganksWnksUmMsVWM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO2p5PShlLHQsbixyLG8pPT57bGV0IGE9TihcIm91dHB1dF9kYXRhXCIsbyxuLmxlbmd0aCw0KSxzPVAoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksZD1QKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLGw9UChcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxwLGY9KGgseSxfKT0+YHNlbGVjdCgke3l9LCAke2h9LCAke199KWA7aWYoIXIpcD1hLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGYocy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCBoPSh5LF8sYj1cIlwiKT0+e2xldCB3PWBhX2RhdGFbaW5kZXhfYSR7X31dW2NvbXBvbmVudF9hJHtffV1gLFM9YGJfZGF0YVtpbmRleF9iJHtffV1bY29tcG9uZW50X2Ike199XWAsJD1gYm9vbChjX2RhdGFbaW5kZXhfYyR7X31dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7X30gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHthLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke199ID0gJHtzLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGEpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7X30gPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsYSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxhKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7X30gPSBvZmZzZXRfYSR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtffSA9IG9mZnNldF9iJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke199ID0gb2Zmc2V0X2Eke199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike199ID0gb2Zmc2V0X2Ike199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke199ID0gb2Zmc2V0X2Mke199ICUgNHU7XG4gICAgICAgICAgICAke3l9WyR7X31dID0gJHtifSgke2YodyxTLCQpfSk7XG4gICAgICAgICAgYH07bz09PTk/cD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7aChcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtoKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2goXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7aChcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpwPWBcbiAgICAgICAgICAgICR7aChcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke2goXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtoKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7aChcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobCxzLGQsYSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtwfVxuICAgICAgfWB9LFp5PWU9PntsZXQgdD1lWzFdLmRpbXMsbj1lWzJdLmRpbXMscj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGE9IShFLmFyZUVxdWFsKHQsbikmJkUuYXJlRXF1YWwobixyKSkscz10LGQ9RS5zaXplKHQpO2lmKGEpe2xldCBwPXJ0LmNhbGNTaGFwZShydC5jYWxjU2hhcGUodCxuLCExKSxyLCExKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO3M9cCxkPUUuc2l6ZShzKX1sZXQgbD1NYXRoLmNlaWwoZC80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwPT5qeShwLGUscyxhLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmx9LC4uLkgocix0LG4scyldfSl9fSxSYz1lPT57ZS5jb21wdXRlKFp5KGUuaW5wdXRzKSl9fSk7dmFyIE5jLFZjPUcoKCk9PntcInVzZSBzdHJpY3RcIjtfdSgpO3FyKCk7JHUoKTtTdSgpO2RkKCk7d2QoKTt4ZCgpO05kKCk7cWQoKTtaZCgpO1hkKCk7bmwoKTthbCgpO3VsKCk7Y2woKTtmbCgpO3lsKCk7d2woKTt4bCgpO0NsKCk7RGwoKTtSbCgpO05sKCk7V2woKTtIbCgpO1NvKCk7cWwoKTtkYygpO3BjKCk7ZmMoKTt5YygpO0hyKCk7JGMoKTtTYygpO0NjKCk7RWMoKTtPYygpO0NvKCk7TWMoKTtjdCgpO2pyKCk7VWMoKTtOYz1uZXcgTWFwKFtbXCJBYnNcIixbVHVdXSxbXCJBY29zXCIsW0N1XV0sW1wiQWNvc2hcIixbSXVdXSxbXCJBZGRcIixbbGRdXSxbXCJBcmdNYXhcIixbYnUsY29dXSxbXCJBcmdNaW5cIixbeXUsY29dXSxbXCJBc2luXCIsW0F1XV0sW1wiQXNpbmhcIixba3VdXSxbXCJBdGFuXCIsW0V1XV0sW1wiQXRhbmhcIixbUHVdXSxbXCJBdHRlbnRpb25cIixbd3VdXSxbXCJBdmVyYWdlUG9vbFwiLFtlYyxKbF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFt2dV1dLFtcIkJpYXNBZGRcIixbeHVdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW3VkXV0sW1wiQ2FzdFwiLFtPdSx6dV1dLFtcIkNlaWxcIixbQnVdXSxbXCJDbGlwXCIsW0R1XV0sW1wiQ29uY2F0XCIsW3ZkLCRkXV0sW1wiQ29udlwiLFt3byxfb11dLFtcIkNvbnZUcmFuc3Bvc2VcIixbRmQsR2RdXSxbXCJDb3NcIixbTXVdXSxbXCJDb3NoXCIsW1J1XV0sW1wiQ3VtU3VtXCIsW0tkLGpkXV0sW1wiRGVwdGhUb1NwYWNlXCIsW1FkLFlkXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFtsYyxjY11dLFtcIkRpdlwiLFtjZF1dLFtcIkVpbnN1bVwiLFt0bCxybF1dLFtcIkVsdVwiLFtVdSx0cl1dLFtcIkVxdWFsXCIsW3BkXV0sW1wiRXJmXCIsW051XV0sW1wiRXhwXCIsW1Z1XV0sW1wiRXhwYW5kXCIsW2lsXV0sW1wiRmFzdEdlbHVcIixbc2xdXSxbXCJGbG9vclwiLFtXdV1dLFtcIkZ1c2VkQ29udlwiLFt3byxfb11dLFtcIkdhdGhlclwiLFtsbCxkbF1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW19sLGJsXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbaGwsZ2xdXSxbXCJHYXRoZXJORFwiLFtwbCxtbF1dLFtcIkdlbHVcIixbTHVdXSxbXCJHZW1tXCIsWyRsLHZsXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbbmMscmNdXSxbXCJHbG9iYWxNYXhQb29sXCIsW3VjLHNjXV0sW1wiR3JlYXRlclwiLFtnZF1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW2JkXV0sW1wiR3JpZFNhbXBsZVwiLFtTbCxUbF1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbT2xdXSxbXCJIYXJkU2lnbW9pZFwiLFtRdSxadV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtNbF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtVbF1dLFtcIkxlYWt5UmVsdVwiLFtHdSx0cl1dLFtcIkxlc3NcIixbeWRdXSxbXCJMZXNzT3JFcXVhbFwiLFtfZF1dLFtcIkxvZ1wiLFtpZF1dLFtcIk1hdE11bFwiLFtWbF1dLFtcIk1hdE11bE5CaXRzXCIsW0xsLEdsXV0sW1wiTWF4UG9vbFwiLFtpYyxhY11dLFtcIk11bFwiLFttZF1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtrbCxBbF1dLFtcIk5lZ1wiLFtGdV1dLFtcIk5vdFwiLFtIdV1dLFtcIlBhZFwiLFtGbF1dLFtcIlBvd1wiLFtmZF1dLFtcIlF1aWNrR2VsdVwiLFthZCx0cl1dLFtcIlJhbmdlXCIsW21jXV0sW1wiUmVjaXByb2NhbFwiLFtxdV1dLFtcIlJlZHVjZU1pblwiLFtjdV1dLFtcIlJlZHVjZU1lYW5cIixbYXVdXSxbXCJSZWR1Y2VNYXhcIixbbHVdXSxbXCJSZWR1Y2VTdW1cIixbbXVdXSxbXCJSZWR1Y2VQcm9kXCIsW3B1XV0sW1wiUmVkdWNlTDFcIixbc3VdXSxbXCJSZWR1Y2VMMlwiLFt1dV1dLFtcIlJlZHVjZUxvZ1N1bVwiLFtodV1dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFtkdV1dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtmdV1dLFtcIlJlbHVcIixbS3VdXSxbXCJSZXNpemVcIixbd2MsdmNdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbeGNdXSxbXCJTY2F0dGVyTkRcIixbZ2MsaGNdXSxbXCJTaWdtb2lkXCIsW2p1XV0sW1wiU2luXCIsW1l1XV0sW1wiU2luaFwiLFtYdV1dLFtcIlNsaWNlXCIsW0FjLGtjXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtUY11dLFtcIlNwbGl0XCIsW0VsLFBsXV0sW1wiU3FydFwiLFtKdV1dLFtcIlNvZnRtYXhcIixbUGMsemNdXSxbXCJTdWJcIixbaGRdXSxbXCJUYW5cIixbZWRdXSxbXCJUYW5oXCIsW3JkXV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW29kLHRyXV0sW1wiVGlsZVwiLFtCY11dLFtcIlRyYW5zcG9zZVwiLFtLcyxqc11dLFtcIldoZXJlXCIsW1JjXV1dKX0pO3ZhciBvbixXYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt0dCgpO2NlKCk7b249Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxuKXt0aGlzLnJlcG8uc2V0KHQsbil9cnVuKHQsbixyLG8sYSl7TmUodC5wcm9ncmFtSW5mby5uYW1lKTtsZXQgcz10aGlzLmJhY2tlbmQuZGV2aWNlLGQ9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpO2xldCBsPVtdO2ZvcihsZXQgZiBvZiBuKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmYuYnVmZmVyfX0pO2ZvcihsZXQgZiBvZiByKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmYuYnVmZmVyfX0pO2EmJmwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTphfSk7bGV0IHA9cy5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpsLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IGY9e2tlcm5lbElkOnRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsY29tcHV0ZVBpcGVsaW5lOnQuY29tcHV0ZVBpcGVsaW5lLGJpbmRHcm91cDpwLGRpc3BhdGNoR3JvdXA6b307dGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKGYpfWQuc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpLGQuc2V0QmluZEdyb3VwKDAscCksZC5kaXNwYXRjaFdvcmtncm91cHMoLi4ubyksdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuYmFja2VuZC5mbHVzaCgpLEJlKHQucHJvZ3JhbUluZm8ubmFtZSl9ZGlzcG9zZSgpe31idWlsZCh0LG4pe05lKHQubmFtZSk7bGV0IHI9dGhpcy5iYWNrZW5kLmRldmljZSxvPVtdO1t7ZmVhdHVyZTpcInNoYWRlci1mMTZcIixleHRlbnNpb246XCJmMTZcIn0se2ZlYXR1cmU6XCJzdWJncm91cHNcIixleHRlbnNpb246XCJzdWJncm91cHNcIn0se2ZlYXR1cmU6XCJzdWJncm91cHMtZjE2XCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzX2YxNlwifV0uZm9yRWFjaChoPT57ci5mZWF0dXJlcy5oYXMoaC5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHtoLmV4dGVuc2lvbn07YCl9KTtsZXQgcz1GcyhuLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxkPXQuZ2V0U2hhZGVyU291cmNlKHMpLGw9YCR7by5qb2luKGBcbmApfVxuJHtzLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2R9YCxwPXIuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgZj1yLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOnAsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBCZSh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTpmLHVuaWZvcm1WYXJpYWJsZXNJbmZvOnMudmFyaWFibGVzSW5mb319bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngscj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLGE9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYobjw9YSYmcjw9YSYmbzw9YSlyZXR1cm5bbixyLG9dO2xldCBzPW4qcipvLGQ9TWF0aC5jZWlsKE1hdGguc3FydChzKSk7aWYoZD5hKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQocykpLGQ+YSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgUXksWXksSW8sQW8sYW4sTGM9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7dGUoKTt0dCgpO0puKCk7V3MoKTtWYygpO1djKCk7UXk9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCBuPVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKXtsZXQgbz1lW3JdLmRhdGFUeXBlO3N3aXRjaCh0W3JdKXtjYXNlXCJub25lXCI6e24ucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e24ucHVzaChgJHtvfWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IGE9ZVtyXS5kaW1zLmxlbmd0aDtuLnB1c2goYCR7b307JHthfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IGE9ZVtyXS5kaW1zLmpvaW4oXCIsXCIpO24ucHVzaChgJHtvfTske2F9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFtyXX1gKX19cmV0dXJuIG4uam9pbihcInxcIil9LFl5PShlLHQsbik9PntsZXQgcj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihyKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLHIrPVwiOlwiK24rYDoke1F5KHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAscn0sSW89Y2xhc3N7Y29uc3RydWN0b3IodCl7dCYmKHRoaXMuYXJjaGl0ZWN0dXJlPXQuYXJjaGl0ZWN0dXJlLHRoaXMudmVuZG9yPXQudmVuZG9yKX1pc0FyY2hpdGVjdHVyZSh0KXtyZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmU9PT10fWlzVmVuZG9yKHQpe3JldHVybiB0aGlzLnZlbmRvcj09PXR9fSxBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKSx0aGlzLnN1Ymdyb3Vwc0YxNlN1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKTtsZXQgbj10LmxpbWl0czshdGhpcy5zdWJncm91cHNTdXBwb3J0ZWR8fCFuLm1pblN1Ymdyb3VwU2l6ZXx8IW4ubWF4U3ViZ3JvdXBTaXplP3RoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9dm9pZCAwOnRoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9W24ubWluU3ViZ3JvdXBTaXplLG4ubWF4U3ViZ3JvdXBTaXplXX19LGFuPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPW51bGw7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwiO3RoaXMuY2FwdHVyZWRDb21tYW5kTGlzdD1uZXcgTWFwO3RoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LG4pe3RoaXMuZW52PXQ7bGV0IHI9W10sbz17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOm4ubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOm4ubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOm4ubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpyfSxhPXM9Pm4uZmVhdHVyZXMuaGFzKHMpJiZyLnB1c2gocykmJiEwO2EoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIil8fGEoXCJ0aW1lc3RhbXAtcXVlcnlcIiksYShcInNoYWRlci1mMTZcIiksYShcInN1Ymdyb3Vwc1wiKSYmYShcInN1Ymdyb3Vwcy1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgbi5yZXF1ZXN0RGV2aWNlKG8pLHRoaXMuZGV2aWNlSW5mbz1uZXcgQW8odGhpcy5kZXZpY2UpLHRoaXMuYWRhcHRlckluZm89bmV3IElvKG4uaW5mb3x8YXdhaXQgbi5yZXF1ZXN0QWRhcHRlckluZm8oKSksdGhpcy5ncHVEYXRhTWFuYWdlcj1Wcyh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBvbih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsVXIodC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPXM9PntzLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke3MuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZSx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJhZGFwdGVyXCIse3ZhbHVlOm4sd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSx0aGlzLnNldFF1ZXJ5VHlwZSgpfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKSxuPXt9O3RoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIiYmKG4udGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMixlbmRPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXQuYmVnaW5Db21wdXRlUGFzcyhuKX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7aWYoIXRoaXMuY29tbWFuZEVuY29kZXIpcmV0dXJuO05lKCksdGhpcy5lbmRDb21wdXRlUGFzcygpO2xldCB0O3RoaXMucXVlcnlUeXBlIT09XCJub25lXCImJih0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldCh0aGlzLnF1ZXJ5U2V0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMix0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwKSx0PXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSx0aGlzLnBlbmRpbmdRdWVyaWVzLnNldCh0LHRoaXMucGVuZGluZ0tlcm5lbHMpLHRoaXMucGVuZGluZ0tlcm5lbHM9W10sdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCx0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4KSksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0Lm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCBuPW5ldyBCaWdVaW50NjRBcnJheSh0LmdldE1hcHBlZFJhbmdlKCkpLHI9dGhpcy5wZW5kaW5nUXVlcmllcy5nZXQodCk7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aC8yO28rKyl7bGV0IGE9cltvXSxzPWEua2VybmVsSWQsZD10aGlzLmtlcm5lbHMuZ2V0KHMpLGw9ZC5rZXJuZWxUeXBlLHA9ZC5rZXJuZWxOYW1lLGY9YS5wcm9ncmFtTmFtZSxoPWEuaW5wdXRUZW5zb3JWaWV3cyx5PWEub3V0cHV0VGVuc29yVmlld3MsXz1uW28qMl0sYj1uW28qMisxXTt0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5xdWVyeVRpbWVCYXNlPV8pO2xldCB3PU51bWJlcihfLXRoaXMucXVlcnlUaW1lQmFzZSksUz1OdW1iZXIoYi10aGlzLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih3KXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKFMpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTtpZih0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5vbmRhdGEpdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe3ZlcnNpb246MSxpbnB1dHNNZXRhZGF0YTpoLm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOl90KCQuZGF0YVR5cGUpfSkpLG91dHB1dHNNZXRhZGF0YTp5Lm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOl90KCQuZGF0YVR5cGUpfSkpLGtlcm5lbElkOnMsa2VybmVsVHlwZTpsLGtlcm5lbE5hbWU6cCxwcm9ncmFtTmFtZTpmLHN0YXJ0VGltZTp3LGVuZFRpbWU6U30pO2Vsc2V7bGV0ICQ9XCJcIjtoLmZvckVhY2goKFQsQyk9PnskKz1gaW5wdXRbJHtDfV06IFske1QuZGltc31dIHwgJHtfdChULmRhdGFUeXBlKX0sIGB9KTtsZXQgdj1cIlwiO3kuZm9yRWFjaCgoVCxDKT0+e3YrPWBvdXRwdXRbJHtDfV06IFske1QuZGltc31dIHwgJHtfdChULmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHtzfXwke2x9fCR7cH18JHtmfVwiICR7JH0ke3Z9ZXhlY3V0aW9uIHRpbWU6ICR7Uy13fSBuc2ApfXZyKFwiR1BVXCIsYCR7Zn06OiR7X306OiR7Yn1gKX10LnVubWFwKCksdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUodCl9KSxCZSgpfXJ1bih0LG4scixvLGEscyl7TmUodC5uYW1lKTtsZXQgZD1bXTtmb3IobGV0IFQ9MDtUPG4ubGVuZ3RoOysrVCl7bGV0IEM9bltUXS5kYXRhO2lmKEM9PT0wKWNvbnRpbnVlO2xldCBBPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KEMpO2lmKCFBKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke0N9YCk7ZC5wdXNoKEEpfWxldHtvdXRwdXRzOmwsZGlzcGF0Y2hHcm91cDpwLHByb2dyYW1Vbmlmb3JtczpmfT10LmdldFJ1bkRhdGEobiksaD1yLmxlbmd0aD09PTA/bC5tYXAoKFQsQyk9PkMpOnI7aWYoaC5sZW5ndGghPT1sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7aC5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtsLmxlbmd0aH0uYCk7bGV0IHk9W10sXz1bXTtmb3IobGV0IFQ9MDtUPGwubGVuZ3RoOysrVCl7aWYoIU51bWJlci5pc0ludGVnZXIoaFtUXSl8fGhbVF08LTN8fGhbVF0+PXMpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHtoW1RdfWApO2lmKGhbVF09PT0tMyljb250aW51ZTtsZXQgQz1oW1RdPT09LTEsQT1oW1RdPT09LTIsaz1DfHxBP2EobFtUXS5kYXRhVHlwZSxsW1RdLmRpbXMpOm8oaFtUXSxsW1RdLmRhdGFUeXBlLGxbVF0uZGltcyk7aWYoeS5wdXNoKGspLGsuZGF0YT09PTApY29udGludWU7bGV0IE89dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoay5kYXRhKTtpZighTyl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7ay5kYXRhfWApO2lmKEMmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKE8pLEEpe2xldCBNPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtNfHwoTT1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxNKSksTS5wdXNoKE8pfV8ucHVzaChPKX1pZihkLmxlbmd0aCE9PW4ubGVuZ3RofHxfLmxlbmd0aCE9PXkubGVuZ3RoKXtpZihfLmxlbmd0aD09PTApcmV0dXJuIEJlKHQubmFtZSkseTt0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gJHt0Lm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gKX1sZXQgYjtpZihmKXtsZXQgVD0wLEM9W107Zi5mb3JFYWNoKE09PntsZXQgVj10eXBlb2YgTS5kYXRhPT1cIm51bWJlclwiP1tNLmRhdGFdOk0uZGF0YTtpZihWLmxlbmd0aD09PTApcmV0dXJuO2xldCBGPU0udHlwZT09PTEwPzI6NCxqLG5lO00udHlwZT09PTEwPyhuZT1WLmxlbmd0aD40PzE2OlYubGVuZ3RoPjI/ODpWLmxlbmd0aCpGLGo9Vi5sZW5ndGg+ND8xNjpGKlYubGVuZ3RoKToobmU9Vi5sZW5ndGg8PTI/Vi5sZW5ndGgqRjoxNixqPTE2KSxUPU1hdGguY2VpbChUL25lKSpuZSxDLnB1c2goVCk7bGV0IFc9TS50eXBlPT09MTA/ODo0O1QrPVYubGVuZ3RoPjQ/TWF0aC5jZWlsKFYubGVuZ3RoL1cpKmo6Vi5sZW5ndGgqRn0pO2xldCBBPTE2O1Q9TWF0aC5jZWlsKFQvQSkqQTtsZXQgaz1uZXcgQXJyYXlCdWZmZXIoVCk7Zi5mb3JFYWNoKChNLFYpPT57bGV0IEY9Q1tWXSxqPXR5cGVvZiBNLmRhdGE9PVwibnVtYmVyXCI/W00uZGF0YV06TS5kYXRhO2lmKE0udHlwZT09PTYpbmV3IEludDMyQXJyYXkoayxGLGoubGVuZ3RoKS5zZXQoaik7ZWxzZSBpZihNLnR5cGU9PT0xMiluZXcgVWludDMyQXJyYXkoayxGLGoubGVuZ3RoKS5zZXQoaik7ZWxzZSBpZihNLnR5cGU9PT0xMCluZXcgVWludDE2QXJyYXkoayxGLGoubGVuZ3RoKS5zZXQoaik7ZWxzZSBpZihNLnR5cGU9PT0xKW5ldyBGbG9hdDMyQXJyYXkoayxGLGoubGVuZ3RoKS5zZXQoaik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHtfdChNLnR5cGUpfWApfSk7bGV0IE89dGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoVCxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTt0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihPLmJ1ZmZlciwwLGssMCxUKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoTy5pZCksYj17b2Zmc2V0OjAsc2l6ZTpULGJ1ZmZlcjpPLmJ1ZmZlcn19bGV0IHc9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShwKSxTPXdbMV09PT0xJiZ3WzJdPT09MSwkPVl5KHQsbixTKSx2PXRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3QoJCk7aWYodnx8KHY9dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZCh0LHcpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QoJCx2KSxtZShcImluZm9cIiwoKT0+YFthcnRpZmFjdF0ga2V5OiAkeyR9LCBwcm9ncmFtTmFtZTogJHt0Lm5hbWV9YCkpLGYmJnYudW5pZm9ybVZhcmlhYmxlc0luZm8pe2lmKGYubGVuZ3RoIT09di51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIHZhcmlhYmxlcyBjb3VudCBtaXNtYXRjaDogZXhwZWN0ICR7di51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGh9LCBnb3QgJHtmLmxlbmd0aH0gaW4gcHJvZ3JhbSBcIiR7di5wcm9ncmFtSW5mby5uYW1lfVwiLmApO2ZvcihsZXQgVD0wO1Q8Zi5sZW5ndGg7VCsrKXtsZXQgQz1mW1RdLEE9Qy50eXBlLGs9dHlwZW9mIEMuZGF0YT09XCJudW1iZXJcIj8xOkMuZGF0YS5sZW5ndGgsW08sTV09di51bmlmb3JtVmFyaWFibGVzSW5mb1tUXTtpZihBIT09T3x8ayE9PU0pdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIHZhcmlhYmxlICR7VH0gbWlzbWF0Y2g6IGV4cGVjdCB0eXBlICR7T30gd2l0aCBzaXplICR7TX0sIGdvdCB0eXBlICR7QX0gd2l0aCBzaXplICR7a30gaW4gcHJvZ3JhbSBcIiR7di5wcm9ncmFtSW5mby5uYW1lfVwiLmApfX1pZihtZShcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0keyR9KSB3aXRoICR7d1swXX14JHt3WzFdfXgke3dbMl19YCksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcInx8dGhpcy5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IFQ9e2tlcm5lbElkOnRoaXMuY3VycmVudEtlcm5lbElkLHByb2dyYW1OYW1lOnYucHJvZ3JhbUluZm8ubmFtZSxpbnB1dFRlbnNvclZpZXdzOm4sb3V0cHV0VGVuc29yVmlld3M6eX07dGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKFQpLHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCImJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKFQpfXJldHVybiB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bih2LGQsXyx3LGIpLEJlKHQubmFtZSkseX11cGxvYWQodCxuKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LG4pfW1lbWNweSh0LG4pe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQsbil9YXN5bmMgZG93bmxvYWQodCxuKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQsbil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxuLHIsbyl7bGV0IGE9TmMuZ2V0KHQpO2lmKCFhKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO2xldCBzPXtrZXJuZWxUeXBlOnQsa2VybmVsTmFtZTpvLGtlcm5lbEVudHJ5OmFbMF0sYXR0cmlidXRlczpbYVsxXSxyXX07dGhpcy5rZXJuZWxzLnNldChuLHMpfXJlbGVhc2VLZXJuZWwodCl7bGV0IG49dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYobil7Zm9yKGxldCByIG9mIG4pdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHIuaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQsbixyKXtsZXQgbz10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFvKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0IGE9by5rZXJuZWxUeXBlLHM9by5rZXJuZWxOYW1lLGQ9by5rZXJuZWxFbnRyeSxsPW8uYXR0cmlidXRlcztpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHthfV0gJHtzfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQsbFswXSYmKGxbMV09bFswXShsWzFdKSxsWzBdPXZvaWQgMCksbWUoXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7YX1dICR7c31cIi4uLmApO2xldCBwPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIHAmJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxkKG4sbFsxXSksMH1jYXRjaChmKXtyZXR1cm4gci5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7YX1dICR7c31cIiBmYWlsZWQuICR7Zn1gKSksMX1maW5hbGx5e3AmJnIucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihmPT5mP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7YX1dICR7c31cIjogJHtmLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBmIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZi5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQsbixyLG8pe2xldCBhPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO2F8fChhPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxhKSk7bGV0IHM9YS5nZXQobiksZD10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIocixvLHMpO3JldHVybiBhLnNldChuLFtkLHJdKSxkfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCBuPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO24mJihuLmZvckVhY2gocj0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoclswXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IG49dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIG4uYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxuLHIpe3JldHVybiBhc3luYygpPT57bGV0IG89YXdhaXQgbm8odGhpcyx0LG4pO3JldHVybiBOcihvLmJ1ZmZlcixyKX19d3JpdGVUaW1lc3RhbXAodCl7dGhpcy5xdWVyeVR5cGU9PT1cImluc2lkZS1wYXNzZXNcIiYmdGhpcy5jb21wdXRlUGFzc0VuY29kZXIud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCx0KX1zZXRRdWVyeVR5cGUoKXt0aGlzLnF1ZXJ5VHlwZT1cIm5vbmVcIiwodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZT09PVwiZGVmYXVsdFwifHwodHlwZW9mIHRoaXMuZW52LnRyYWNlPlwidVwiP3RoaXMuZW52Lndhc20udHJhY2U6dGhpcy5lbnYudHJhY2UpKSYmKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKT90aGlzLnF1ZXJ5VHlwZT1cImluc2lkZS1wYXNzZXNcIjp0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJih0aGlzLnF1ZXJ5VHlwZT1cImF0LXBhc3Nlc1wiKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjJ9KSx0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlcj10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pKSl9Y2FwdHVyZUJlZ2luKCl7bWUoXCJpbmZvXCIsXCJjYXB0dXJlQmVnaW5cIiksdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpfHx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCxbXSksdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpfHx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCxbXSksdGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImNhcHR1cmluZ1wifWNhcHR1cmVFbmQoKXttZShcImluZm9cIixcImNhcHR1cmVFbmRcIiksdGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1yZXBsYXkoKXttZShcImluZm9cIixcInJlcGxheVwiKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJyZXBsYXlpbmdcIjtsZXQgdD10aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCksbj10aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkscj10Lmxlbmd0aDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO2ZvcihsZXQgbz0wO288cjtvKyspe2xldCBhPXRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCkscz10W29dO3RoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMiksYS5zZXRQaXBlbGluZShzLmNvbXB1dGVQaXBlbGluZSksYS5zZXRCaW5kR3JvdXAoMCxzLmJpbmRHcm91cCksYS5kaXNwYXRjaFdvcmtncm91cHMoLi4ucy5kaXNwYXRjaEdyb3VwKSx0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKyx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2gobltvXSksKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuZmx1c2goKX10aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwifW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuZ3B1RGF0YU1hbmFnZXIub25DcmVhdGVTZXNzaW9uKCl9b25SZWxlYXNlU2Vzc2lvbih0KXt0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHQpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModCkmJnRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUodCksdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyh0KSYmdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZSh0KSx0aGlzLmdwdURhdGFNYW5hZ2VyLm9uUmVsZWFzZVNlc3Npb24odCl9b25SdW5TdGFydCh0KXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9dCx0aGlzLnNldFF1ZXJ5VHlwZSgpfX19KTt2YXIgWHksR2MsSnksSGMsc24sdW4sa28sRmMscWM9RygoKT0+e1widXNlIHN0cmljdFwiO3R0KCk7WHk9MSxHYz0oKT0+WHkrKyxKeT1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsMzJdLFtcImZsb2F0MTZcIiwxNl0sW1wiaW50MzJcIiwzMl0sW1widWludDMyXCIsMzJdLFtcImludDY0XCIsNjRdLFtcInVpbnQ2NFwiLDY0XSxbXCJpbnQ4XCIsOF0sW1widWludDhcIiw4XSxbXCJpbnQ0XCIsNF0sW1widWludDRcIiw0XV0pLEhjPShlLHQpPT57bGV0IG49SnkuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZS5cIik7cmV0dXJuIHQubGVuZ3RoPjA/TWF0aC5jZWlsKHQucmVkdWNlKChyLG8pPT5yKm8pKm4vOCk6MH0sc249Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5zZXNzaW9uSWQ9dC5zZXNzaW9uSWQsdGhpcy5tbENvbnRleHQ9dC5jb250ZXh0LHRoaXMubWxUZW5zb3I9dC50ZW5zb3IsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMudGVuc29yU2hhcGU9dC5zaGFwZX1nZXQgdGVuc29yKCl7cmV0dXJuIHRoaXMubWxUZW5zb3J9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5kYXRhVHlwZX1nZXQgc2hhcGUoKXtyZXR1cm4gdGhpcy50ZW5zb3JTaGFwZX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiBIYyh0aGlzLmRhdGFUeXBlLHRoaXMudGVuc29yU2hhcGUpfWRlc3Ryb3koKXttZShcInZlcmJvc2VcIiwoKT0+XCJbV2ViTk5dIFRlbnNvcldyYXBwZXIuZGVzdHJveVwiKSx0aGlzLm1sVGVuc29yLmRlc3Ryb3koKX13cml0ZSh0KXt0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLHQpfWFzeW5jIHJlYWQodCl7cmV0dXJuIHQ/dGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLHQpOnRoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcil9Y2FuUmV1c2VUZW5zb3IodCxuLHIpe3JldHVybiB0aGlzLm1sQ29udGV4dD09PXQmJnRoaXMuZGF0YVR5cGU9PT1uJiZ0aGlzLnRlbnNvclNoYXBlLmxlbmd0aD09PXIubGVuZ3RoJiZ0aGlzLnRlbnNvclNoYXBlLmV2ZXJ5KChvLGEpPT5vPT09clthXSl9fSx1bj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMudGVuc29yTWFuYWdlcj10O3RoaXMud3JhcHBlcj1ufWdldCB0ZW5zb3JXcmFwcGVyKCl7cmV0dXJuIHRoaXMud3JhcHBlcn1yZWxlYXNlVGVuc29yKCl7dGhpcy50ZW5zb3JXcmFwcGVyJiYodGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy50ZW5zb3JXcmFwcGVyKSx0aGlzLndyYXBwZXI9dm9pZCAwKX1hc3luYyBlbnN1cmVUZW5zb3IodCxuLHIsbyl7bGV0IGE9dGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MQ29udGV4dCh0KTtpZih0aGlzLndyYXBwZXIpe2lmKHRoaXMud3JhcHBlci5jYW5SZXVzZVRlbnNvcihhLG4scikpcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7aWYobyl7aWYodGhpcy53cmFwcGVyLmJ5dGVMZW5ndGghPT1IYyhuLHIpKXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb3B5IGRhdGEgdG8gdGVuc29yIHdpdGggZGlmZmVyZW50IHNpemUuXCIpO3RoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMud3JhcHBlci5yZWFkKCkpfXRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMud3JhcHBlcil9bGV0IHM9dHlwZW9mIE1MVGVuc29yVXNhZ2U+XCJ1XCI/dm9pZCAwOk1MVGVuc29yVXNhZ2UuUkVBRHxNTFRlbnNvclVzYWdlLldSSVRFO3JldHVybiB0aGlzLndyYXBwZXI9YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmdldENhY2hlZFRlbnNvcih0LG4scixzLCEwLCEwKSxvJiZ0aGlzLmFjdGl2ZVVwbG9hZCYmKHRoaXMud3JhcHBlci53cml0ZSh0aGlzLmFjdGl2ZVVwbG9hZCksdGhpcy5hY3RpdmVVcGxvYWQ9dm9pZCAwKSx0aGlzLndyYXBwZXIudGVuc29yfXVwbG9hZCh0KXtpZih0aGlzLndyYXBwZXIpaWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZSh0KTtyZXR1cm59ZWxzZSBtZShcInZlcmJvc2VcIiwoKT0+XCJEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuXCIpLHRoaXMucmVsZWFzZVRlbnNvcigpO3RoaXMuYWN0aXZlVXBsb2FkP3RoaXMuYWN0aXZlVXBsb2FkLnNldCh0KTp0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheSh0KX1hc3luYyBkb3dubG9hZCh0KXtpZih0aGlzLmFjdGl2ZVVwbG9hZClpZih0KXt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkodCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO3JldHVybn1lbHNlIHJldHVybiB0aGlzLmFjdGl2ZVVwbG9hZC5idWZmZXI7aWYoIXRoaXMud3JhcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuXCIpO3JldHVybiB0P3RoaXMud3JhcHBlci5yZWFkKHQpOnRoaXMud3JhcHBlci5yZWFkKCl9fSxrbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnRlbnNvclRyYWNrZXJzQnlJZD1uZXcgTWFwO3RoaXMuZnJlZVRlbnNvcnM9W107dGhpcy5leHRlcm5hbFRlbnNvcnM9bmV3IFNldH1nZXRNTENvbnRleHQodCl7bGV0IG49dGhpcy5iYWNrZW5kLmdldE1MQ29udGV4dCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJNTENvbnRleHQgbm90IGZvdW5kIGZvciBzZXNzaW9uLlwiKTtyZXR1cm4gbn1yZXNlcnZlVGVuc29ySWQoKXtsZXQgdD1HYygpO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodCxuZXcgdW4odGhpcykpLHR9cmVsZWFzZVRlbnNvcklkKHQpe2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtuJiYodGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHQpLG4udGVuc29yV3JhcHBlciYmdGhpcy5yZWxlYXNlVGVuc29yKG4udGVuc29yV3JhcHBlcikpfWFzeW5jIGVuc3VyZVRlbnNvcih0LG4scixvLGEpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvciB7dGVuc29ySWQ6ICR7bn0sIGRhdGFUeXBlOiAke3J9LCBzaGFwZTogJHtvfSwgY29weU9sZDogJHthfX1gKTtsZXQgcz10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQobik7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7cmV0dXJuIHMuZW5zdXJlVGVuc29yKHQscixvLGEpfXVwbG9hZCh0LG4pe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyLnVwbG9hZChuKX1hc3luYyBkb3dubG9hZCh0LG4pe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke24/LmJ5dGVMZW5ndGh9fWApO2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gci5kb3dubG9hZChuKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCBuIG9mIHRoaXMuZnJlZVRlbnNvcnMpbi5zZXNzaW9uSWQ9PT10JiZuLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKG49Pm4uc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxuLHIsbyl7bGV0IGE9dGhpcy5nZXRNTENvbnRleHQodCkscz1HYygpLGQ9bmV3IHNuKHtzZXNzaW9uSWQ6dCxjb250ZXh0OmEsdGVuc29yOm4sZGF0YVR5cGU6cixzaGFwZTpvfSk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldChzLG5ldyB1bih0aGlzLGQpKSx0aGlzLmV4dGVybmFsVGVuc29ycy5hZGQoZCksc31hc3luYyBnZXRDYWNoZWRUZW5zb3IodCxuLHIsbyxhLHMpe2xldCBkPXRoaXMuZ2V0TUxDb250ZXh0KHQpO2ZvcihsZXRbcCxmXW9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKWlmKGYuY2FuUmV1c2VUZW5zb3IoZCxuLHIpKXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke259LCBzaGFwZTogJHtyfX1gKTtsZXQgaD10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShwLDEpWzBdO3JldHVybiBoLnNlc3Npb25JZD10LGh9bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke259LCBzaGFwZTogJHtyfX1gKTtsZXQgbD1hd2FpdCBkLmNyZWF0ZVRlbnNvcih7ZGF0YVR5cGU6bixzaGFwZTpyLGRpbWVuc2lvbnM6cix1c2FnZTpvLHdyaXRhYmxlOmEscmVhZGFibGU6c30pO3JldHVybiBuZXcgc24oe3Nlc3Npb25JZDp0LGNvbnRleHQ6ZCx0ZW5zb3I6bCxkYXRhVHlwZTpuLHNoYXBlOnJ9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LEZjPSguLi5lKT0+bmV3IGtvKC4uLmUpfSk7dmFyIEVvLGViLGRuLEtjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2J0KCk7Sm4oKTtxYygpO3R0KCk7RW89bmV3IE1hcChbWzEsXCJmbG9hdDMyXCJdLFsxMCxcImZsb2F0MTZcIl0sWzYsXCJpbnQzMlwiXSxbMTIsXCJ1aW50MzJcIl0sWzcsXCJpbnQ2NFwiXSxbMTMsXCJ1aW50NjRcIl0sWzIyLFwiaW50NFwiXSxbMjEsXCJ1aW50NFwiXSxbMyxcImludDhcIl0sWzIsXCJ1aW50OFwiXSxbOSxcInVpbnQ4XCJdXSksZWI9KGUsdCk9PntpZihlPT09dClyZXR1cm4hMDtpZihlPT09dm9pZCAwfHx0PT09dm9pZCAwKXJldHVybiExO2xldCBuPU9iamVjdC5rZXlzKGUpLnNvcnQoKSxyPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtyZXR1cm4gbi5sZW5ndGg9PT1yLmxlbmd0aCYmbi5ldmVyeSgobyxhKT0+bz09PXJbYV0mJmVbb109PT10W29dKX0sZG49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50ZW5zb3JNYW5hZ2VyPUZjKHRoaXMpO3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQ9bmV3IE1hcDt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dD1uZXcgTWFwO3RoaXMubWxDb250ZXh0Q2FjaGU9W107dGhpcy5zZXNzaW9uR3JhcGhJbnB1dHM9bmV3IE1hcDt0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzPVtdO3RoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcz1uZXcgTWFwO1VyKHQubG9nTGV2ZWwsISF0LmRlYnVnKX1nZXQgY3VycmVudFNlc3Npb25JZCgpe2lmKHRoaXMuYWN0aXZlU2Vzc2lvbklkPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIk5vIGFjdGl2ZSBzZXNzaW9uXCIpO3JldHVybiB0aGlzLmFjdGl2ZVNlc3Npb25JZH1vblJ1blN0YXJ0KHQpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBvblJ1blN0YXJ0IHtzZXNzaW9uSWQ6ICR7dH19YCksdGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1vblJ1bkVuZCh0KXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gb25SdW5FbmQge3Nlc3Npb25JZDogJHt0fX1gKTtsZXQgbj10aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHQpO2lmKG4pe2ZvcihsZXQgciBvZiBuKW1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWxlYXNpbmcgdGVtcG9yYXJ5IHRlbnNvciB7dGVuc29ySWQ6ICR7cn19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZChyKTt0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZGVsZXRlKHQpLHRoaXMuYWN0aXZlU2Vzc2lvbklkPXZvaWQgMH19YXN5bmMgY3JlYXRlTUxDb250ZXh0KHQpe2lmKHQgaW5zdGFuY2VvZiBHUFVEZXZpY2Upe2xldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG89Pm8uZ3B1RGV2aWNlPT09dCk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7Z3B1RGV2aWNlOnQsbWxDb250ZXh0Om99KSxvfX1lbHNlIGlmKHQ9PT12b2lkIDApe2xldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG89Pm8ub3B0aW9ucz09PXZvaWQgMCYmby5ncHVEZXZpY2U9PT12b2lkIDApO2lmKHIhPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtyXS5tbENvbnRleHQ7e2xldCBvPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7bWxDb250ZXh0Om99KSxvfX1sZXQgbj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChyPT5lYihyLm9wdGlvbnMsdCkpO2lmKG4hPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtuXS5tbENvbnRleHQ7e2xldCByPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHQpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe29wdGlvbnM6dCxtbENvbnRleHQ6cn0pLHJ9fXJlZ2lzdGVyTUxDb250ZXh0KHQsbil7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5zZXQodCxuKTtsZXQgcj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobik7cnx8KHI9bmV3IFNldCx0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQobixyKSksci5hZGQodCksdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cy5sZW5ndGg+MCYmKHRoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLnNldCh0LHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMpLHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHM9W10pfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZGVsZXRlKHQpO2xldCBuPXRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHQpO2lmKCFuKXJldHVybjt0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHQpLHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZGVsZXRlKHQpO2xldCByPXRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChuKTtpZihyLmRlbGV0ZSh0KSxyLnNpemU9PT0wKXt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5kZWxldGUobik7bGV0IG89dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoYT0+YS5tbENvbnRleHQ9PT1uKTtvIT09LTEmJnRoaXMubWxDb250ZXh0Q2FjaGUuc3BsaWNlKG8sMSl9fWdldE1MQ29udGV4dCh0KXtyZXR1cm4gdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCl9cmVzZXJ2ZVRlbnNvcklkKCl7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKX1yZWxlYXNlVGVuc29ySWQodCl7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlbGVhc2VUZW5zb3JJZCB7dGVuc29ySWQ6ICR7dH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0KX1hc3luYyBlbnN1cmVUZW5zb3IodCxuLHIsbyxhKXtsZXQgcz1Fby5nZXQocik7aWYoIXMpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQ/P3RoaXMuY3VycmVudFNlc3Npb25JZCxuLHMsbyxhKX1hc3luYyBjcmVhdGVUZW1wb3JhcnlUZW5zb3IodCxuLHIpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ige29ubnhEYXRhVHlwZTogJHtufSwgc2hhcGU6ICR7cn19YCk7bGV0IG89RW8uZ2V0KG4pO2lmKCFvKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7bn1gKTtsZXQgYT10aGlzLnRlbnNvck1hbmFnZXIucmVzZXJ2ZVRlbnNvcklkKCk7YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcih0LGEsbyxyLCExKTtsZXQgcz10aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHQpO3JldHVybiBzP3MucHVzaChhKTp0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuc2V0KHQsW2FdKSxhfXVwbG9hZFRlbnNvcih0LG4pe2lmKCFJZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke24uYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LG4pfWFzeW5jIGRvd25sb2FkVGVuc29yKHQsbil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LG4pfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LG4pe3JldHVybiBhc3luYygpPT57bGV0IHI9YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBOcihyLG4pfX1yZWdpc3Rlck1MVGVuc29yKHQsbixyLG8pe2xldCBhPUVvLmdldChyKTtpZighYSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7bGV0IHM9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlZ2lzdGVyVGVuc29yKHQsbixhLG8pO3JldHVybiBtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTFRlbnNvciB7dGVuc29yOiAke259LCBkYXRhVHlwZTogJHthfSwgZGltZW5zaW9uczogJHtvfX0gLT4ge3RlbnNvcklkOiAke3N9fWApLHN9cmVnaXN0ZXJNTENvbnN0YW50KHQsbixyLG8sYSxzKXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBtb3VudGVkIGZpbGVzIGFyZSBub3QgYXZhaWxhYmxlLlwiKTtsZXQgZD10O3Quc3RhcnRzV2l0aChcIi4vXCIpJiYoZD10LnN1YnN0cmluZygyKSk7bGV0IGw9cy5nZXQoZCk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBGaWxlIHdpdGggbmFtZSAke2R9IG5vdCBmb3VuZCBpbiBwcmVsb2FkZWQgZmlsZXMuYCk7aWYobityPmwuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzOiBkYXRhIG9mZnNldCBhbmQgbGVuZ3RoIGV4Y2VlZCB0aGUgZXh0ZXJuYWwgZmlsZSBkYXRhIHNpemUuXCIpO2xldCBwPWwuc2xpY2UobixuK3IpLmJ1ZmZlcixmO3N3aXRjaChhLmRhdGFUeXBlKXtjYXNlXCJmbG9hdDMyXCI6Zj1uZXcgRmxvYXQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImZsb2F0MTZcIjpmPW5ldyBVaW50MTZBcnJheShwKTticmVhaztjYXNlXCJpbnQzMlwiOmY9bmV3IEludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwidWludDMyXCI6Zj1uZXcgVWludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NjRcIjpmPW5ldyBCaWdJbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQ2NFwiOmY9bmV3IEJpZ1VpbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcImludDhcIjpmPW5ldyBJbnQ4QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NFwiOmNhc2VcInVpbnQ0XCI6Y2FzZVwidWludDhcIjpmPW5ldyBVaW50OEFycmF5KHApO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5kYXRhVHlwZX0gaW4gY3JlYXRpbmcgV2ViTk4gQ29uc3RhbnQgZnJvbSBleHRlcm5hbCBkYXRhLmApfXJldHVybiBtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHthLmRhdGFUeXBlfSwgc2hhcGU6ICR7YS5zaGFwZX19fWApLG8uY29uc3RhbnQoYSxmKX1yZWdpc3RlckdyYXBoSW5wdXQodCl7dGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cy5wdXNoKHQpfWlzR3JhcGhJbnB1dCh0LG4pe2xldCByPXRoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLmdldCh0KTtyZXR1cm4gcj9yLmluY2x1ZGVzKG4pOiExfWZsdXNoKCl7fX19KTt2YXIgamM9e307WnQoamMse2luaXQ6KCk9PnRifSk7dmFyIGlyLFBvLHRiLFpjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO0xjKCk7dHQoKTthZSgpO0tjKCk7aXI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LG4scixvKXt0aGlzLm1vZHVsZT10O3RoaXMuZGF0YVR5cGU9bjt0aGlzLmRhdGE9cjt0aGlzLmRpbXM9b31nZXRGbG9hdDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1FLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEZsb2F0MzJBcnJheTpuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0QmlnSW50NjRBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUUuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgQmlnSW50NjRBcnJheTpuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEludDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1FLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEludDMyQXJyYXk6bmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRVaW50MTZBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xMCYmdGhpcy5kYXRhVHlwZSE9PTQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9RS5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBVaW50MTZBcnJheTpuZXcgVWludDE2QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1yZXNoYXBlKHQpe2lmKEUuc2l6ZSh0KSE9PUUuc2l6ZSh0aGlzLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmV3IHNoYXBlXCIpO3JldHVybiBuZXcgZSh0aGlzLm1vZHVsZSx0aGlzLmRhdGFUeXBlLHRoaXMuZGF0YSx0KX19LFBvPWNsYXNze2NvbnN0cnVjdG9yKHQsbixyKXt0aGlzLm1vZHVsZT10O3RoaXMuYmFja2VuZD1uO3RoaXMuY3VzdG9tRGF0YU9mZnNldD0wO3RoaXMuY3VzdG9tRGF0YVNpemU9MDt0aGlzLmFkYXB0ZXJJbmZvPW4uYWRhcHRlckluZm8sdGhpcy5kZXZpY2VJbmZvPW4uZGV2aWNlSW5mbztsZXQgbz10LlBUUl9TSVpFLGE9ci90LlBUUl9TSVpFLHM9bz09PTQ/XCJpMzJcIjpcImk2NFwiO3RoaXMub3BLZXJuZWxDb250ZXh0PU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKTtsZXQgZD1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSk7dGhpcy5vdXRwdXRDb3VudD1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSksdGhpcy5jdXN0b21EYXRhT2Zmc2V0PU51bWJlcih0LmdldFZhbHVlKG8qYSsrLFwiKlwiKSksdGhpcy5jdXN0b21EYXRhU2l6ZT1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSk7bGV0IGw9W107Zm9yKGxldCBwPTA7cDxkO3ArKyl7bGV0IGY9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpLGg9TnVtYmVyKHQuZ2V0VmFsdWUobyphKyssXCIqXCIpKSx5PU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKSxfPVtdO2ZvcihsZXQgYj0wO2I8eTtiKyspXy5wdXNoKE51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKSk7bC5wdXNoKG5ldyBpcih0LGYsaCxfKSl9dGhpcy5pbnB1dHM9bH1nZXQga2VybmVsQ3VzdG9tRGF0YSgpe3JldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGF9Z2V0IGN1c3RvbURhdGFCdWZmZXIoKXtyZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCx0aGlzLmN1c3RvbURhdGFPZmZzZXQrdGhpcy5jdXN0b21EYXRhU2l6ZSl9Y29tcHV0ZSh0LG4pe2xldCByPW4/LmlucHV0cz8ubWFwKGQ9PnR5cGVvZiBkPT1cIm51bWJlclwiP3RoaXMuaW5wdXRzW2RdOmQpPz90aGlzLmlucHV0cyxvPW4/Lm91dHB1dHM/P1tdLGE9KGQsbCxwKT0+bmV3IGlyKHRoaXMubW9kdWxlLGwsdGhpcy5vdXRwdXQoZCxwKSxwKSxzPShkLGwpPT57bGV0IHA9d3QoZCxsKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkfWApO2xldCBmPXA+MD90aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHApLmlkOjA7cmV0dXJuIG5ldyBpcih0aGlzLm1vZHVsZSxkLGYsbCl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQscixvLGEscyx0aGlzLm91dHB1dENvdW50KX1vdXRwdXQodCxuKXtsZXQgcj10aGlzLm1vZHVsZS5zdGFja1NhdmUoKTt0cnl7bGV0IG89dGhpcy5tb2R1bGUuUFRSX1NJWkUsYT1vPT09ND9cImkzMlwiOlwiaTY0XCIscz10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK24ubGVuZ3RoKSpvKTt0aGlzLm1vZHVsZS5zZXRWYWx1ZShzLG4ubGVuZ3RoLGEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKXRoaXMubW9kdWxlLnNldFZhbHVlKHMrbyooZCsxKSxuW2RdLGEpO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LHMpfWNhdGNoKG8pe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske3R9XSB3aXRoIGRpbXMgWyR7bn1dLiBJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gRXJyb3I6ICR7b31gKX1maW5hbGx5e3RoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShyKX19fSx0Yj1hc3luYyhlLHQsbixyKT0+e2xldCBvPXQuanNlcEluaXQ7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuXCIpO2lmKGU9PT1cIndlYmdwdVwiKXtsZXQgYT1uZXcgYW47YXdhaXQgYS5pbml0aWFsaXplKG4sciksbyhcIndlYmdwdVwiLFthLHM9PmEuYWxsb2MoTnVtYmVyKHMpKSxzPT5hLmZyZWUocyksKHMsZCxsLHA9ITEpPT57aWYocCltZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihzKX0sIGRzdD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCksYS5tZW1jcHkoTnVtYmVyKHMpLE51bWJlcihkKSk7ZWxzZXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtOdW1iZXIocyl9LCBncHVEYXRhSWQ9JHtOdW1iZXIoZCl9LCBzaXplPSR7TnVtYmVyKGwpfWApO2xldCBmPXQuSEVBUFU4LnN1YmFycmF5KE51bWJlcihzPj4+MCksTnVtYmVyKHM+Pj4wKStOdW1iZXIobCkpO2EudXBsb2FkKE51bWJlcihkKSxmKX19LGFzeW5jKHMsZCxsKT0+e21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7c30sIGRhdGFPZmZzZXQ9JHtkfSwgc2l6ZT0ke2x9YCksYXdhaXQgYS5kb3dubG9hZChOdW1iZXIocyksKCk9PnQuSEVBUFU4LnN1YmFycmF5KE51bWJlcihkKT4+PjAsTnVtYmVyKGQrbCk+Pj4wKSl9LChzLGQsbCk9PmEuY3JlYXRlS2VybmVsKHMsTnVtYmVyKGQpLGwsdC5VVEY4VG9TdHJpbmcodC5fSnNlcEdldE5vZGVOYW1lKE51bWJlcihkKSkpKSxzPT5hLnJlbGVhc2VLZXJuZWwocyksKHMsZCxsLHApPT57bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7bH0sIGtlcm5lbD0ke3N9LCBjb250ZXh0RGF0YU9mZnNldD0ke2R9YCk7bGV0IGY9bmV3IFBvKHQsYSxOdW1iZXIoZCkpO3JldHVybiBhLmNvbXB1dGVLZXJuZWwoTnVtYmVyKHMpLGYscCl9LCgpPT5hLmNhcHR1cmVCZWdpbigpLCgpPT5hLmNhcHR1cmVFbmQoKSwoKT0+YS5yZXBsYXkoKV0pfWVsc2V7bGV0IGE9bmV3IGRuKG4pO28oXCJ3ZWJublwiLFthLCgpPT5hLnJlc2VydmVUZW5zb3JJZCgpLHM9PmEucmVsZWFzZVRlbnNvcklkKHMpLGFzeW5jKHMsZCxsLHAsZik9PmEuZW5zdXJlVGVuc29yKHMsZCxsLHAsZiksKHMsZCk9PnthLnVwbG9hZFRlbnNvcihzLGQpfSxhc3luYyhzLGQpPT5hLmRvd25sb2FkVGVuc29yKHMsZCldKX19fSk7dmFyIHJiLENyLElyLHp0LG5iLFl0LEFyLGtyLFFjLEVyLFByLHpyLHFuPUcoKCk9PntcInVzZSBzdHJpY3RcIjt6cygpO0RzKCk7dGUoKTtidCgpO0RyKCk7WG4oKTtyYj0oZSx0KT0+e0llKCkuX09ydEluaXQoZSx0KSE9PTAmJmhlKFwiQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LENyPWFzeW5jIGU9PntyYihlLndhc20ubnVtVGhyZWFkcyxKdChlLmxvZ0xldmVsKSl9LElyPWFzeW5jKGUsdCk9Pnt7bGV0IG49KFpjKCksYnIoamMpKS5pbml0O2lmKHQ9PT1cIndlYmdwdVwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO2xldCByPWUud2ViZ3B1LmFkYXB0ZXI7aWYocil7aWYodHlwZW9mIHIubGltaXRzIT1cIm9iamVjdFwifHx0eXBlb2Ygci5mZWF0dXJlcyE9XCJvYmplY3RcInx8dHlwZW9mIHIucmVxdWVzdERldmljZSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuXCIpfWVsc2V7bGV0IG89ZS53ZWJncHUucG93ZXJQcmVmZXJlbmNlO2lmKG8hPT12b2lkIDAmJm8hPT1cImxvdy1wb3dlclwiJiZvIT09XCJoaWdoLXBlcmZvcm1hbmNlXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZSBzZXR0aW5nOiBcIiR7b31cImApO2xldCBhPWUud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO2lmKGEhPT12b2lkIDAmJnR5cGVvZiBhIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2F9XCJgKTtpZihyPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoe3Bvd2VyUHJlZmVyZW5jZTpvLGZvcmNlRmFsbGJhY2tBZGFwdGVyOmF9KSwhcil0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuIFlvdSBtYXkgbmVlZCB0byBlbmFibGUgZmxhZyBcIi0tZW5hYmxlLXVuc2FmZS13ZWJncHVcIiBpZiB5b3UgYXJlIHVzaW5nIENocm9tZS4nKX1hd2FpdCBuKFwid2ViZ3B1XCIsSWUoKSxlLHIpfWlmKHQ9PT1cIndlYm5uXCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IubWwpdGhyb3cgbmV3IEVycm9yKFwiV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO2F3YWl0IG4oXCJ3ZWJublwiLEllKCksZSl9fX0senQ9bmV3IE1hcCxuYj1lPT57bGV0IHQ9SWUoKSxuPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCByPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipyKTt0Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUsbyxvK3IpIT09MCYmaGUoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpO2xldCBzPXI9PT00P1wiaTMyXCI6XCJpNjRcIjtyZXR1cm5bTnVtYmVyKHQuZ2V0VmFsdWUobyxzKSksTnVtYmVyKHQuZ2V0VmFsdWUobytyLHMpKV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19LFl0PWU9PntsZXQgdD1JZSgpLG49dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYobj09PTApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke2UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLG4pLFtuLGUuYnl0ZUxlbmd0aF19LEFyPWFzeW5jKGUsdCk9PntsZXQgbixyLG89SWUoKTtBcnJheS5pc0FycmF5KGUpP1tuLHJdPWU6ZS5idWZmZXI9PT1vLkhFQVBVOC5idWZmZXI/W24scl09W2UuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGhdOltuLHJdPVl0KGUpO2xldCBhPTAscz0wLGQ9MCxsPVtdLHA9W10sZj1bXTt0cnl7aWYoW3MsbF09T3ModCksdD8uZXh0ZXJuYWxEYXRhJiZvLm1vdW50RXh0ZXJuYWxEYXRhKXtsZXQgdj1bXTtmb3IobGV0IFQgb2YgdC5leHRlcm5hbERhdGEpe2xldCBDPXR5cGVvZiBUPT1cInN0cmluZ1wiP1Q6VC5wYXRoO3YucHVzaChlcih0eXBlb2YgVD09XCJzdHJpbmdcIj9UOlQuZGF0YSkudGhlbihBPT57by5tb3VudEV4dGVybmFsRGF0YShDLEEpfSkpfWF3YWl0IFByb21pc2UuYWxsKHYpfWZvcihsZXQgdiBvZiB0Py5leGVjdXRpb25Qcm92aWRlcnM/P1tdKWlmKCh0eXBlb2Ygdj09XCJzdHJpbmdcIj92OnYubmFtZSk9PT1cIndlYm5uXCIpe2lmKG8uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSExLHR5cGVvZiB2IT1cInN0cmluZ1wiKXtsZXQgQz12LEE9Qz8uY29udGV4dCxrPUM/LmdwdURldmljZSxPPUM/LmRldmljZVR5cGUsTT1DPy5wb3dlclByZWZlcmVuY2U7QT9vLmN1cnJlbnRDb250ZXh0PUE6az9vLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dChrKTpvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dCh7ZGV2aWNlVHlwZTpPLHBvd2VyUHJlZmVyZW5jZTpNfSl9ZWxzZSBvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dCgpO2JyZWFrfWE9YXdhaXQgby5fT3J0Q3JlYXRlU2Vzc2lvbihuLHIscyksYT09PTAmJmhlKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIiksby5qc2VwT25DcmVhdGVTZXNzaW9uPy4oKSxvLmN1cnJlbnRDb250ZXh0JiYoby5qc2VwUmVnaXN0ZXJNTENvbnRleHQoYSxvLmN1cnJlbnRDb250ZXh0KSxvLmN1cnJlbnRDb250ZXh0PXZvaWQgMCxvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMCk7bGV0W2gseV09bmIoYSksXz0hIXQ/LmVuYWJsZUdyYXBoQ2FwdHVyZSxiPVtdLHc9W10sUz1bXTtmb3IobGV0IHY9MDt2PGg7disrKXtsZXQgVD1vLl9PcnRHZXRJbnB1dE5hbWUoYSx2KTtUPT09MCYmaGUoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZS5cIikscC5wdXNoKFQpLGIucHVzaChvLlVURjhUb1N0cmluZyhUKSl9Zm9yKGxldCB2PTA7djx5O3YrKyl7bGV0IFQ9by5fT3J0R2V0T3V0cHV0TmFtZShhLHYpO1Q9PT0wJiZoZShcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksZi5wdXNoKFQpO2xldCBDPW8uVVRGOFRvU3RyaW5nKFQpO3cucHVzaChDKTt7aWYoXyYmdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PT12b2lkIDApe1MucHVzaChcImdwdS1idWZmZXJcIik7Y29udGludWV9bGV0IEE9dHlwZW9mIHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT1cInN0cmluZ1wiP3QucHJlZmVycmVkT3V0cHV0TG9jYXRpb246dD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltDXT8/XCJjcHVcIjtpZihBIT09XCJjcHVcIiYmQSE9PVwiY3B1LXBpbm5lZFwiJiZBIT09XCJncHUtYnVmZmVyXCImJkEhPT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke0F9LmApO2lmKF8mJkEhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7Uy5wdXNoKEEpfX1sZXQgJD1udWxsO3JldHVybiBTLnNvbWUodj0+dj09PVwiZ3B1LWJ1ZmZlclwifHx2PT09XCJtbC10ZW5zb3JcIikmJihkPW8uX09ydENyZWF0ZUJpbmRpbmcoYSksZD09PTAmJmhlKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLCQ9e2hhbmRsZTpkLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpTLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6Uy5tYXAodj0+WW4odikpfSksenQuc2V0KGEsW2EscCxmLCQsXywhMV0pLFthLGIsd119Y2F0Y2goaCl7dGhyb3cgcC5mb3JFYWNoKHk9Pm8uX09ydEZyZWUoeSkpLGYuZm9yRWFjaCh5PT5vLl9PcnRGcmVlKHkpKSxkIT09MCYmby5fT3J0UmVsZWFzZUJpbmRpbmcoZCkhPT0wJiZoZShcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIiksYSE9PTAmJm8uX09ydFJlbGVhc2VTZXNzaW9uKGEpIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLGh9ZmluYWxseXtvLl9mcmVlKG4pLHMhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMocykhPT0wJiZoZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxsLmZvckVhY2goaD0+by5fZnJlZShoKSksby51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKX19LGtyPWU9PntsZXQgdD1JZSgpLG49enQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W3IsbyxhLHMsZF09bjtzJiYoZCYmdC5fT3J0Q2xlYXJCb3VuZE91dHB1dHMocy5oYW5kbGUpIT09MCYmaGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSx0Ll9PcnRSZWxlYXNlQmluZGluZyhzLmhhbmRsZSkhPT0wJiZoZShcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIikpLHQuanNlcE9uUmVsZWFzZVNlc3Npb24/LihlKSxvLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSksYS5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKHIpIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLHp0LmRlbGV0ZShlKX0sUWM9YXN5bmMoZSx0LG4scixvLGE9ITEpPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IHM9SWUoKSxkPXMuUFRSX1NJWkUsbD1lWzBdLHA9ZVsxXSxmPWVbM10saD1mLHksXztpZihsPT09XCJzdHJpbmdcIiYmKGY9PT1cImdwdS1idWZmZXJcInx8Zj09PVwibWwtdGVuc29yXCIpKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKGEmJmYhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtvfSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO2lmKGY9PT1cImdwdS1idWZmZXJcIil7bGV0IFM9ZVsyXS5ncHVCdWZmZXI7Xz13dChSdChsKSxwKTtsZXQgJD1zLmpzZXBSZWdpc3RlckJ1ZmZlcjtpZighJCl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO3k9JChyLG8sUyxfKX1lbHNlIGlmKGY9PT1cIm1sLXRlbnNvclwiKXtsZXQgUz1lWzJdLm1sVGVuc29yO189d3QoUnQobCkscCk7bGV0ICQ9cy5qc2VwUmVnaXN0ZXJNTFRlbnNvcjtpZighJCl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTt5PSQocixTLFJ0KGwpLHApfWVsc2V7bGV0IFM9ZVsyXTtpZihBcnJheS5pc0FycmF5KFMpKXtfPWQqUy5sZW5ndGgseT1zLl9tYWxsb2MoXyksbi5wdXNoKHkpO2ZvcihsZXQgJD0wOyQ8Uy5sZW5ndGg7JCsrKXtpZih0eXBlb2YgU1skXSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAkeyR9IGlzIG5vdCBhIHN0cmluZ2ApO3Muc2V0VmFsdWUoeSskKmQsUGUoU1skXSxuKSxcIipcIil9fWVsc2V7bGV0ICQ9cy5qc2VwSXNHcmFwaElucHV0O2lmKGwhPT1cInN0cmluZ1wiJiYkKXtsZXQgdj1zLl9PcnRHZXRJbnB1dE5hbWUocixvKSxUPXMuVVRGOFRvU3RyaW5nKHYpO2lmKCQocixUKSl7bGV0IEM9UnQobCk7Xz13dChDLHApLGg9XCJtbC10ZW5zb3JcIjtsZXQgQT1zLmpzZXBDcmVhdGVUZW1wb3JhcnlUZW5zb3Isaz1zLmpzZXBVcGxvYWRUZW5zb3I7aWYoIUF8fCFrKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2xldCBPPWF3YWl0IEEocixDLHApO2soTyxuZXcgVWludDhBcnJheShTLmJ1ZmZlcixTLmJ5dGVPZmZzZXQsUy5ieXRlTGVuZ3RoKSkseT1PfWVsc2UgXz1TLmJ5dGVMZW5ndGgseT1zLl9tYWxsb2MoXyksbi5wdXNoKHkpLHMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheShTLmJ1ZmZlcixTLmJ5dGVPZmZzZXQsXykseSl9ZWxzZSBfPVMuYnl0ZUxlbmd0aCx5PXMuX21hbGxvYyhfKSxuLnB1c2goeSkscy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KFMuYnVmZmVyLFMuYnl0ZU9mZnNldCxfKSx5KX19bGV0IGI9cy5zdGFja1NhdmUoKSx3PXMuc3RhY2tBbGxvYyg0KnAubGVuZ3RoKTt0cnl7cC5mb3JFYWNoKCgkLHYpPT5zLnNldFZhbHVlKHcrdipkLCQsZD09PTQ/XCJpMzJcIjpcImk2NFwiKSk7bGV0IFM9cy5fT3J0Q3JlYXRlVGVuc29yKFJ0KGwpLHksXyx3LHAubGVuZ3RoLFluKGgpKTtTPT09MCYmaGUoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3J9LCBpbmRleD0ke299LmApLHQucHVzaChTKX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKGIpfX0sRXI9YXN5bmMoZSx0LG4scixvLGEpPT57bGV0IHM9SWUoKSxkPXMuUFRSX1NJWkUsbD16dC5nZXQoZSk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0IHA9bFswXSxmPWxbMV0saD1sWzJdLHk9bFszXSxfPWxbNF0sYj1sWzVdLHc9dC5sZW5ndGgsUz1yLmxlbmd0aCwkPTAsdj1bXSxUPVtdLEM9W10sQT1bXSxrPXMuc3RhY2tTYXZlKCksTz1zLnN0YWNrQWxsb2ModypkKSxNPXMuc3RhY2tBbGxvYyh3KmQpLFY9cy5zdGFja0FsbG9jKFMqZCksRj1zLnN0YWNrQWxsb2MoUypkKTt0cnl7WyQsdl09UHMoYSk7Zm9yKGxldCBXPTA7Vzx3O1crKylhd2FpdCBRYyhuW1ddLFQsQSxlLHRbV10sXyk7Zm9yKGxldCBXPTA7VzxTO1crKylhd2FpdCBRYyhvW1ddLEMsQSxlLHcrcltXXSxfKTtmb3IobGV0IFc9MDtXPHc7VysrKXMuc2V0VmFsdWUoTytXKmQsVFtXXSxcIipcIikscy5zZXRWYWx1ZShNK1cqZCxmW3RbV11dLFwiKlwiKTtmb3IobGV0IFc9MDtXPFM7VysrKXMuc2V0VmFsdWUoVitXKmQsQ1tXXSxcIipcIikscy5zZXRWYWx1ZShGK1cqZCxoW3JbV11dLFwiKlwiKTtpZih5JiYhYil7bGV0e2hhbmRsZTpXLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpKLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6dmV9PXk7aWYoZi5sZW5ndGghPT13KXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHt3fSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7Zi5sZW5ndGh9KS5gKTtmb3IobGV0IFE9MDtRPHc7USsrKXtsZXQgZWU9dFtRXTthd2FpdCBzLl9PcnRCaW5kSW5wdXQoVyxmW2VlXSxUW1FdKSE9PTAmJmhlKGBDYW4ndCBiaW5kIGlucHV0WyR7UX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBRPTA7UTxTO1ErKyl7bGV0IGVlPXJbUV07b1tRXT8uWzNdP3MuX09ydEJpbmRPdXRwdXQoVyxoW2VlXSxDW1FdLDApIT09MCYmaGUoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtRfV0gZm9yIHNlc3Npb249JHtlfS5gKTpzLl9PcnRCaW5kT3V0cHV0KFcsaFtlZV0sMCx2ZVtlZV0pIT09MCYmaGUoYENhbid0IGJpbmQgb3V0cHV0WyR7UX1dIHRvICR7SltRXX0gZm9yIHNlc3Npb249JHtlfS5gKX16dC5zZXQoZSxbcCxmLGgseSxfLCEwXSl9cy5qc2VwT25SdW5TdGFydD8uKHApO2xldCBqO3k/aj1hd2FpdCBzLl9PcnRSdW5XaXRoQmluZGluZyhwLHkuaGFuZGxlLFMsViwkKTpqPWF3YWl0IHMuX09ydFJ1bihwLE0sTyx3LEYsUyxWLCQpLGohPT0wJiZoZShcImZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLlwiKTtsZXQgbmU9W107Zm9yKGxldCBXPTA7VzxTO1crKyl7bGV0IEo9TnVtYmVyKHMuZ2V0VmFsdWUoVitXKmQsXCIqXCIpKTtpZihKPT09Q1tXXSl7bmUucHVzaChvW1ddKTtjb250aW51ZX1sZXQgdmU9cy5zdGFja1NhdmUoKSxRPXMuc3RhY2tBbGxvYyg0KmQpLGVlPSExLGxlLFo9MDt0cnl7cy5fT3J0R2V0VGVuc29yRGF0YShKLFEsUStkLFErMipkLFErMypkKSE9PTAmJmhlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7V30uYCk7bGV0IGtlPWQ9PT00P1wiaTMyXCI6XCJpNjRcIixTZT1OdW1iZXIocy5nZXRWYWx1ZShRLGtlKSk7Wj1zLmdldFZhbHVlKFErZCxcIipcIik7bGV0IEQ9cy5nZXRWYWx1ZShRK2QqMixcIipcIiksUj1OdW1iZXIocy5nZXRWYWx1ZShRK2QqMyxrZSkpLFk9W107Zm9yKGxldCB4ZT0wO3hlPFI7eGUrKylZLnB1c2goTnVtYmVyKHMuZ2V0VmFsdWUoRCt4ZSpkLGtlKSkpO3MuX09ydEZyZWUoRCkhPT0wJiZoZShcIkNhbid0IGZyZWUgbWVtb3J5IGZvciB0ZW5zb3IgZGltcy5cIik7bGV0IGZlPVkucmVkdWNlKCh4ZSxiZSk9PnhlKmJlLDEpO2xlPV90KFNlKTtsZXQgRmU9eT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW3JbV11dO2lmKGxlPT09XCJzdHJpbmdcIil7aWYoRmU9PT1cImdwdS1idWZmZXJcInx8RmU9PT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCB4ZT1bXTtmb3IobGV0IGJlPTA7YmU8ZmU7YmUrKyl7bGV0IFllPXMuZ2V0VmFsdWUoWitiZSpkLFwiKlwiKSxHdD1zLmdldFZhbHVlKForKGJlKzEpKmQsXCIqXCIpLHh0PWJlPT09ZmUtMT92b2lkIDA6R3QtWWU7eGUucHVzaChzLlVURjhUb1N0cmluZyhZZSx4dCkpfW5lLnB1c2goW2xlLFkseGUsXCJjcHVcIl0pfWVsc2UgaWYoRmU9PT1cImdwdS1idWZmZXJcIiYmZmU+MCl7bGV0IHhlPXMuanNlcEdldEJ1ZmZlcjtpZigheGUpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO2xldCBiZT14ZShaKSxZZT13dChTZSxmZSk7aWYoWWU9PT12b2lkIDB8fCFNcihsZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7bGV9YCk7ZWU9ITAsbmUucHVzaChbbGUsWSx7Z3B1QnVmZmVyOmJlLGRvd25sb2FkOnMuanNlcENyZWF0ZURvd25sb2FkZXIoYmUsWWUsbGUpLGRpc3Bvc2U6KCk9PntzLl9PcnRSZWxlYXNlVGVuc29yKEopIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIil9fSxcImdwdS1idWZmZXJcIl0pfWVsc2UgaWYoRmU9PT1cIm1sLXRlbnNvclwiJiZmZT4wKXtsZXQgeGU9cy5qc2VwRW5zdXJlVGVuc29yO2lmKCF4ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2lmKHd0KFNlLGZlKT09PXZvaWQgMHx8IVJyKGxlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtsZX1gKTtsZXQgWWU9YXdhaXQgeGUoZSxaLFNlLFksITEpO2VlPSEwLG5lLnB1c2goW2xlLFkse21sVGVuc29yOlllLGRvd25sb2FkOnMuanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihaLGxlKSxkaXNwb3NlOigpPT57cy5qc2VwUmVsZWFzZVRlbnNvcklkKFopLHMuX09ydFJlbGVhc2VUZW5zb3IoSil9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgeGU9QnIobGUpLGJlPW5ldyB4ZShmZSk7bmV3IFVpbnQ4QXJyYXkoYmUuYnVmZmVyLGJlLmJ5dGVPZmZzZXQsYmUuYnl0ZUxlbmd0aCkuc2V0KHMuSEVBUFU4LnN1YmFycmF5KFosWitiZS5ieXRlTGVuZ3RoKSksbmUucHVzaChbbGUsWSxiZSxcImNwdVwiXSl9fWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUodmUpLGxlPT09XCJzdHJpbmdcIiYmWiYmcy5fZnJlZShaKSxlZXx8cy5fT3J0UmVsZWFzZVRlbnNvcihKKSxzLmpzZXBPblJ1bkVuZD8uKHApfX1yZXR1cm4geSYmIV8mJihzLl9PcnRDbGVhckJvdW5kT3V0cHV0cyh5LmhhbmRsZSkhPT0wJiZoZShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHp0LnNldChlLFtwLGYsaCx5LF8sITFdKSksbmV9ZmluYWxseXtzLnN0YWNrUmVzdG9yZShrKSxULmZvckVhY2goaj0+cy5fT3J0UmVsZWFzZVRlbnNvcihqKSksQy5mb3JFYWNoKGo9PnMuX09ydFJlbGVhc2VUZW5zb3IoaikpLEEuZm9yRWFjaChqPT5zLl9mcmVlKGopKSwkIT09MCYmcy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksdi5mb3JFYWNoKGo9PnMuX2ZyZWUoaikpfX0sUHI9ZT0+e2xldCB0PUllKCksbj16dC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCByPW5bMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcocik7bz09PTAmJmhlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSx6cj1lPT57bGV0IHQ9W107Zm9yKGxldCBuIG9mIGUpe2xldCByPW5bMl07IUFycmF5LmlzQXJyYXkocikmJlwiYnVmZmVyXCJpbiByJiZ0LnB1c2goci5idWZmZXIpfXJldHVybiB0fX0pO3ZhciBPdCxIZSxhcixjbixwbixsbix6byxPbyxXdCxMdCxpYixZYyxYYyxKYyxlcCx0cCxycCxucCxEbz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtxbigpO2J0KCk7U3IoKTtPdD0oKT0+ISF3ZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsYXI9ITEsY249ITEscG49ITEsT289bmV3IE1hcCxXdD0oZSx0KT0+e2xldCBuPU9vLmdldChlKTtuP24ucHVzaCh0KTpPby5zZXQoZSxbdF0pfSxMdD0oKT0+e2lmKGFyfHwhY258fHBufHwhSGUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0saWI9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6YXI9ITEsZS5kYXRhLmVycj8ocG49ITAsem9bMV0oZS5kYXRhLmVycikpOihjbj0hMCx6b1swXSgpKSxsbiYmKFVSTC5yZXZva2VPYmplY3RVUkwobG4pLGxuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PU9vLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sWWM9YXN5bmMoKT0+e2lmKCFjbil7aWYoYXIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihwbil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKGFyPSEwLE90KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57SGU/LnRlcm1pbmF0ZSgpLEFzKCkudGhlbigoW24scl0pPT57dHJ5e0hlPXIsSGUub25lcnJvcj1hPT50KGEpLEhlLm9ubWVzc2FnZT1pYix6bz1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOndlfTshby5pbi53YXNtLndhc21QYXRocyYmKG58fGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSYmKG8uaW4ud2FzbS53YXNtUGF0aHM9e3dhc206bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmfSksSGUucG9zdE1lc3NhZ2UobyksbG49bn1jYXRjaChvKXt0KG8pfX0sdCl9KTt0cnl7YXdhaXQgVHIod2Uud2FzbSksYXdhaXQgQ3Iod2UpLGNuPSEwfWNhdGNoKGUpe3Rocm93IHBuPSEwLGV9ZmluYWxseXthcj0hMX19fSxYYz1hc3luYyBlPT57aWYoT3QoKSlyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e1d0KFwiaW5pdC1lcFwiLFt0LG5dKTtsZXQgcj17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmUsZW52OndlfX07SGUucG9zdE1lc3NhZ2Uocil9KTthd2FpdCBJcih3ZSxlKX0sSmM9YXN5bmMgZT0+T3QoKT8oTHQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e1d0KFwiY29weS1mcm9tXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwiY29weS1mcm9tXCIsaW46e2J1ZmZlcjplfX07SGUucG9zdE1lc3NhZ2UocixbZS5idWZmZXJdKX0pKTpZdChlKSxlcD1hc3luYyhlLHQpPT57aWYoT3QoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIEx0KCksbmV3IFByb21pc2UoKG4scik9PntXdChcImNyZWF0ZVwiLFtuLHJdKTtsZXQgbz17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6ey4uLnR9fX0sYT1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmYS5wdXNoKGUuYnVmZmVyKSxIZS5wb3N0TWVzc2FnZShvLGEpfSl9ZWxzZSByZXR1cm4gQXIoZSx0KX0sdHA9YXN5bmMgZT0+e2lmKE90KCkpcmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHQsbik9PntXdChcInJlbGVhc2VcIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07SGUucG9zdE1lc3NhZ2Uocil9KTtrcihlKX0scnA9YXN5bmMoZSx0LG4scixvLGEpPT57aWYoT3QoKSl7aWYobi5zb21lKHM9PnNbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihvLnNvbWUocz0+cykpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgocyxkKT0+e1d0KFwicnVuXCIsW3MsZF0pO2xldCBsPW4scD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bCxvdXRwdXRJbmRpY2VzOnIsb3B0aW9uczphfX07SGUucG9zdE1lc3NhZ2UocCx6cihsKSl9KX1lbHNlIHJldHVybiBFcihlLHQsbixyLG8sYSl9LG5wPWFzeW5jIGU9PntpZihPdCgpKXJldHVybiBMdCgpLG5ldyBQcm9taXNlKCh0LG4pPT57V3QoXCJlbmQtcHJvZmlsaW5nXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O0hlLnBvc3RNZXNzYWdlKHIpfSk7UHIoZSl9fSk7dmFyIG9wLGFiLG1uLGlwPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO0RvKCk7dGUoKTt4cigpO1huKCk7b3A9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0sYWI9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IHFlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIU1yKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6bixkb3dubG9hZDpyLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gcWUuZnJvbUdwdUJ1ZmZlcihuLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpyLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFScih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpuLGRvd25sb2FkOnIsZGlzcG9zZTpvfT1lWzJdO3JldHVybiBxZS5mcm9tTUxUZW5zb3Iobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxtbj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gSmMoYXdhaXQgZXIodCkpfWFzeW5jIGxvYWRNb2RlbCh0LG4pe05lKCk7bGV0IHI7dHlwZW9mIHQ9PVwic3RyaW5nXCI/cj1hd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpOnI9dCxbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IGVwKHIsbiksQmUoKX1hc3luYyBkaXNwb3NlKCl7cmV0dXJuIHRwKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxuLHIpe05lKCk7bGV0IG89W10sYT1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKHk9PntsZXQgXz15WzBdLGI9eVsxXSx3PXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKF8pO2lmKHc9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7X30nYCk7by5wdXNoKGIpLGEucHVzaCh3KX0pO2xldCBzPVtdLGQ9W107T2JqZWN0LmVudHJpZXMobikuZm9yRWFjaCh5PT57bGV0IF89eVswXSxiPXlbMV0sdz10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoXyk7aWYodz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7X30nYCk7cy5wdXNoKGIpLGQucHVzaCh3KX0pO2xldCBsPW8ubWFwKCh5LF8pPT5vcCh5LCgpPT5gaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1thW19dXX1cImApKSxwPXMubWFwKCh5LF8pPT55P29wKHksKCk9PmBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbZFtfXV19XCJgKTpudWxsKSxmPWF3YWl0IHJwKHRoaXMuc2Vzc2lvbklkLGEsbCxkLHAsciksaD17fTtmb3IobGV0IHk9MDt5PGYubGVuZ3RoO3krKyloW3RoaXMub3V0cHV0TmFtZXNbZFt5XV1dPXNbeV0/P2FiKGZbeV0pO3JldHVybiBCZSgpLGh9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7bnAodGhpcy5zZXNzaW9uSWQpfX19KTt2YXIgc3A9e307WnQoc3Ase09ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kOigpPT5mbixpbml0aWFsaXplRmxhZ3M6KCk9PmFwLHdhc21CYWNrZW5kOigpPT5zYn0pO3ZhciBhcCxmbixzYix1cD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtEbygpO2lwKCk7YXA9KCk9PntpZigodHlwZW9mIHdlLndhc20uaW5pdFRpbWVvdXQhPVwibnVtYmVyXCJ8fHdlLndhc20uaW5pdFRpbWVvdXQ8MCkmJih3ZS53YXNtLmluaXRUaW1lb3V0PTApLHdlLndhc20uc2ltZD09PSExJiZjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiBub24tU0lNRCBidWlsZCBpcyBubyBsb25nZXIgcHJvdmlkZWQsIGFuZCB0aGlzIHNldHRpbmcgd2lsbCBiZSBpZ25vcmVkLicpLHR5cGVvZiB3ZS53YXNtLnByb3h5IT1cImJvb2xlYW5cIiYmKHdlLndhc20ucHJveHk9ITEpLHR5cGVvZiB3ZS53YXNtLnRyYWNlIT1cImJvb2xlYW5cIiYmKHdlLndhc20udHJhY2U9ITEpLHR5cGVvZiB3ZS53YXNtLm51bVRocmVhZHMhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHdlLndhc20ubnVtVGhyZWFkcyl8fHdlLndhc20ubnVtVGhyZWFkczw9MClpZih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCl3ZS53YXNtLm51bVRocmVhZHM9MTtlbHNle2xldCBlPXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/Tm4oXCJub2RlOm9zXCIpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7d2Uud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKChlfHwxKS8yKSl9fSxmbj1jbGFzc3thc3luYyBpbml0KHQpe2FwKCksYXdhaXQgWWMoKSxhd2FpdCBYYyh0KX1hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LG4pe2xldCByPW5ldyBtbjtyZXR1cm4gYXdhaXQgci5sb2FkTW9kZWwodCxuKSxQcm9taXNlLnJlc29sdmUocil9fSxzYj1uZXcgZm59KTtHZSgpO0dlKCk7R2UoKTt2YXIgaHM9XCIxLjIxLjBcIjt2YXIgbFQ9Rm47e2xldCBlPSh1cCgpLGJyKHNwKSkud2FzbUJhY2tlbmQ7Q3QoXCJ3ZWJncHVcIixlLDUpLEN0KFwid2Vibm5cIixlLDUpLEN0KFwiY3B1XCIsZSwxMCksQ3QoXCJ3YXNtXCIsZSwxMCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHdlLnZlcnNpb25zLFwid2ViXCIse3ZhbHVlOmhzLGVudW1lcmFibGU6ITB9KTtleHBvcnR7T2YgYXMgSW5mZXJlbmNlU2Vzc2lvbix2ciBhcyBUUkFDRSxOZSBhcyBUUkFDRV9GVU5DX0JFR0lOLEJlIGFzIFRSQUNFX0ZVTkNfRU5ELHFlIGFzIFRlbnNvcixsVCBhcyBkZWZhdWx0LHdlIGFzIGVudixDdCBhcyByZWdpc3RlckJhY2tlbmR9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?d16c\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fpreload-css.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fevobidev%2FDesktop%2FReact%2Fonnx-ml%2Fsrc%2Fcomponents%2FDigitRecognizer.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);